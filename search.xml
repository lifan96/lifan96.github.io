<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库知识分析]]></title>
    <url>%2F2019%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[设计数据库 索引模块 为什么要使用索引？ 快速查询数据 什么样的信息能成为索引？ 主键、唯一键以及普通索引等 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立B-Tree结构进行查找 生成索引，建立B+-Tree结构进行查找 生成索引，建立Hash结构进行查找 B-Tree 根节点至少包括两个孩子 树中每个节点最多含有m个孩子（m&gt;=2） 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子（ceil（）取上限） 所有叶子节点都位于同一层 B+-Tree 其定义基本与B树相同 非叶子节点的子树指针与关键字个数相同 非叶子节点的子树指针P[i]，指向关键字值 [k[i],k[i+1]) 子树 非叶子节点仅用来索引，数据都保存在叶子节点中 所有叶子节点均有一个链指针指向下一个叶子节点 结论 B+Tree更适合用来存储索引 B+树的磁盘读写代价更低 B+树的查询效率更加稳定 B+树更有利于对数据库的扫描 Hash索引 缺点 仅仅能满足“=”，“IN”，不能使用范围查询 无法被用来避免数据的排序操作 不能利用部分索引键查询 不能避免表扫描 遇到大量Hash值相等的情况后性能比不一定就会比B-Tree索引高\ BitMap索引是个神器（位图索引） 密集索引和稀疏索引的区别 密集索引文件中的每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 InnoDB 若一个主键被定义，该主键则作为密集索引 若没有主键被定义，该表的第一和唯一非空索引则作为密集索引 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引） 非主键索引存储相关键位和其对应的主键值，包含两次查找 问题 如何定位并优化慢查询SQL 根据慢日志定位慢查询SQL 使用explain等工具分析SQL type：出现index、all则需要优化 extra：出现using filesort、using temporary则需要优化 修改SQL或者尽量让SQL走索引 123alter table person_info_large add index idx_name(name); /*为某个字段增加索引*//*强制通过某个索引查询*/select count(id) from person_info_large force index(primary); 联合索引的最左匹配原则的成因 联合索引：有两个字段组成的索引 最左匹配原则：mysql会一直向右匹配直到遇到范围查询就停止匹配 = 和 in 可以乱序，mysql的查询优化器会帮你优化成索引可以识别的形式 直接使用第二个字段是用不到索引的 索引是建立得越多越好吗？ 不是。 数据量小的表不需要建立索引，建立会增加额外的索引开销 数据变更需要维护索引，因此更多的索引意味着更多的维护成本 更多的索引也意味着需要更多的空间 MyISAM与InnoDB关于锁方面的区别是什么？ MyISAM默认用的是表级锁，不支持行级锁 InnoDB默认用的是行级锁，也支持表级锁 二段锁：加锁和解锁是分成两个步骤进行的 共享锁：上了共享锁之后，依然可以上共享锁，不支持上排它锁 排它锁：上了排它锁，另外的读或写都是不能操作的 MyISAM适合的场景 频繁执行全表count语句 对数据进行增删改的频率不高，查询非常频繁 没有事务 InnoDB适合的场景 数据增删改查都相当频繁 可靠性比较高，要求支持事务 数据库锁的分类 按锁的粒度划分，可分为表级锁、行级锁、页级锁 按锁级别划分，可分为共享锁、排它锁 按加锁方式划分，可分为自动锁、显示锁 按操作划分，可分为DML锁（表数据）、DDL锁（表结构） 按使用方式划分，可分为乐观锁、悲观锁 数据库事务的四大特性ACID 原子性（Atomic）：事务包含的所有操作，要么全部执行，要么全部回滚 一致性（Consistency）：事务应确保数据库的状态从一致状态到另一个一致状态，一致性状态，也就是数据的完整性 隔离性（Isolation）：一个事务的执行不能影响其他事物的执行 持久性（Durability）：当系统或者介质发生故障时，确保以提交事务的更新不能丢失，即对已提交事物的更新能恢复 事务隔离级别以及各级别下的并发访问问题 更新丢失（一个事务的更新覆盖了另一个事务的更新）— mysql所有事务隔离级别在数据库层面上均可避免 脏读 — READ-COMMTTED事务隔离级别以上可避免 一个事务读到一个未提交事务的数据 不可重复读 — REPEATABLE-READ事务隔离级别以上可避免 事务A多次读取同一数据，在读取过程中进行了数据的更新并提交，事务A多次读取数据时不一致 幻读 — SERIALIZABLE事务隔离级别可避免 事务A读取与搜索条件相匹配的若干行，事务B插入或删除行修改事务A的结果集，导致事务A看起来像出现幻觉一样 InnoDB可重复读隔离级别下如何避免幻读 表象：快照读（非阻塞读） – 伪MVCC 当前读：select … lock in share mode,select…for udate，update，delete，insert 快照读：不加锁的非阻塞读，select 内在：next-key锁（行锁+gap锁） 行锁 Gap锁 对主键索引或者唯一索引会用Gap锁吗？ 如果where条件全部命中，则不会用Gap锁，只会加记录锁 如果where条件部分命中或者全不命中，则会用Gap锁 Gap锁会用在非唯一索引或者不走索引的当前读中 RC、RR级别下的InnoDB的非阻塞读如何实现 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段 undo日志 read view 语法部分 GROUP BY HAVING：过滤组 统计相关：COUNT，SUM，MAX，MIN，AVG]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[理解计算机网络知识点]]></title>
    <url>%2F2019%2F08%2F%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[网络分层（自底向上） OSI 七层参考模型 1.1 物理层 主要定义物理设备的标准，如网线类型，光纤的接口类型等 单位：传输比特流（0101）转换为机器码 1.2 数据链路层 如何格式化数据以进行传输，控制对物理介质的访问。提供对错误的检测和纠正，确保传输的可 靠性 单位：将比特数据—&gt;帧 1.3 网络层 将网络地址翻译成对应的物理地址，如何将发送方的数据路由到接收方 路由器属于网络层 单位：数据报 主要协议：IP 1.4 传输层 解决主机之间的数据传输，可以是不同网络之间 单位：分段 TCP：面向连接的、可靠的、基于字节流的传输层通信协议 UDP 1.5 会话层 建立和管理应用程序之间的通信 1.6 表示层 信息的语法语义以及它们的关联 1.7 应用层 HTTP协议 TCP/IP TCP的三次握手 TCP简介 面向连接的、可靠的、基于字节流的传输层通信协议 将应用层的数据流分隔成报文段并发送给目标节点的TCP层 数据包都有序号，对方收到则发送ACK确认，未收到则重传 使用奇偶校验和来检验数据在传输过程中是否有错误 TCP Flags URG：紧急指针标志 为1时表示有效，为0则忽略 ACK：确认序号标志 为1时表示有效，为0不含确认信息，则忽略 PSH：push标志 为1时指示接收方在接收到的报文段尽快交给应用程序，而不是在缓冲区排队 RST：重置连接标志 用于重置由于主机崩溃产生的错误连接、非法的报文段和拒绝连接 SYN：同步序号，用于建立连接过程 FIN：finish标志，用于释放连接 流程 第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，进入SYN_SEND状态，等待服务器确认 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=ack+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 问题 为什么需要三次握手才能建立起连接？ 为了初始化Sequence Number的初始值 首次握手的隐患—SYN超时 Server收到Client的SYN，回复SYN-ACK的时候未收到ACK的确认 Server不断重试直至超时，Linux默认等待63秒才断开连接 针对SYN Flood的防护措施 SYN队列满后，通过tcp_syncookies参数回发SYN Cookie 若为正常连接则Client会回发SYN Cookie，直接建立连接 建立连接后，Client出现故障怎么办？ 保活机制 向对方发送保活探测报文，如果未收到响应则继续发送 尝试次数达到保活探测数仍未收到响应则中断连接 TCP的四次挥手“挥手”是为了终止连接 流程 第一次挥手：Client发送一个FIN，用来关闭Client到server的数据传送，Client进入FIN_WAIT_1状态 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手 问题 为什么会有TIME_WAIT状态？ 确保有足够的时间让对方收到ACK包 避免新旧连接混淆 为什么需要四次握手才能断开连接？ 因为全双工，发送方和接收方都需要FIN报文和ACK报文 服务器出现大量CLOSE_WAIT状态的原因 对方关闭Socket连接，我方忙于读或写，没有及时关闭连接 检查代码，特别是释放资源的代码 检查配置，特别是处理请求的线程配置 TCP和UDP的区别 面向连接 VS 无连接 可靠性 有序性 速度 量级 TCP的滑动窗口 RTT和RTO RTT：发送一个数据包到收到对应的ACK，所花费时间 RTO：重传时间间隔 TCP使用滑动窗口做流量控制与乱序重排 保证TCP的可靠性 保证TCP的流控特性 窗口数据的计算过程 AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd - LastByteRead) EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked) TCP会话的发送方 四种状态 Sent and Acknowledged Sent But Not Yet Acknowledged（发送窗口） Not Sent Recipient Ready to Receive（发送窗口） Not Sent Recipient NOT Ready to Receive TCP会话的接收方 三种状态 Received and Acknowledged Not Yet Received，Transmitter Permitted To Send（接收窗口） Not Yet Received，Transmitter May Not Send HTTP 超文本传输协议特点： 支持客户、服务器模式 简单快速 灵活 无连接 无状态 HTTP请求结构 HTTP响应结构 请求/响应的步骤 客户端连接到Web服务器 发送HTTP请求 服务器接收请求并返回HTTP响应 释放TCP连接 客户端浏览器解析HTML内容 HTTP状态码 五种 1xx：指示信息—表示请求已接收，继续处理 2xx：成功—表示请求已被成功接收、理解、接受 3xx：重定向—要完成请求必须进行更进一步地操作 4xx：客户端错误—请求有语法错误或请求无法实现 5xx：服务器端错误—服务器未能实现合法的请求 问题 在浏览器地址栏键入URL，按下回车之后经历的流程？ DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 常见的HTTP状态码 200 OK：正常返回信息 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在，eg，输入错误的URL 500 InternalServer Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间可能恢复正常 GET请求和POST请求的区别 Http报文层面：GET将请求信息放在URL,POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 其他层面：GET可以被缓存、被存储，而POST不行 Cookie和Session的区别 4.1 Cookie简介 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求时，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie的设置以及发送过程 4.2 Session简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息 使用Cookie来实现 使用URL回写来实现 4.3 区别 Cookie数据存放在客户端的浏览器上，Session数据放在服务器上 Session相对于Cookie更安全 若考虑减轻服务器负担，应当使用CookieHTTP和HTTPS的区别 SSL简介（Security Sockets Layer，安全套接层） 为网络通信提供安全及数据完整性的一种安全协议 是操作系统外的API，SSL3.0后更名为TLS 采用身份验证和数据加密保证网络的安全和数据的完整性 加密方式 对称加密：加密解密都是用同一个秘钥 非对称加密：加密使用的秘钥和解密使用的秘钥是不相同的 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 数字签名：证明某个消息或文件是某人发出/认同的 HTTPS数据传输流程 浏览器将支持的加密算法信息发送给服务器 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器 浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据 HTTP和HTTPS的区别 HTTPS需要到CA申请证书，HTTP不需要 HTTPS密文传输，HTTP明文传输 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS = HTTP +加密 +认证+完整性保护，较HTTP安全 Socket]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F08%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven能解决什么问题 引入工程所需的各种jar包 编译代码 可以进行单元测试 打包项目、部署项目 仓库种类 本地仓库 远程仓库【私服】 中央仓库 Maven常用的命令 mvn complie：compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target 目录下。 mvn test： maven 工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 mvn clean： maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 mvn package：package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于web 工程打成war包。 mvn install：install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 注：当后面的命令执行时，前面的操作过程也都会自动执行， Maven 生命周期 Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点 创建web项目问题 出现不能没有创建servlet的选项，在pom文件中加入 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F08%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis 数据结构redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ：不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串String 存储：set key value 获取： get key 删除： del key 哈希类型 hash 存储： hset key field value 获取： hget key field：获取指定的field对应的值 hgetall key ：获取所有的field和value 删除： hdel key field 列表类型 list 添加：可以添加一个元素到列表的头部（左边）或者尾部（右边） lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取：lrange key start end：范围获取 删除： lpop key：删除列表最左边的一个元素，并将元素返回 rpop key：删除列表最右边的一个元素，并将元素返回 集合类型 set 存储：sadd key value 获取：smembers key:获取set集合中所有元素 删除：srem key value:删除set集合中的某个元素 有序集合类型 sortedset 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value 持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB： 1234567891011* 默认方式，不需要进行配置，默认就使用这种机制* 在一定的间隔时间中，检测key的变化情况，然后持久化数据1.编辑redis.windows.conf 文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 100002.重新启动redis服务器，并指定配置文件名称 * redis目录下打开cmd，输入redis-server.exe redis.windows.conf AOF： 12345678* 日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据1.编辑redis.windows.conf 文件 appendonly no(关闭aof)---&gt;appendonly yes (打开aof) # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化2.重新启动redis服务器，并指定配置文件名称 * redis目录下打开cmd，输入redis-server.exe redis.windows.conf Jedis Jedis: 一款java操作redis数据库的工具 使用步骤： 下载jedis的jar包 使用 123456//1.获取连接Jedis jedis = new Jedis("localhost",6379);//2.操作jedis.set("username","zhangsan");//3.关闭连接jedis.close(); Jedis中的方法与各种数据结构的操作名字一致 Jedis 连接池 使用 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接 面试相关 为什么Redis能这么快？ 100000+QPS（QPS，每秒内查询的次数） 完全基于内存，绝大部分请求是纯粹的内存操作，执行下率高 数据结构简单，对数据操作也简单 采用单线程 多路I/O复用模型 FD：File Description，文件描述符 一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的的映射 Select系统调用 从海量key里查询出某一固定前缀的Key 摸清数据规模，即问清楚边界 KEYS pattern：查找所有符合给定模式pattern的key KEYS指令一次性返回所有匹配的key 键的数量过大会使服务卡顿 SCAN cursor [MATCH pattern] [COUNT count] 基于游标的迭代器（cursor），需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 使用封装的相关jar包，如jedis，里面的方法进行查询 如何通过Redis实现分布式锁 分布式锁需要解决的问题 互斥性 安全性 死锁 容错 SETNX key value：如果key不存在，则创建并赋值 时间复杂度：O(1) 返回值：设置成功，返回1；设置失败，返回0 如何解决SETNX长期有效的问题 EXPIRE key seconds 设置key的生存时间，当key过期时（生存时间为0），会被自动删除 缺点：原子性得不到满足 SET key value [Ex seconds] [PX milliseconds] [NX|XX] Ex seconds：设置键的过期时间（秒） PX milliseconds：设置键的过期时间（毫秒） NX：只在键不存在时，才对建进行设置操作 XX：只在键已经存在时，才对键进行设置操作 SET操作成功完成时，返回OK，否则返回nil 大量的key同时过期的注意事项 解放方案：在设置key的过期时间的时候，给key加上随机值 如何使用Redis做异步队列 使用List作为队列，RPUSH生产消息，LPOP消费消息 缺点：没有等待队列里有值就直接消费 弥补：可以通过在应用层引入Sleep机制去调用LPOP重试 BLPOP key [key…] timeout：阻塞直到队列有消息或者超时 缺点：只能供一个消费者消费 pub/sub：主题订阅者模式 订阅者（pub）发送消息，订阅者（sub）接受消息 订阅者可以订阅任意数量的频道（Topic） 缺点：消费的发布是无状态的，无法保证可达 使用Pipeline的好处 批量执行指令，节省多次IO往返的时间 有顺序依赖的指令建议分批发送 Redis的同步机制 主从同步原理 全同步过程 Salve发送sync命令道Master Master启动一个后台进程，将Redis中的数据快照保存到文件中 Master将保存数据快照期间接收到的写命令缓存起来 Master完成写文件操作后，将该文件发送给Salve 使用新的AOF文件替换掉就的AOF文件 Master将这期间收集的增量写命令发送给Salve端 增量同步过程 Master接收到用户的操作指令，判断是否需要传播到Slave 将操作记录追加到AOF文件 将操作传播到其他Salve： 对齐主从库 往响应缓冲写入指令 将缓存中的数据发送给Salve Redis的集群原理 分片：按照某种规则去划分数据，分散存储在多个节点上 常规的按照哈希划分无法实现节点的动态增减 一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环 将数据key使用相同的函数Hash计算出Hash值 引入虚拟节点解决数据倾斜的问题]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax&Json]]></title>
    <url>%2F2019%2F08%2FAJAX%26JSON%2F</url>
    <content type="text"><![CDATA[AJAX 概念：ASynchronous JavaScript And XML 异步的JavaScript 和 XML 异步和同步：客户端和服务器端相互通信的基础上 12345678同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。详细解释：Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。好处：提升用户体验 实现方式： 原生JS实现方式（了解） JQuery实现方式 $.ajax() 123456789101112131415161718&lt;script&gt; function fuc() &#123; //使用$.ajax()发送异步请求 $.ajax(&#123; url:"ajaxServlet", //请求路径 type:"post", //请求方式，默认get //data:"username=jack&amp;age", //请求参数 data:&#123;"username":"jack","age":23&#125;, success:function (data) &#123; alert(data) &#125;,//响应成功后的回调函数 error:function () &#123; alert("出错了...") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:"text",//设置接收到的数据的格式 &#125;); &#125; &lt;/script&gt; $.get()：发送get请求 123456* 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 $.post()：发送post请求 123456* 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON 概念：JavaScript Object Notation JavaScript对象表示法 json现在多用于存储和交换文本信息的语法 进行数据的传输 JSON 比 XML 更小、更快，更易解析。 基本规则 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 1234567值得取值类型：1. 数字（整数或浮点数）2. 字符串（在双引号中）3. 逻辑值（true 或 false）4. 数组（在方括号中）&#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125;5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125;6. null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{ }定义 json 格式 方括号保存数组：[] 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 123456789101112131415161718&lt;script&gt; var person = &#123;"name":"张三",age:23,'gender':true&#125;; var ps = [&#123;"name": "张三", "age": 23, "gender": true&#125;, &#123;"name": "李四", "age": 24, "gender": true&#125;, &#123;"name": "王五", "age": 25, "gender": false&#125;]; for (var key in person)&#123; //alert(key + ":" + person.name); alert(key + ":" + person[key]) &#125; for (var i = 0; i&lt; ps.length;i++)&#123; var p = ps[i]; for (var key in p)&#123; alert(key + ":" + p[key]); &#125; &#125; &lt;/script&gt; JSON数据和Java对象的相互转换 常见的JSON解析器：Jsonlib，Gson，fastjson，jackson JSON转换为Java对象 12345使用步骤： * 导入jackson的相关jar包 * 创建Jackson核心对象 ObjectMapper * 调用ObjectMapper的相关方法进行转换 * readValue(json字符串数据，Class) Java对象转换JSON 1234使用步骤： * 导入jackson的相关jar包 * 创建Jackson核心对象 ObjectMapper * 调用ObjectMapper的相关方法进行转换 转换方法 123456* writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中* writeValueAsString(obj):将对象转为json字符串 注解 @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern = “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于多线程]]></title>
    <url>%2F2019%2F08%2F%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 创建多线程创建Thread类的子类java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类 实现步骤: 1.创建一个Thread类的子类 2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?) 3.创建Thread类的子类对象 4.调用Thread类中的方法start方法,开启新的线程,执行run方法 void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行 实现Runnable接口实现步骤: 1.创建一个Runnable接口的实现类 2.在实现类中重写Runnable接口的run方法,设置线程任务 3.创建一个Runnable接口的实现类对象 4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象 5.调用Thread类中的start方法,开启新的线程执行run方法 实现Runnable接口创建多线程程序的好处:1.避免了单继承的局限性 一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类 实现了Runnable接口,还可以继承其他的类,实现其他的接口 2.增强了程序的扩展性,降低了程序的耦合性(解耦) 实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦) 实现类中,重写了run方法:用来设置线程任务 创建Thread类对象,调用start方法:用来开启新线程 获取线程名称1.使用Thread类中的方法getName() String getName() 返回该线程的名称。2.可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称 static Thread currentThread() 返回对当前正在执行的线程对象的引用。 Thread.currentThread().getName() 设置线程名称（了解）1.使用Thread类中的方法setName(名字) void setName(String name) 改变线程名称，使之与参数 name 相同。2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字 Thread(String name) 分配新的 Thread 对象。 线程睡眠public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行 使用：Thread.sleep(暂停时间) 匿名内部类实现线程的创建匿名:没有名字内部类:写在其他类内部的类 匿名内部类作用:简化代码把子类继承父类,重写父类的方法,创建子类对象合一步完成把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成匿名内部类的最终产物:子类/实现类对象,而这个类没有名字 格式: new 父类/接口(){ 重复父类/接口中的方法 }; 123456789101112131415161718192021222324252627282930313233343536373839public class Demo01InnerClassThread &#123; public static void main(String[] args) &#123; //线程的父类是Thread // new MyThread().start(); new Thread()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"黑马"); &#125; &#125; &#125;.start(); //线程的接口Runnable //Runnable r = new RunnableImpl();//多态 Runnable r = new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"程序员"); &#125; &#125; &#125;; new Thread(r).start(); //简化接口的方式 new Thread(new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"传智播客"); &#125; &#125; &#125;).start(); &#125;&#125; 2. 解决线程安全使用同步代码块格式:synchronized(锁对象){ 可能会出现线程安全问题的代码(访问了共享数据的代码) } 注意: 1.通过代码块中的锁对象,可以使用任意的对象 2.但是必须保证多个线程使用的锁对象是同一个 3.锁对象作用:把同步代码块锁住,只让一个线程在同步代码块中执行 使用同步方法使用步骤:1.把访问了共享数据的代码抽取出来,放到一个方法中2.在方法上添加synchronized修饰符 格式:定义方法的格式修饰符 synchronized 返回值类型 方法名(参数列表){ 可能会出现线程安全问题的代码(访问了共享数据的代码) } 使用Lock锁解决线程安全问题的三种方案:使用Lock锁java.util.concurrent.locks.Lock接口Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。Lock接口中的方法: void lock()获取锁。 void unlock() 释放锁。 java.util.concurrent.locks.ReentrantLock implements Lock接口 使用步骤:1.在成员位置创建一个ReentrantLock对象2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 3. 线程状态 Timed Waiting （计时等待）进入到TimeWaiting(计时等待)有两种方式1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态 唤醒的方法: void notify() 唤醒在此对象监视器上等待的单个线程。 void notifyAll() 唤醒在此对象监视器上等待的所有线程。 BLOCKED （锁阻塞） Waiting （无限等待） 等待唤醒案例:线程之间的通信创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子 注意: 顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行 同步使用的锁对象必须保证唯一 只有锁对象才能调用wait和notify方法 4. 线程通信 概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2019%2F08%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数式编程思想概述面向对象的思想: ​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: ​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 Lambda表达式的标准格式​ 由三部分组成:​ a.一些参数​ b.一个箭头​ c.一段代码​ 格式:​ (参数列表) -&gt; {一些重写方法的代码};​ 解释说明格式:​ ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔​ -&gt;:传递的意思,把参数传递给方法体{}​ {}:重写接口的抽象方法的方法体 12//使用Lambda表达式，实现多线程new Thread(()-&gt;&#123;System.out.println(Thread.currentThread().getName()+"新的线程创建了");&#125;).start(); Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2019%2F08%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一章 网络编程入门1.1 软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 1.3 协议分类 UDP：面向无连接通信协议—&gt;即在数据传输时，数据的发送端和接收端不建立逻辑连接。 数据报：网络传输的基本单位 特点：消耗资源小，通信效率高；数据被限制在64kb以内 应用于：音频、视频和普通数据传输 TCP：传输控制协议；面向连接的通信协议—&gt;即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 第一次握手：客户端向服务器发出连接请求，等待服务器确认 第二次握手：服务器向客户端返回一个响应，通知客户端收到了连接请求 第三次握手：客户端再次向服务器端发送确认信息，确认连接 应用于：下载文件、浏览网页等 1.4 网络编程的三要素 协议 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式*，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 端口号 端口号是一个逻辑端口；当我们使用网络软件时，操作系统就会为网络软件分配一个随机的端口号或者网络软件打开的时候系统会指定一个端口号 组成：有两个字节组成，取值范围在0~65535之间 注意：1024之前的端口号不能使用，已经被系统分配给已知的网络软件 ​ 网络软件的端口号不能重复 常用端口号：80：网络端口；3306：MySQL；1521：Oracle；8080：Tomcat服务器 第二章 TCP通信程序2.1 概述两端通信时步骤 服务器端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功后才能通信。服务器端不可以主动连接客户端。 Java实现TCP通信的两个类 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 简单记：服务器使用客户端的流和客户端交互 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是包含了IP地址和端口号的网络单位。 构造方法 Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号 参数： String host：服务器的名称、服务器的IP地址 int port：服务器的端口号 成员方法： OutputStream getOutputStream()：返回此套接字的输出流 InputStream getInputStream()：返回此套接字的输入流 void close()：关闭此套接字 创建步骤 创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号 使用Socket对象中的方法getOutputStream()获取网络字节输出流对象 使用网络字节输出流OutputStream 对象中的方法write，给服务器发送数据 使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 释放资源（Socket） 注意 客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象 当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接 这时如果服务器没有启动，那么就会抛出异常 1234567891011121314151617181920212223import java.io.IOException;import java.io.OutputStream;import java.net.Socket;public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket("127.0.0.1",8888); OutputStream os = socket.getOutputStream(); os.write("你好服务器".getBytes()); //4. 使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象 //5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据 InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); String msg = new String(bytes, 0, len); System.out.println(msg); socket.close(); &#125;&#125; 2.3 ServerSocket类ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 ServerSocket(int port)：创建绑定到特定端口的服务器套接字 成员方法 Socket accept()：侦听并接受到此套接字的连接 服务器必须明确—&gt;必须知道是哪个客户端请求的服务器，所以可以使用accept方法获取到请求的客户端对象Socket 服务器端实现步骤 创建ServerSocket对象和系统要指定的端口号 使用ServerSocket对象中的方法accept方法，获取到请求的客户端对象Socket 使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象 使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据 使用Socket对象中的方法getOutputStream()获取网络字节输出流对象 使用网络字节输出流OutputStream 对象中的方法write，给客户端回写数据 释放资源（Socket，ServerSocket） 12345678910111213141516171819202122232425import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(8888); Socket socket = serverSocket.accept(); InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); String msg = new String(bytes, 0, len); System.out.println(msg); OutputStream os = socket.getOutputStream(); os.write("收到谢谢".getBytes()); socket.close(); serverSocket.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Filter&Listener]]></title>
    <url>%2F2019%2F08%2FFilter%26Listener%2F</url>
    <content type="text"><![CDATA[Filter 过滤器 概念： web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 使用步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 @WebFilter(“/*”)//访问所有资源之前，都会执行该过滤器 过滤器细节 web.xml 配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.lifan.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!--拦截路径--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器声明周期方法 init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter：每一次请求被拦截资源时，会执行。执行多次 destory：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解 拦截路径配置： 12341. 具体资源路径：/index.jsp 只有访问index.jsp资源时，过滤器才会被执行2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 123456789* 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源* web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链（配置多个过滤器） 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1过滤器1--&gt;过滤器2--&gt;资源执行--&gt;过滤器2--&gt;过滤器1 过滤器先后顺序问题： 1231. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 增强对象的功能：使用设计模式（一些通用的解决固定问题的方式） 装饰模式 代理模式 12345678910111213141516* 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的* 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： * 代理对象和真实对象实现相同的接口 * Proxy.newProxyInstance(); * 使用代理对象调用方法 * 增强方法 * 增强方式： * 增强参数列表 * 增强返回值类型 * 增强方法体执行逻辑 Listener 监听器 事件监听机制 事件：一件事情 事件源：事件发生的地方（比如按钮） 监听器：一个对象 注册监听：将事件、事件源、监听器绑定在一起。当时事件源上发生某个事件后，执行监听器代码 ServletContextListener（接口） 创建 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 销毁 void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 实现步骤 12345678910* 定义一个类，实现ServletContextListener接口 * 复写方法 * 配置 * web.xml &lt;listener&gt; &lt;listener-class&gt;cn.lifan.listener.ContextLoderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; * 注解 @WebListener]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSP&EL&JSTL]]></title>
    <url>%2F2019%2F07%2FJSP%26EL%26JSTL%2F</url>
    <content type="text"><![CDATA[JSP 指令 作用：用于配置JSP页面，导入资源文件 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2…%&gt; 分类： page：配置JSP页面 12345678* contentType：等同于response.setContentType() * 设置响应体的mime类型以及字符集 * 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）* import：导包* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面* isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception include：页面包含的。导入页面的资源文件 1* &lt;%@include file=&quot;top.jsp&quot;%&gt; taglib：导入资源 12* &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; * prefix：前缀，自定义的 注释 html注释：\:只能注释html代码片段 jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有 内置对象 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象MVC M：Model，模型 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入–&gt;调用模型–&gt;将数据交给视图进行展示 优缺点： 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意： 123* jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. \$&#123;表达式&#125; ：忽略当前这个el表达式 使用 运算 12345671. 算数运算符： + - * /(div) %(mod)2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)4. 空运算符： empty * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 * $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0 * $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 123456789101112131415161718192021222324251. el表达式只能从域对象中获取值2. 语法： * $&#123;域名称.键名&#125;：从指定域中获取指定键的值 * 域名称： 1. pageScope--&gt; pageContext 2. requestScope--&gt; request 3. sessionScope--&gt; session 4. applicationScope--&gt; application（ServletContext） * 举例：在request域中存储了name=张三 * 获取：$&#123;requestScope.name&#125; * $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 $&#123;name&#125; * 获取对象、List集合、Map集合的值 * 对象：$&#123;域名称.键名.属性名&#125; *本质上会去调用对象的getter方法 * 简写：$&#123;键名.属性名&#125; * List集合：$&#123;域名称.键名[索引]&#125; * Map集合： * $&#123;域名称.键名.key名称&#125; * $&#123;域名称.键名[&quot;key名称&quot;]&#125;3.隐式对象： * el表达式中有11个隐式对象 * pageContext： * 获取jsp其他八个内置对象 * $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录 JSTL 概念：JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 使用标签 常用的 JSTL标签 if：相当于java代码的if语句 123456属性： * test 必须属性，接受boolean表达式 * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 * 一般情况下，test属性值会结合el表达式一起使用 注意： * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose：相当于java代码的switch语句 123* 使用choose标签声明 相当于switch声明* 使用when标签做判断 相当于case* 使用otherwise标签做其他情况的声明 相当于default foreach：相当于java代码的for语句 12345678910111213141516普通遍历（for）： 属性： * begin：开始值 * end：结束值（包含） * var：临时变量 * step：步长 * varStatus：循环状态对象 * index：容器中元素的索引，从0开始 * count：循环次数，从1开始遍历容器（foreach）： 属性： * items：容器对象 * var：容器中的临时变量 * varStatus：循环状态对象 * index：容器中元素的索引，从0开始 * count：循环次数，从1开始]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[会话技术]]></title>
    <url>%2F2019%2F07%2F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie 概念：客户端会话技术，将数据保存到客户端 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name,String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 Cookie 细节 一次可不可以发送多个cookie? 1可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 12345* 默认情况下，当浏览器关闭后，Cookie数据被销毁* 持久化存储：setMaxAge(int seconds) * 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到 后，cookie文件自动失效 * 负数：默认值 * 零：删除cookie信息 cookie能不能存中文？ 123* 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码 ---&gt; 一般采用URL编码(%E3)* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 12345671. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？* 默认情况下cookie不能共享* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot;2. 不同的tomcat服务器间cookie共享问题？* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie 的特点和作用 特点： cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存储少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 JSP 概念：Java Server Pages： java服务器端页面 原理：JSP本质上就是一个Servlet（JSP–&gt;.java–&gt;class–&gt;执行） JSP的脚本： &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置（成员变量或方法）。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象：在jsp页面中不需要获取和创建，可以直接使用的对象 request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。 入门： 获取HTTPSession对象 1HttpSession session = request.getSession(); 使用HTTPSession对象 123Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 原理：Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 12345* 默认情况下。不是。* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());c.setMaxAge(60*60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 12345* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 Session什么时候被销毁？ 1234567* 服务器关闭* session对象调用invalidate() 自杀* session默认失效时间 30分钟选择性配置修改 （web.xml）&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Response]]></title>
    <url>%2F2019%2F07%2FResponse%2F</url>
    <content type="text"><![CDATA[HTTP协议 请求消息：客户端发送给服务器端的数据 数据格式： 请求行 请求头 请求空行 请求体 响应消息：服务器端发送给客户端的数据 数据格式： 响应行 组成：协议和版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器请求和响应的一个状态 1XX：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2XX：成功。代表：200 3XX：重定向。代表：302(重定向)，304(访问缓存) 4XX：客户端错误 404（请求路径没有对应的资源） 405：请求方式没有对应的doxxx方法 5XX：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：头名称 ：值 常见响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体：传输的数据 Response功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头 setHeader(String name, String value) 设置响应体 步骤： ① 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() ② 使用输出流，将数据输出到客户端浏览器 重定向 方式一 1234//1. 设置状态码为302response.setStatus(302);//2.设置响应头locationresponse.setHeader("location","/day15/responseDemo2"); 方式二 1response.sendRedirect("/day15/responseDemo2"); 转发和重定向之间的区别重定向的特点：redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 服务器输出字符数据到浏览器步骤： 获取字符输出流 输出数据 注意： 乱码问题： PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 12//简单的形式，设置编码，是在获取流之前设置response.setContentType("text/html;charset=utf-8"); 服务器输出字节数据到浏览器步骤： 获取字节输出流 1ServletOutputStream sos = response.getOutputStream(); 输出数据 1sos.write("你好".getBytes("utf-8")); ServletContext对象 概念：代表整个web应用，可以和程序的容器(服务器)来通信，一个web项目只包含一个 获取： 通过 request 对象获取 request.getServletContext(); 通过 HttpServlet 获取 this.getServletContext(); 获取MIME类型： MIME类型：在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 获取：String getMimeType(String file) 域对象：共享数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 获取文件的真实(服务器)路径 方法：String getRealPath(String path)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC相关问题]]></title>
    <url>%2F2019%2F07%2Fjdbc%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[导入驱动jar包 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 各个对象 DriverManager：驱动管理对象 * 功能： ① 注册驱动：**告诉程序该使用哪一个数据库驱动jar** static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125;&#125; **注意：mysql 5之后的驱动jar包可以省略注册驱动的步骤。** ​ ② 获取数据库连接： ​ 方法：static Connection getConnection(String url, String user, String password) ​ 参数： ​ url：指定连接的路径 ​ 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 ​ 例子：jdbc:mysql://localhost:3306/db3 ​ **细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简 写为：jdbc:mysql:///数据库名称** ​ user：用户名 ​ password：密码 Connection：数据库连接对象 功能： ① 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) ②管理事务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 ① 执行sql boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 - Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 结果集对象也需要关闭资源 PerparedStatement :执行sql对象 ① SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户任意，输入密码 ‘a’ or ‘a’ = ‘a’ (false or true) ② 解决SQL注入问题：使用 PreparedStatement 对象来解决 ③ 预编译的SQL：参数使用 ？作为占位符 ④ 给 ？赋值： 方法：setxxx(参数1，参数2) - 参数1：？的位置 从1开始 - 参数2：？的值 ## JDBC事务 ### 操作 - 开启事务：setAutoCommit(boolean autoCommit)：参数设置为false，即开始，默认为关闭 - 在执行sql之前开启事务 - 提交事务：commit() - 当所有sql都执行万提交事务 - 回滚事务：rollback() - 在catch中回滚事务 ## 数据库连接池 &gt; 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 1. 节约资源 2. 用户访问高效 标准接口：DataSource - 方法： - 获取连接：getConnection() - 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 - 数据库厂商实现 - C3P0：数据库连接池技术 - Druid：数据库连接池实现技术，由阿里巴巴提供的 ### C3P0数据库连接池技术 步骤： 1. 导入jar包 - c3p0-0.9.5.2.jar - mchange-commons-java-0.2.12.jar - mysql-connector-java-5.1.37-bin.jar（切记不能忘了导入这个） 2. 定义配置文件 - 名称： c3p0.properties 或者 c3p0-config.xml - 路径：直接将文件放在src目录下即可。 3. 创建核心对象 - 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection 注意： 1. 使用默认配置 1DataSource ds = new ComboPooledDataSource(); 2. 使用指定名称配置 1DataSource ds = new ComboPooledDataSource("otherc3p0"); ### Druid数据库连接池技术 步骤： 1. 导入jar包 - druid-1.0.9.jar 2. 定义配置文件 - properties形式 - 可以叫任意名称，可以放在任意目录下 3. 加载配置文件，使用Properties类 4. 获取数据库连接池对象：通过工厂类获取 DruidDataSourceFactory 5. 获取连接：getConnection 定义工具类： 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 - 获取连接方法：通过数据库连接池获取连接 - 释放资源 - 获取连接池的方法 ## Spring JDBC 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象，依赖于数据源DataSource 1JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 - update()：执行DML语句。增、删、改语句 - queryForMap()：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 。**注意：这个方法查询的结果集长度只能是1（真能查询一条记录）** - queryForList()：查询结果将结果集封装为list集合 - query()：查询结果，将结果封装为JavaBean对象 - query的参数：RowMapper - 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 - new BeanPropertyRowMapper&lt;类型&gt;(类型.class) - queryForObject：查询结果，将结果封装为对象 - 一般用于聚合函数的查询]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[servlet相关]]></title>
    <url>%2F2019%2F07%2Fservlet%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 实现接口中的方法 配置Servlet（在web.xml中配置） 12345678910&lt;!--配置 servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.lifan.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的中资源路径 查找web.xml文件，是否有对应的 标签体内容 如果有，则会 找到对应的全类名 tomact将字节码文件加载进内存，并创建其对象 调用其方法 Servlet 中的生命周期 被创建：执行init方法，只执行一次 Servlet 什么时候被创建？ 默认情况下，第一次访问时，Servlet被创建 可配置执行Servlet配置的时机 在下配置 第一次被访问时，创建 的值为负数 在服务器启动时，创建 的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例 多个用户同时访问时，可能存在线程安全问题 解决办法：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 提供服务：执行service方法，执行多次 每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 Servlet 3.0支持注解配置。可以不需要web.xml了 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法. 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) Servlet体系结构 GenericServlet 抽象类：将Servlet接口中做了默认空实现，只将service()方法作为抽象 定义servlet类时，可以继承GenericServlet，实现 service()方法即可 HttpServlet 抽象类：对 http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Http相关]]></title>
    <url>%2F2019%2F07%2FHttp%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Http特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求消息数据格式 请求行 请求方式 请求url 请求协议/版本 请求方式 GET POST 请求头 请求头名称 ：请求头值 User-Agent：浏览器告诉服务器，我访问你 使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用：防盗链、统计工作 请求空行 空行（起分隔作用） 请求体（正文） 封装POST请求消息的请求参数的]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动相关问题]]></title>
    <url>%2F2019%2F07%2FTomcat%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[可能遇到的问题 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano 温柔：修改自身的端口号 conf/server.xml 123&lt;Connector port="8888" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8445" /&gt; - 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 - 好处：在访问时，就不用输入端口号 部署 直接将项目放到webapps目录下即可。 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。war包会自动解压缩 配置conf/server.xml文件 在标签体中配置 docBase:项目存放的路径 path：虚拟目录 在conf\Catalina\localhost创建任意名称的xml文件。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[注解相关问题]]></title>
    <url>%2F2019%2F07%2F%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[预定义注解 @Override：检测被该注解标注的方法是否是继承自父类（接口）的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告 一般传递参数@suppressWarnings(“all”) 注解的本质本质上就是一个接口，该接口默认继承Annotation接口 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 定义了属性，给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解用于描述注解的注解 @Target：描述注解能够作用的位置 @Retention：描述注解被保留的阶段 @Document：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2F2019%2F07%2FRequest%2F</url>
    <content type="text"><![CDATA[Request和Response对象原理 Tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo1的对象 Tomcat服务器，会创建request和 response对象，request对象中封装请求数据 Tomcat将request和response两个对象传递给service方法，并且调用service方法 程序员通过request对象获取请求数据，通过response对象来设置响应消息数据 服务器再给浏览器做出响应之前，会从response对象中拿程序员设置的响应数据 Request 继承体系结构 ServletRequest（接口） ​ | 继承 HttpServletRequest（接口） ​ | 实现 org.apache.catalina.connector.RequestFacade@202c2dc1（Tomcat中） 获取请求消息 获取请求行数据 方法： 获取请求方式 1String getMethod() 获取虚拟目录：/day14 1String getContextPath() 获取Servlet路径：/demo1 1String getServletPath() 获取Get请求参数：name=zhansan 1String getQueryString() 获取请求URI 12String getRequestURI() // /day14/demo1StringBUffer getRequestURL() // http://localhost:8080/day14/demo1 获取协议版本：HTTP/1.1 1String getProtocol() //父类中 获取客户机的IP 1String getRemoteAddr() //父类中 请求头数据 方法： String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration getHeaderNames()：获取所有请求头名称 获取请求体数据 只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有所有类型的数据 再从流对象中拿数据 1234String line = null; while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; 其他功能 获取请求参数通用方式（get和post通用） String getPrarmeter(String name)：根据请求参数名称获取请求参数值 String[] getPrarmeterValues(String name)：根据请求参数名称获取请求参数值的数组 Enumeration getParameterNames()：获取所有请求参数名称 Map&lt;String,String[ ]&gt; getParameterMap()：获取所有参数的map集合 请求转发 步骤 ： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String Path) 通过RequestDispatcher 对象调用方法转发：forward(ServletRequest request ,ServletResponse response) 特点： 浏览器地址状态栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： setAttribute(String name,Object obj)：存储数据 Object getAttribute(String name)：通过键获取值 removeAttribute(String name)：通过键移除键值对 获取ServletContext ServletContext getServletContext() ### 中文乱码问题 - get方式：Tomcat 8 已经将中文乱码问题解决 - post方式：会乱码 解决：在获取参数前，设置编码 request.setCharacterEncoding(&quot;UTF-8&quot;); BeanUtils工具类 简化数据封装，用于封装JavaBean的 JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XML笔记]]></title>
    <url>%2F2019%2F07%2Fxml%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 组成部分 文档声明 格式：&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 属性：id属性值唯一 文本：CDATA区：在该区域中的数据会被原样展示 格式：&lt; ! [ CATA [ 数据 ] ]&gt; 约束规定xml文档的书写规则 分类： DTD：一种简单的约束技术 Schema：一种复杂的约束技术 DTD： 引入 ： 内部文档：将约束规则定义在XML文档中（了解） 外部文档： 本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt; 缺陷：内容不能限定 Schema： 引入： 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. xsi:schemaLocation=”http://www.itcast.cn/xml student.xsd” 为每一个xsd约束声明一个前缀,作为标识 xmlns=”http://www.itcast.cn/xml&quot; 解析操作文档，将文档的数据读取到内存中 操作XML文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析XML的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 使用Jsoup步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 123456789101112131415161718public class JsoupDemo1 &#123; public static void main(String[] args) throws IOException &#123; //2.获取Document对象，根据XML文档 //2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath(); //2.2解析XML文档，获取dom树 Document document = Jsoup.parse(new File(path), "UTF-8"); //3.获取元素对象Elements（可以看成集合） Elements elements = document.getElementsByTag("name"); System.out.println(elements.size()); //根据索引获取值 Element element = elements.get(0); String name = element.text(); System.out.println(name); &#125;&#125; 对象的使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件的。 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList来使用 Element：元素对象 ① 获取子元素对象 ② 获取属性值 String attr(String key)：根据属性名称获取属性值 ③ 获取文本内容 String text()：获取所有字标签纯文本内容 String html()：获取标签体的所有内容(包括字标签的标签和文本内容) Node：节点对象 是Document和Element的父类 快捷查询方式 selector：选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 JsoupXpath-0.3.2.jar 查询w3cshool参考手册，使用xpath的语法完成查询]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射相关问题]]></title>
    <url>%2F2019%2F07%2F%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[三种字节码加载方式 第一阶段：是字节码文件 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 全类名：包名.类名 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 第二个阶段：已经将class加载进内存中 类名.class：通过类名的属性class获取多用于参数的传递 第三阶段：已经有对象 对象.getClass()：getClass()方法在Object类中定义着 多用于对象的获取字节码的方式 不带declare和带declare的区别 不带的只能获取公共成员变量、构造方法和方法 带的可以或群全部的成员变量、构造方法和方法（需要暴力反射） 暴力反射访问私有成员变量、构造方法和方法都可以使用暴力反射（主要解决私有修饰符访问错误） 123456//获取指定名称的成员变量 Field d = personClass.getDeclaredField("d"); //忽略访问权限修饰符的安全检查 d.setAccessible(true); //暴力反射 Object value2 = d.get(p); System.out.println(value2); 使用空参构造方法创建对象如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 getMethods()获取类中所有的方法（是包含Object中的方法） 获取类名12345//1.获取Person的Class对象 Class personClass = Person.class;//2.获取类名String className = personClass.getName();System.out.prinln(className); 手写小框架 需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现： 配置文件 反射 步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.lifan.reflect;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;/** * 框架类 */public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //可以创建任意类的对象，可以执行任意方法 /* 前提：不能改变类的任何代码 */ //1.在程序中加载读取配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录下的一个配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream("pro.properties"); pro.load(is); //获取配置文件中定义的数据 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-基础篇]]></title>
    <url>%2F2019%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数组一、为什么很多编程语言中数组都从0下标开始的 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 1. 如何实现随机访问？ 当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址： a[i] address = base_address + i * data_type_size base_address：内存块首地址 data_type_size：数组中每个元素的大小（），数组中存储int类型，data_type_size为4个字节 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1) 。 2. 低效的“插入”和“删除”操作 如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位；如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1) 。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n) 。 如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1) ；如果删除开头的数据，则最坏情况时间复杂度为 O(n)。 3. 警惕数组越界访问问题12int[] a = new int[3];a[3] = 1; // java.lang.ArrayIndexOutOfBoundsException 4. 容器是否能完全代替数组？ ArrayList最大的优势就是可以将很多数组操作的细节封装起来 支持动态扩容 在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适 5. 解答 公式对比： 以0为起始下标：a[k]_address = base_address + k * type_size 以1位起始下标：a[k]_address = base_address + (k-1)*type_size 结论：数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。 链表一、如何实现LRU缓存淘汰算法？ 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO （ First In ， First Out ）、最少使用策略 LFU （ Least Frequently Used ）、最近最少使用策略 LRU （ Least Recently Used ）。 1. 单链表我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点 查找：链表要想随机访问第 k 个元素，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。 插入和删除 2. 循环链表 循环链表的尾结点指针是指向链表的头结点。 循环链表的优点是从链尾到链头比较方便。 当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。 3. 双向链表 向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。 4. 双向循环链表 5. 数组和链表的最大区别数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致 “ 内存不足（ out of memory ） ” 。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。 6. 解答我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 7. 设计思想时空替换思想： “ 用空间换时间 ” 与 “ 用时间换空间 ”当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-入门篇]]></title>
    <url>%2F2019%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[10个数据结构 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回朔算法、动态规划、字符串匹配算法 复杂度分析一、如何分析算法的执行效率和资源消耗1234567891011int cal(int n)&#123; int sum = 0; int i = 1; for(; i &lt;= n; ++i)&#123; sum = sum + i; &#125; return sum;&#125;/*第 2 、 3 行代码分别需要 1 个 unit_time 的执行时间，第 4 、 5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time */ 1. 大O表示法1T(O) = O(f(n)) 大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。当 n 很大时，你可以把它想象成 10000 、 100000 。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。 2. 分析时间复杂度3个方法 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)T2(n)=O(f(n))O(g(n))=O(f(n)*g(n)) 3. 几种常见时间复杂度实例分析 常量阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n^2)… 指数阶O(2^n)、阶乘阶O(n!) O(1) O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 O(logn)、O(nlogn) 2^x =n –&gt; x = log2n 对数之间是可以互相转换的，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn) 。 将O(logn)循环n次就是O(nlogn)，比如，归并排序、快速排序的时间复杂度都是 O(nlogn) 。 O(m+n)、O(m*n) 12345678910111213int cal(int m, int n) &#123; int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) &#123; sum_1 = sum_1 + i; &#125; int sum_2 = 0; int j = 1; for (; j &lt; n; ++j) &#123; sum_2 = sum_2 + j; &#125; return sum_1 + sum_2;&#125; 从代码中可以看出， m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n) 。 4. 空间复杂度分析空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 5. 常见空间复杂度 O(1)、O(n)、O(n^2) 二、浅析最好、最坏、平均、均摊时间复杂度 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Collection、泛型]]></title>
    <url>%2F2019%2F01%2F%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 Collection集合1.1 集合概述 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有什么区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 Iterator接口使用步骤： Collection接口中有一个方法，iterator()，这个方法返回的就是迭代器的实现类对象 使用Iterator接口中的方法hashNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc"); coll.add("itcast"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP("大胡子登登"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show("aaa"); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add("aa"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add("♥"); colors.add("♦"); colors.add("♠"); colors.add("♣"); for(int i = 2;i&lt;=10;i++)&#123; numbers.add(i+""); &#125; numbers.add("J"); numbers.add("Q"); numbers.add("K"); numbers.add("A"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = color+number; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add("小☺"); pokerBox.add("大☠"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0;i&lt;pokerBox.size();i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i&gt;=51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i%3==0)&#123; player1.add(card); &#125;else if(i%3==1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看看 System.out.println("令狐冲："+player1); System.out.println("田伯光："+player2); System.out.println("绿竹翁："+player3); System.out.println("底牌："+dipai); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象04]]></title>
    <url>%2F2018%2F08%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104%2F</url>
    <content type="text"><![CDATA[多态 由于参数类型不同而导致执行效果各异的现象就是多态。 多态的实现 在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。 12345678910111213141516171819202122232425262728293031//定义接口 Animalinterface Animal&#123; void shout(); //定义抽象shout()方法&#125;//定义Cat类实现Animal接口class Cat implements Animal&#123; //实现sout()方法 public void shout()&#123; System.out.println("喵喵......"); &#125;&#125;//定义Dog类实现Animal接口class Dog implements Animal&#123; //实现shout()方法 public void shout()&#123; System.out.println("汪汪....."); &#125;&#125;//定义测试类public class Example&#123; public static void main(String[] args)&#123; Animal an1 = new Cat(); //创建Cat对象，使用Animal类型的变量an1引用 Animal an2 = new Dog(); //创建Dog对象，使用Animal类型的变量an2引用 animalShout(an1); //调用animalShout()方法，将an1作为参数传入 animalShout(an2); //调用animalShout()方法，将an2作为参数传入 &#125; //定义静态的animalShout()方法，接受一个Animal类型的参数 public static void animalShout(Animal an)&#123; an.shout(); //调用实际参数的shout()方法 &#125;&#125; 对象的类型转换 当子类对象当作父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类中的某些方法。 Java 提供了一个关键字instanceof,它可以判断一个对象是否为某个类（或接口）的实例或者子类实例。 对象（或者对象引用变量） instanceof 类（或接口） 关键字final 关键字 final 修饰的变量（成员变量和局部变量）是常量，只能赋值一次。 final 修饰的方法不能被子类重写。 final 修饰的类不能被继承。 static 关键字 静态变量 在定义一个类时，只是在描述某类事物的特征和行为，并没有产生具体的数据。只有通过new关键字创建该类的实例对象后，系统才会为每个对象分配空间，存储各自数据。某些特定的数据在内存中只有一份，而且能够被一个类的所有实例对象所共享。 在Java类中，可以使用static 关键字来修饰成员变量，该变量称作静态变量。静态变量被所有实例共享，可以使用“类名.变量名”的形式来访问或赋值。 注：static 关键字只能用于修饰成员变量，不能用于修饰局部变量。 静态方法 在不创建对象的情况下就可以调用某个方法，也可以说是使该方法不必和对象绑在一起。只需在类中定义的方法前加上static关键字即可，这种方法为静态方法。静态方法可以使用“类名.方法名”的 方式来访问。 注：在一个静态方法中只能访问用 static 修饰的成员，原因在于没有被 static 修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。 静态代码块 在Java中，使用一对大括号包围起来的若干行代码被称为一个代码块，用static 关键字修饰的代码块称为静态代码块。 当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次。 单例模式 单例模式是Java中的一种设计模式，它是指在设计一个类时，需要保证在整个程序运行期间针对该类只存在一个实例对象，就好像我们生存的世界只有一个月亮。 12345678class Single&#123; //自己创建一个对象 private static Single INSTANCE = new Single(); private Single()&#123;&#125; //私有化构造方法 public static Single getInstance()&#123; //提供返回该对象的静态方法 return INSTANCE; &#125;&#125; 类的构造方法使用 private 修饰，声明为私有，这样就不能在类的外部使用new关键字来创建实例对象了。 在类的内部创建一个该类的实例对象，并使用静态变量INSTANCE引用该对象，由于变量应该禁止外界直接访问，因此使用private修饰，声明为私有成员。 为了让类的外部能够获得类的实例对象，需要定义一个静态方法 getInstance(),用于返回该类实例INSTANCE。由于方法是静态的，外界可以通过：类名.方法名的方式来访问。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象03]]></title>
    <url>%2F2018%2F08%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103%2F</url>
    <content type="text"><![CDATA[类的继承继承的实现extends 在 Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。 在程序中，如果想声明一个类继承另一个类，需要使用 extends 关键字。 123456789101112131415161718192021222324//声明一个 Animal 类class Animal&#123; String name; //定义name属性 //定义动物叫的方法 void shout()&#123; System.out.println("动物发出叫声"); &#125;&#125;//定义 Dog 类继承Animal 类class Dog extends Animal&#123; //定义一个打印 name 的方法 public void printName()&#123; System.out.println("name="+name); &#125;&#125;//定义一个测试类public class Example&#123; public static void main(String[] args)&#123; Dog dog = new Dog(); //创建一个Dog类的实例对象 dog.name="沙皮狗"； //为Dog类的 name 属性进行赋值 dog.printName()； //为Dog类的 getInfo()方法 dog.shout(); //调用Dog类继承来的 shout()方法 &#125;&#125; 注： ① 在Java中，类只支持单继承，不允许多重继承，也就是一个类只能拥有一个直接父类。 ② 多个类可以继承一个父类。 ③在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如 C类继承自 B类，而B类又可以去继承 A类，这时，C类也可以称作 A类的子类。 ④在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 重写父类的方法 在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。 在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。 子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限。如父类中的方法是public 的，子类的方法就不能是 private 的。 抽象类 abstract class 当定义一个类时，常常需要定义一些方法来描述该类的行为特征，但有时这些方法实现的方式是无法确定的。例如 Animal 类，shout()方法用于表示动物的叫声，但针对不同的动物，叫声也是不同的，因此在 shout() 方法中无法准确描述动物的叫声。针对这种情况，Java允许在定义方法时不写方法体，不包括方法体的方法为抽象方法，抽象方法必须使用 abstract 关键字来修饰。 1abstract void shout(); //定义抽象方法 shout() 当一个类中包含了抽象方法，该类必须使用 abstract 关键字来修饰，使用 abstract 关键字修饰的类为抽象类。 12345//定义抽象类 Animalabstract class Animal&#123; //定义抽象方法 shout() abstract int shout();&#125; 注意： ① 包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需使用 abstract 关键字来修饰即可。 ② 抽象类是不可以被实例化的，因为抽象类中可能包含抽象方法，抽象方法没有方法体，不可以被调用。 ③ 如果想调用抽象类中定义的方法，需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。 12345678910111213141516171819//定义抽象类 Animalabstract class Animal&#123; //定义抽象方法 shout() abstract void shout();&#125;//定义一个Dog类继承抽象类Animalclass Dog extends Animal&#123; //实现抽象方法 shout() void shout()&#123; System.out.println("汪汪......"); &#125;&#125;//定义测试类public class Example&#123; public static void main(String[] args)&#123; Dog dog = new Dog(); //创建Dog类的实例对象 dog.shout(); //调用dog对象实现的shout()方法 &#125;&#125; 接口 如果一个抽象类中的所有方法都是抽象的，则可以将这个类用另外一种方式来定义，叫接口。 在定义接口时，需要使用interface关键字来声明。 12345interface Animal&#123; int ID=1; //定义全局常量 void breathe(); //定义抽象方法 void run();&#125; 在接口中定义的方法和变量都包含一些默认修饰符。接口中定义的方法默认使用“public abstarct”来修饰，即抽象方法。接口中的变量默认使用“public static fianl”来修饰，即全局常量。 由于接口中的方法都是抽象方法，因此不能通过实例化对象的方式来调用接口中的方法。这就需要定义一个类，并使用 implements 关键字实现接口中的所有方法。 1234567891011121314151617181920212223242526//定义了Animal接口interface Animal&#123; int ID=1; //定义全局常量 void breathe(); //定义抽象方法 breathe() void run();&#125;//Dog类实现了Animal接口class Dog implements Animal&#123; //实现 breathe()方法 public void breathe()&#123; System.out.println("狗在呼吸"); &#125; //实现 run()方法 public void run()&#123; System.out.println("狗在跑"); &#125;&#125;//定义测试方法public class Example&#123; public static void main(String[] args)&#123; Dog dog = new Dog(); //创建Dog类的实例对象 dog.breathe(); //调用Dog类的breathe()方法 dog.run(); //调用Dog类的run()方法 &#125;&#125; 在程序中，还可以定义一个接口使用 extends 关键字去继承另一个接口。 接口的特点 接口中的方法都是抽象的，不能实例化对象。 当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。 一个类通过 implements 关键字实现接口时，可以实现多个接口，被实现的多个接口之间要用逗号隔开。 一个接口可以通过 extends 关键字继承多个接口，接口之间用逗号隔开。 123456789interface Running&#123; ...&#125;interface Flying&#123; ...&#125;interface Eating extends Running,Flying&#123; ...&#125; 一个类在继承另一个类的同时还可以实现接口，此时，extends 关键字必须位于 implements 关键字之前。 123class Dog extends Canidae implements Animal&#123; //先继承后实现 ...&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象02]]></title>
    <url>%2F2018%2F08%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A102%2F</url>
    <content type="text"><![CDATA[内部类成员内部类 在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类被称作成员内部类。在成员内部类中可以访问外部类的所有成员。 123456789101112131415161718192021class Outer&#123; private int num = 4; //定义类的成员变量 //下面的代码定义了一个成员方法，方法中访问内部类 public void test()&#123; Inner inner = new Inner(); inner.show(); &#125; //下面的代码定义了一个成员内部类 class Inner&#123; void show()&#123; //在成员内部类的方法中访问外部类的成员变量 System.out.println("num = "+num); &#125; &#125;&#125;public class Example&#123; public static void main(String[] args)&#123; Outer outer = new Outer; //创建外部类对象 outer.test(); //调用test()方法 &#125;&#125; 如果想通过外部类去访问内部类，则需要通过外部类对象去创建内部类对象。 外部类名.内部类名 变量名 = new 外部类名().new 内部类名(); 123456public class Example&#123; public static void main(String[] args)&#123; Outer.Inner inner = new Outuer().new Inner();//创建内部类对象 inner.show(); //调用 test() 方法 &#125;&#125; 注：如果内部类被声明为私有，外界将无法访问。 静态内部类 可以使用 static 关键字来修饰一个成员内部类，该内部类被称作静态内部类。它可以在不创建外部类对象的情况下被实例化。 外部类名.内部类名 变量名 = new 外部类名.内部类名(); 123456789101112131415class Outer&#123; private static int num = 6; //下面的代码定义了一个静态内部类 static class Inner&#123; void show()&#123; System.out.println("num = "+num); &#125; &#125;&#125;class Example&#123; public static void main(String[] args)&#123; Outer.Inner inner = new Outer.Inner();//创建内部类对象 inner.show(); //调用内部类的方法 &#125;&#125; 注：① 在静态内部类中只能访问外部类的静态成员。② 在静态内部类中可以定义静态的成员，而在非静态的内部类中不允许定义静态的成员。 方法内部类 方法内部类是指在成员方法中定义的类，它只能在当前方法中被使用。 12345678910111213141516171819class Outer&#123; private int num = 4; //定义成员变量 public void test()&#123; //下面是方法中定义的内部类 class Inner&#123; void show()&#123; System.out.println("num = "+num);//访问外部类成员 &#125; &#125; Inner in = new Inner(); //创建内部类对象 in.show(); //调用内部类的方法 &#125;&#125;public class Example&#123; public static void main(String[] args)&#123; Outer outer = new Outer(); //创建外部类对象 outer.test(); //调用 test() 方法 &#125;&#125; 匿名内部类 匿名内部类是实现接口的一种简便写法。 123new 父类(参数列表) 或 父接口()&#123; //匿名内部类实现部分&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象01]]></title>
    <url>%2F2018%2F08%2FJava-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A101%2F</url>
    <content type="text"><![CDATA[面向对象特点：封装性、继承性、多态性 类和对象定义 类是对某一类事物的抽象描述，它用于描述一组对象的共同特征和行为。 对象用于表示现实中该类事物的个体。 类中可以定义成员变量和成员方法，其中成员变量用于描述对象的特征，也被称作属性。成员方法用于描述对象的行为，可简称方法。 定义在类中的变量称为成员变量，定义方法在方法中的变量称为局部变量。 对象的创建和使用 在 Java 程序中可以使用 new 关键字来创建对象。 类名 对象名称 = new 类名 ( ) ; 12345678class Person&#123; int age = 10; //类中定义的变量被称作成员变量 //定义speak()方法 void speak()&#123; int age = 60; //方法内部定义的变量被称作局部变量 System.out.println("大家好，我今年"+age+"岁!"); &#125;&#125; 通过对象的引用来访问对象所有的成员。 对象引用 . 对象成员 123456789class Example01&#123; public static void mian(String[] args)&#123; Person p1 = new Person(); //创建第一个Person对象 Person p2 = new Person(); //创建第二个Person对象 p1.age = 18; //为age属性赋值 p1.speak(); //调用对象方法 p2.speak(); &#125;&#125; Java虚拟机会自动为成员变量初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值。 当没有任何变量引用这个对象时，它将成为垃圾对象，不能再被实现。 类成员的封装 所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用 private 关键字来修饰。 私有属性只能在它所在类中被访问。 为了能让外界访问私有属性，需要提供一些使用 public 修饰的公有方法，其中包括用于获取属性值的 getXxx() 方法和设置属性值的 setXxx() 方法。 构造方法定义在一个类中定义的方法如果同时满足以下三个条件，该方法称为构造方法： 方法名与类名相同。 在方法名的前面没有返回值类型的声明。 在方法中不能使用 return 语句返回一个值。 new 语句不仅会实例化类对象，还会调用类中的构造方法。 在一个类中除了定义无参的构造方法，还可以定义有参的构造方法，通过有参的构造方法就可以实现对属性的赋值。 构造方法的重载 与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或个数不同即可。 注： 1. 在Java中的每个类都至少有一个构造方法，如果一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么也不做。 2. 构造方法不用 private 修饰 ，通常用 public 来修饰。 this 关键字的使用 this 关键字在程序中的三种常见用法： 通过 this 关键字可以明确地去访问一个类的成员变量，解决与局部变量名称冲突问题。 123456789class Person&#123; int age; public Person(int age)&#123; this.age = age; &#125; public int getAge()&#123; return this.age; &#125;&#125; 通过 this 关键字调用成员方法 12345678class Person&#123; public void openMouth()&#123; ... &#125; public void speak()&#123; this.openMonth(); &#125;&#125; 构造方法是在实例化对象时被Java虚拟机自动调用的，在程序中不能像调用其他方法一样去掉用构造方法，但可以在一个构造方法中使用“ this([参数1，参数2…])”的形式来调用其他的构造方法。 只能在构造方法中使用 this 调用其他构造方法，不能在成员方法中使用。 在构造方法中，使用 this 调用构造方法的语句必须位于第一行，且只能出现一次。 不能在一个类的两个构造方法中使用 this 互相调用。 super 关键字的使用 问题：当子类重写父类的方法后，子类对象无法访问父类被重写的方法。 解决：Java 提供一个 super 关键字用于访问父类的成员。 使用 super 关键字调用父类的成员变量和成员方法。 super.成员变量 super.成员方法([参数1，参数2…]) 使用 super 关键字调用父类的构造方法。 super([参数1，参数2…]) 注意： 1. 通过 super 调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。 2. 在定义一个类时，如果没有特殊需求，尽量在类中定义一个无参的构造方法，避免被继承时出现错误。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础05]]></title>
    <url>%2F2018%2F08%2FJava-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8005%2F</url>
    <content type="text"><![CDATA[异常异常概念 在程序运行的过程中，会发生各种非正常状况，比如程序运行时磁盘空间不足，网络连接中断，被装载的类不存在。针对这种情况，在Java语言中，引入了异常，以异常类的形式对这些非正常情况进行封装，通过异常处理机制对程序运行时发生的各种问题进行处理。 Throwable 有两个直接子类Error 和 Exception，其中Error代表程序中产生的错误，Exception代表程序中产生的异常。 Error 类称为错误类，它表示Java 运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。 Exception 类称为异常类，它表示程序本身可以处理的错误，在开发Java程序中进行的异常处理，都是针对Exception类及其子类。在Exception 类的众多子类中有一个特殊的RuntimeException类，该类及其子类用于表示运行时异常，除了此类，Exception 类下所有其他的子类都用于表示编译时异常。 Throwable 类中的常用方法 异常处理 try … catch Java 中提供一种对异常进行处理的方式——异常捕获 12345try&#123; //程序代码块&#125;catch(ExceptionType(Exception 类及其子类) e)&#123; //对ExceptionType的处理&#125; 其中在try 代码块中编写可能发生异常的Java 语句，catch 代码块中编写针对异常进行处理的代码。当try 代码块的程序发生了异常，系统会将这个异常的信息封装成一个异常对象，并将这个对象传递给catch代码块。catch 代码块需要一个参数指明它所能够接受的异常类型，这个参数的类型必须是Exception类或其子类。 finally 在程序中，有时候我们希望语句无论程序是否发生异常都要执行，这个时候在try … catch语句后，加一个 finally 代码块。 注： 不论程序是否发生异常还是使用 return 语句结束，finally语中的语句都会执行。用途：例如释放系统资源。 在try … catch中如果执行了System.exit(0)语句，finally中的语句就不会执行。System.exit(0)表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行。 throws 如果去调用一个别人写的方法时，是否知道别人写的方法是否会异常呢？这就很难做出判断。针对这种情况，Java中允许在方法的后面使用 throws 关键字对外声明该方法有可能发生的异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则无法编译通过。 123修饰符 返回值类型 方法名([参数1，参数2...])throws ExceptionType1[,ExceptionType2...]&#123; &#125; 从上述语法格式中可以看出，throws关键字需要写在方法声明的后面，throws后面需要声方法中发生异常的类型，通常将这种做法称为方法声明抛一个异常。 异常分类 编译时异常 在Java中，Exception 类除了RuntimeException 类及其子类都是编译时异常。编译时异常的特点是Java 编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。 处理编译时期的异常的两种方式： 使用 try … catch 语句对异常进行捕获。 使用 throws 关键字声明抛出异常，调用者对其处理。 运行时异常 RuntimeException 类及其子类都是运行时异常。运行时异常特点是Java编译器不会对其检查，也就是说，当程序中出现这类异常时，即使没有使用 try … catch 语句捕获或使用 throws 关键字声明抛出，程序也能编译通过，运行时异常一般是由程序中的逻辑错误引起的，在程序运行时无法恢复。 自定义异常 Java允许用户自定义异常，但自定义的异常类必须继承自 Exception 或其子类。 12345678910//下面的代码是自定义一个异常类继承自 Exceptionpublic class MyException extends Exception&#123; public MyException()&#123; super(); //调用 Exception 无参的构造方法 &#125; public MyException(String message)&#123; super(); //调用 Exception 有参的构造方法 &#125;&#125; 在实际开发中，如果没有特殊的要求，自定义的异常类只需继承 Exception 类，在构造方法中使用 super() 语句调用Exception 的构造方法即可。 使用自定义异常使用 throw 关键字，throw 关键字用于在方法中抛出异常的实例对象。 1throw Exception异常对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础04]]></title>
    <url>%2F2018%2F08%2FJava-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004%2F</url>
    <content type="text"><![CDATA[函数方法方法基础 方法定义 在Java中，声明一个方法的具体语法格式如下： 修饰符 返回值类型 方法名([参数类型 参数名1，参数类型 参数名2，…]){ 执行语句 ... return 返回值； } 方法的返回值必须为方法声明的返回值类型，如果方法中没有返回值，返回值类型要声明为void，此时，方法中return语句可以省略。 方法调用 方法名（参数列表） 参数的传递 值传递 方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。 引用传递 也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址； 在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。 变量作用域 全局变量 定义：又称“外部变量”，它不属于哪个方法，作用域从定义的地址开始到源文件结束。 局部变量 定义：在方法内定义的变量称为“局部变量”或“临时变量”，方法结束后局部变量占用的内存将被释放。 重载方法 Java 允许在一个程序中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。注：方法的重载与返回值类型无关。 方法的递归 方法的递归是指在一个方法的内部调用自身的过程，递归必须要有结束条件，不然就会陷入无限递归的状态，永远无法结束调用。 数组 数组是一种数据结构，用来存储同一类型值的集合。通过整型下标（下标从0开始）可以访问数组中的每一个值。 数组的初始化 动态初始化 在声明数组变量时，需要指出数组类型（数据元素类型后紧跟[]）和数组变量名字。 int[] a; 上面这条语句只声明了变量a，并没有将a初始化一个真正的数组。应该使用new运算符创建数组。 int[] a = new int[100]; 这条语句创建了一个可以存储100个整型的数组。数组长度不要求是常量：new int[n]会创建一个长度为n的数组。 静态初始化 int[] a = {2,3,8,5,4,6}; 这种语法形式可以在不创建新变量的情况下重新初始化一个数组。 数组遍历1234int[] a = new int[100];for(int i = 0; i &lt; 100; i++)&#123; a[i] = i; //fills the array with numbers 0 to 99&#125; 创建一个数字数组时，所有元素都初始化为0。 boolean 数组的元素会初始化为false。 对象数组的元素则初始化为一个特殊值null，这表示这些元素还未存放对象。 数组元素个数1234int[] a = new int[100];for(int i = 0; i &lt; a.length; i++)&#123; System.out.println(a[i]);&#125; 获取数组元素个数使用array.length。 一旦创建了数组，就不能再改变它的大小。 二维数组 数组声明 1int[][] a; 数组初始化 静态初始化 1int[][] a = new int[5][6]; 动态初始化 1int[][] a = &#123;&#123;2,3,4&#125;,&#123;5,6,7&#125;&#125;;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础03]]></title>
    <url>%2F2018%2F08%2FJava-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003%2F</url>
    <content type="text"><![CDATA[运算符 在Java中，使用算术运算符+、-、*、/表示加减乘除运算。当参与/运算的两个操作数是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作用%表示。 注：整数被0除将会产生一个异常，而浮点数被0除将会得到一个无穷大或NaN结果。 二元运算符 x += 4;//等价于 x = x + 4; 自增运算符与自减运算符 前缀方式：++n 后缀方式：n++ 区别：前缀方式先对变量进行 +1 运算；后缀方式则先使用变量原来的值，在对变量进行 +1 运算。 关系运算符与boolean运算符 使用两个等号 == 检测是否相等。 3 == 7 //值为false 使用 != 检测是否不相等。 3! = 7 //值为true 经常使用的还有&lt;(小于)、&gt;（大于）、&lt;=（小于等于）和 &gt;=（大于等于）。 用&amp;&amp;表示逻辑 “与” 、用 ||表示逻辑 “或”。 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。 expression1 &amp;&amp; expression2 expression1 || expression2 三元操作符 ?: condition ? expression1 : expression2 当条件condition 为 true 时计算第1个表达，否则计算第2个表达。例： x&lt;y ? x : y //返回 x 和 y 中较小的那个值。 位运算符 &amp;(“与”)、|（“或”）、^（“异或”）、~（“非”） 访问修饰符 Java 中4种访问修饰符public / protected / default(friendly) / private 对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。 对于protected修饰符，它主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。 对于default来说，有点的时候也成为friendly（友员），它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。 对于private来说，它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。 下表为Java访问控制符的含义和使用情况 : 区别： (1) public:可以被所有其他类所访问。 (2) private:只能被自己修改。 (3) protected:自身，子类及同一个包中类可以访问。 (4) default(默认):同一包中的类可以访问，声明时没有加修饰符，认为是friendly。 注意：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。 基本结构语句 顺序结构语句 选择结构语句 if语句 123456if(condition)&#123; statement1. statement2&#125;else if&#123; statement3&#125; 多重选择：switch 语句 1234567891011switch(choice)&#123; case 1： ... break; case 2: ... break; default: ... break;&#125; case 标签可以是： 类型为 char、byte、short 或 int（或其包装类）的常量表达式。 枚举常量 字符串字面量 循环结构语句 while循环 当条件为true时，while循环执行一条语句。 123while(condition)&#123; statement&#125; while 循环语句首先检测循环条件。因此，循环体中的代码有可能不被执行。 do while循环如果希望循环体至少执行一次，则应该将检测条件放在最后。使用do/while循环语句执行这种操作。 123do&#123; statement&#125; while() 这种循环语句先执行语句，再检测循环条件；然后重复语句，再检测循环条件，以此类推。 for循环 for 循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。下面程序将数字1~10输出到屏幕上： 12for(int i = 1;i &lt;= 10;i++) System.out.println(i); for语句的第一部分通常用于对计数器初始化；第二部分给出每次新一轮循环执行前要检测的循环条件；第三部分指示如何更新计数器。 注：如果在for语句内部定义一个变量，这个变量就不能在循环体之外使用。另一方面，可以在各自独立的不同for循环中定义同名的变量。 for each 循环 语句格式：for(variable :collection) statement 定义一个变量暂存集合中的每一个元素，并执行相应的语句/语句块。collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象。 12for(int element : a) System.out.println(element); 这个循环应该读作“循环a中的每一个元素”。 循环控制 break 和 continue 语句 break 的作用就是跳出一个循环或者结束一个循环。 continue 的作用是立即结束本次循环，继续执行下一次循环。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础02]]></title>
    <url>%2F2018%2F07%2FJava-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[数据类型1.基本数据类型 Java 是一种强类型语言（每一个变量必须声明一种类型）。在Java中，一共有8种数据类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符类型char和一种表示真值的boolean类型。 1.1.整型（表示没有小数部分的数值，允许为负数） int 最常用 long 类型，数值后有一个后缀L，用于表示比如星球上的居住人数。 byte 和 short 类型用于特定场合。比如，底层的文件处理或者需要控制占用存储空间量的大数组。 1.2.浮点类型（表示有小数部分的数值） double 表示这种类型的数值精度是 float 类型的两倍（双精度数值），绝大部分应用程序采用这种数据类型。 float类型（单精度数值），数值后有一个后缀F，在很多情况下，精度难以满足，所以有很少的情况适合使用float类型。 注:没有后缀 F 的默认为 double 类型。 1.3.char 类型（表示单个字符，通常用来表示字符常量，用单引号’ ‘括起来）1.4.boolean 类型 boolean 类型有两个值：false 和 true，用来判断逻辑条件。整型值和布尔值之间不能转换。 2.字符串（String） Java 字符串就是Unicode 字符序列。Java 没有内置的字符串类型，而是预先定义了一个类String，每个用双引号括起来的字符串都是String类的一个实例。 2.1.子串 String 类的 substring 方法可以从一个较大的字符串提取一个子串。 123String greeting = "Hello";String s = greeting.substring(0,3);System.out.println(s);//输出：Hel 2.2.拼接 Java 语言允许使用 + 号连接（拼接）两个字符串。 1234String a = "Hello ";String b = "World!";String message = a + b;System.out.println(message);//输出：Hello World! 当一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 2.3.不可变字符串 Sring 类没有提供用于修改字符串的方法。由于不能修改，所以在Java文档中将String 类对象称为不可变字符串。 2.4.检测字符串是否相等 可以用 equals方法检测两个字符串是否相等。对于表达式：s.equals(t)，如果字符串s与字符串t相等，则返回true，否则，返回false。 注：不能使用 == 运算符号检测两个字符串是否相等！这个运算符只能确定两个字符串是否放在同一个位置上（同一地址）。 2.5.空串与Null串 空串 “ ” 是长度为0的字符串。可以使用代码检查一个字符串是否为空： 123if(str.length() == 0)//或if(str.equals("")) 空串是一个Java对象，有自己的串长度（0）和内容（空）。 String还可以放一个特殊的值，名为 null，这表示没有任何对象与该变量有关。要检查一个字符串是否为 null ，要使用以下条件： 1if(str == null) 要检查一个字符串既不是 null 也不是空串，需要使用以下条件： 1if(str != null &amp;&amp; str.length() != 0)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法之二分查找法]]></title>
    <url>%2F2018%2F07%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单查找法使用简单查找法查找元素时，在最糟情况下需要查看每个元素。因此，如果列表包含8个数字，你最多需要检查8个数字。用O(n)表示简单查找法的运行时间。 二分查找法 二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回 null 。 猜数字游戏（1-100） 小了，但排除了一半的数字！至此，你知道1～50都小了。接下来，你猜75。 大了，那余下的数字又排除了一半！使用二分查找时，你猜测的是中间的数字，从而每次都将余下的数字排除一半。接下来，你猜63（50和75中间的数字）。 这就是二分法。 对数log 10 100相当于问“将多少个10相乘的结果为100”。答案是两个：10 × 10 = 100。因此，log 10 100 = 2。对数运算是幂运算的逆运算。用O(log2 n)表示二分法的运行时间，也就是O(log n)。 一些常见的大O运行时间下面按从快到慢的顺序列出经常遇到的5种大O运行时间： O(log n)：对数时间，这样的算法包括二分查找。 O(n)：线性时间，这样的算法包括简单查找。 O(n * log n)：这样的算法包括快速排序。 O(n2)：这样的算法包括选择排序。 O(n!)：这样的算法包括旅行商问题的解决方案。 旅行商有一位旅行商。他需要前往5个城市。 这位旅行商（姑且称之为Opus吧）要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。 推而广之，涉及n个城市时，需要执行n!（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没了。 小结 二分查找的速度比简单查找要快许多，数据越大，差距就越明显。 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。 算法运行时间并不以秒为单位。 算法运行时间是从其增速的角度来度量的。 算法运行时间用大O表示法表示。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 学习笔记01]]></title>
    <url>%2F2018%2F07%2FGit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[创建版本库 pwd 命令用于显示当前目录 初始化一个仓库，使用 git init 命令 查看文件内容：使用 cat 命令 修改文件内容：使用 vi 命令 添加文件到Git仓库，分两步： 1.使用命令 git add ，注意，可反复多次使用，添加多个文件。 2.使用命令 git commit -m ，完成 -m 后输入本次提交说明 注：Windows目录一定要使用英文路径，绝不能出现中文。 版本回退 要随时掌握工作区的状态，使用 git status 命令 如果 git status 告诉你有文件被修改过，用 git diff 可以查看修改内容 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用got reset –hard commit_id 穿梭前，用 git log 可以查看提交的历史，以便确定要回退带哪个版本 参数 –pretty=oneline（简洁版） 要重返未来，用git reflog查看历史命令，以便确定要回到未来那个版本（关机重启、命令窗口关闭使用此方法） 注：在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上个版本就是HEAD~100。例：git rest –hard HEAD^,查找时版本号没必要写全，Git会自动查找。 工作区和暂存区工作区：就是电脑里能看到的目录，如：learngit 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 stage(index)为暂存区 Git自动创建第一个分支master 指向master的一个指针HEAD 分解： ① 使用git add 实际上就是把文件添加到暂存区 ② 使用git commit 实际上就是把暂存区的所有内容提交到当前分支 创建Git版本库时，Git自动创建了一个master分支，所以，git commit就是往分支master上提交更改 管理修改注：每修改一次需要git add，不然不会进入commit 中 撤销修改 场景一：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改版，使用命令 git checkout –file。 场景二：当你不但改乱了工作区某个文件的内容，还添加到暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file 就回到了场景1，然后使用场景一的方法。 场景三：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，前提是没有推送到远程仓库 。 删除文件命令rm file用于删除工作区的文件。 命令 git rm file 用于删除一个文件。如果一个文件已经被提交到版本库，用于那不要担心删除，但是只能恢复到文件最新版本，且会丢失最后一次提交后修改的内容。]]></content>
      <categories>
        <category>多学一招</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各进制之间的转换]]></title>
    <url>%2F2018%2F07%2F%E5%90%84%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.十进制和二进制之间的转换 十进制转二进制 十进制转换成二进制就是一个除以2取余的过程。最后将所有余数倒序排列，得到的数就是转换的果。 二进制转十进制 二进制转换成十进制要从右向左用二进制位上的每个数去乘以2的相应次方。 如：把一个二进制数0100 0100转换为十进制，转换方式如下： 2.二进制和八进制、十六进制之间的转换 二进制转八进制 二进制转八进制时，首先需要将二进制数自右向左每三位分成一段，然后将二进制的每段的三位转为八进制的一位，转换过程中数值的对应关系如下。（注意八进制必须以0为开头） 二进制转十六进制 二进制转十六进制，首先需要将二进制数每四位分成一段，查表转换即可。（注意十六进制必须以0x或0X开头）]]></content>
      <categories>
        <category>多学一招</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础01]]></title>
    <url>%2F2018%2F07%2FJava-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[基本语法关键字 关键字的编程语言里事先定义好并赋予了特殊含义的单词，也称作保留词。 使用Java关键字时，有几个要注意的地方： 所有程序的关键字都是小写。 程序中的标识符不能以关键字命名。 标识符 在编程中，经常需要在程序中定义一些符号来标记一些名称，如包名，类名，方法名，参数名，变量名等，这些符号被称为标识符。 定义标识符应遵循以下规则： 包名所有字母一律小写，例如：cn.lisite.test。 类名和接口名每个单词的首字母都要大写，例如：Person。 常量名和方法名的每一个单词首字母小写，从第二个单词首字母大写，例如：lineNumber。 在程序中，应尽量使用有意义的单词来定义标识符，使得程序便于阅读。 注释 注释是对程序的某个功能或某行代码的解释说明，它只是在Java源文件中有效，在编译程序时编译器会忽略这些注释信息，不会将其编译到class字节码文件中去。 Java 中的注释有三种类型，具体如下： 单行注释，用符号“//”表示。 多行注释，以符号“ / ”开头，以符号” / “结尾。 文档注释，以符号“ /* ”开头，并在这是内容末尾以“ / ”结束。 常量1.整型常量整型常量是整数类型的数据，有二进制、八进制、十进制和十六进制4种表示形式。 二进制：由数字0和1组成的数字序列，前面要以 0b 或者 0B 开头。 八进制：以0开头并且其后由0~7范围内（包括 0 和 7 ）的整数组成的数字序列。 十进制：由数字0~9范围内（包括0和9）的整数组成的数字序列。 十六进制：以 0x 或者 0X 开头并且其后由0~9,A~F（包括两端）组成的数字序列。 2.浮点数常量浮点数常量就是在数学中用到的小数，分为 float 单精度浮点数和 double 双精度浮点数两种类型。 单精度浮点数：后面以F或f结尾 双精度浮点数：后面以D或d结尾 注：在使用浮点数时也可以在结尾处不加任何的后缀，虚拟机会默认为 double 双精度浮点数。 3.字符常量字符常量用以表示一个字符，一个字符常量要用一对英文半角格式的单引号 ‘ ‘ 引起来。 注：因为Java采用的是Unicode字符集，Unicode字符以 \u 开头，空白字符在Unicode码表中对应的值为 ‘\u0000’ 。 4.字符串常量字符串常量用以表示一串连续的字符，一个字符串常量要用一对英文半角格式的双引号 “ “ 引起来。 注：一个字符串可以包含一个字符或多个字符，也可以不包含任何字符，即长度为0。 5.布尔常量布尔常量即布尔型的两个值 true 和 false ，该常量用于区分一个事物的真与假。 6.null 常量null 常量只有一个值 null ，表示对象的引用为空。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 函数]]></title>
    <url>%2F2018%2F07%2FPython-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[调用函数 Python内置了很多有用的函数，我们可以直接调用。 调用求绝对值函数 abs 函数： 1234&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20 函数max() 可以接手任意多个参数，并返回最大的那个： 12&gt;&gt;&gt; max(2,3,1,-5)3 int()、float()、str()、bool()函数可以把其他数据类型转换成相对应的数据类型： 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 定义函数 在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号 : ，然后，在缩进块中编写函数体，函数的 返回值 用 return语句 返回。 12def 函数名 (参数): return 注：如果没有 return 语句，函数执行完毕后也会返回结果，只是结果为 None 。return None 可以简写为 return。 函数可以同时返回多个值，但其实就是一个tuple。 函数的参数 位置参数 12def poewr(x): return x * x 对于 power(x) 函数，参数x就是一个位置参数。 默认参数 123456def power(x,n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 对于 power()函数，参数 n=2就是一个默认参数。 设置默认参数时，有几点要注意： 必选参数在前，默认参数在后，否则Python的解释器会报错。 如何设置默认参数，当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 默认参数必须指向不变对象。 使用默认参数的好处？ 最大的好处是能降低调用函数的难度。 可变参数 在Python函数中，还可以定义可变参数 。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum *numbers 是可变参数，numbers 接收的是一个tuple。 把 list 或 tuple的元素变成可变参数传进去： 123&gt;&gt;&gt; nums = [1,2,3]&gt;&gt;&gt; calc(*nums)14 *nums 表示把 nums 这个 list 的所有元素作为可变参数传进去。 关键字参数 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict 。 12def person(name,age,**kw): print('name:',name,'age:',age,'other:',kw) **kw是关键字参数，kw接收的是一个dict。 关键字参数有什么用？ 它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 命名关键字参数 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 city 和 job 作为关键字参数。这种方式定义的函数如下： 12def person(name,age,*,city,job): print(name,age,city,job) 和关键字参数 *kw不同 ，命名关键字参数需要一个特殊分隔符 ， * 后面的参数被视为命名关键字参数。 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 递归函数 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 12345#计算阶乘 n! = 1 x 2 x 3 x ... x n,用函数fact(n)表示fact(n) = n! = fact(n-1) x ndef fact(n): if n==1: return 1 return n * fact(n-1) 递归函数的优点是定义简单，逻辑清晰。缺点是过深的调用会导致栈溢出。 解决递归调用栈溢出的方法是通过尾递归优化 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 1234567def fact(n): return fact_iter(n,1)def fact_iter(num,product): if num == 1: return product return fact_iter(num - 1,num * product) 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 语言基础04]]></title>
    <url>%2F2018%2F07%2FPython-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004%2F</url>
    <content type="text"><![CDATA[Python 的特性list Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 123&gt;&gt;&gt; classmates = ['Michael','Bob','Tracy']&gt;&gt;&gt; classmates['Michael','Bob','Tracy'] 变量 classmates 就是一个 list 。用len() 函数可以获得list元素的个数: 12&gt;&gt;&gt; len(classmates)3 用索引来访问list中每一个位置的元素，记得索引是从 0 开始的。当索引超出范围，Python会报一个IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 12&gt;&gt;&gt; classmates[0]'Michael' 除了计算索引位置外，还可用 -1 做索引，直接获取最后一个元素，以此类推，可以获取倒数第二个、第三个： 12&gt;&gt;&gt; classmates[-1]'Tracy' list 是一个可变的有序表，可以使用函数 append() 往 list 中追加元素到末尾: 123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael','Bob','Tracy','Adam'] 使用函数 insert() 将元素插入到指定位置，比如索引为 1 的位置: 123&gt;&gt;&gt; classmates.insert(1,'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list 末尾的元素，用 pop() 方法： 1234&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置： 1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引的位置： 123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] list 里面的元素的数据类型也可以不同，比如： 1&gt;&gt;&gt; L = ['Apple', 123, True] list 元素也可以是另一个 list（list的嵌套），比如： 123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4 拆开写：123&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']#如果想拿到 ‘php’ 可以写成p[1] 或者 s[2][1]，因此 s 可以看成是一个二维数组。 如果list中一个元素也没有，就是一个空的list，它的长度为0。 tuple 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。 1&gt;&gt;&gt; classmates = ('Michael','Bob','Tracy') !!!注：classmates这个tuple不能变了，它没有append(),insert()这样的方法，其他获取元素的方法和list是一样的，但不能赋值成另外的元素。 不可变的tuple有什么意义？？？因为tuple不可变，所以代码更加安全。如果可能，能用tuple替代list就尽量用tuple。 tuple的陷阱：当定义一个tuple时，在定义的时候，tuple的元素就必须确定下来。如果要定义一个空的tuple，可以写成（）；但是，要定义一个只有1个元素的tuple： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 小结 list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 语言基础03]]></title>
    <url>%2F2018%2F07%2FPython-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003%2F</url>
    <content type="text"><![CDATA[基础语法分为两块，包含条件判断和循环两块。条件判断主要是if语句的相关使用。循环主要是while模块的使用。 条件判断在Python程序中，用 if 语句实现：注意不要少了冒号 ： if 语句完整结构：123456789if &lt;条件判断1&gt;: &lt;执行1&gt;#elif 为 else if 的缩写elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; if 语句特点：条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。 !!!注：因为 input() 返回的数据类型是 str ， str 不能直接和整数比较，必须先把 str 转换成整数。Python提供了 int() 函数来完成这件事情。 循环循环是让计算机做重复任务的有效的方法。 第一种循环：for … in 循环，比如计算1-10的整数之和，可以用一个sum变量做累加。 1234sum = 0for x in [1,2,3,4,5,6,,7,8,9,10]: sum = sum + xprint(sum) 第二种循环：while 循环，只要满足条件，就不断循环，条件不满足时退出循环。比如计算100以内所有奇数之和。 123456sum = 0n = 99while n &gt; 0: sum = sum + n n= n - 2print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 break 和 comtinue break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 语言基础02]]></title>
    <url>%2F2018%2F07%2FPython-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[字符串和编码 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件： 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器： Python的字符串 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。 对于单个字符的编码： ord() 函数获取字符的整数表示。 1234&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013 chr() 函数把编码转换成对应的字符。 1234&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 由于 Python 的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python 对 bytes 类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’ 以Unicode表示的str通过 encode() 方法可以编码为指定的 bytes。 1234&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xe6\x96\x87' !!!注：1.纯英文的 str 可以用 ASCII 编码为 bytes，内容是一样的。2.含有中文的 str 可以用 UTF-8 编码为bytes，但无法用 ASCII 编码，因为中文编码超出了 ASCII 编码的范围，Python会报错。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 bytes 。要把 bytes 变为str ，就需要用 decode() 方法。 1234&gt;&gt;&gt;b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt;b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' !!!注：1.如果 bytes 中包含无法解码的字节，decode() 方法会报错。2.如果 bytes 中只有一小部分无效字节，可以传入errors=’ignore’ 忽略错误的字节。 其他 要计算 str 包含多少个字符，可以用 len() 函数。 要计算 bytes 包含多少个字节，可以用 len() 函数。 在操作字符串时，我们经常遇到 str 和 bytes 的互相转换。为了避免乱码问题，应当始终坚持使用 UTF-8 编码对 str 和 bytes 进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。 格式化 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 !!!注：1.格式化整数和浮点数还可以指定是否补0和整数与小数的位数。 2.如果你不太确定应该用什么，%s 永远起作用，它会把任何数据类型转换为字符串。 3.有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%。 format() 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多。12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%']]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 语言基础01]]></title>
    <url>%2F2018%2F07%2FPython-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用 0x 前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号 ‘ 或双引号 “ 括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含 ‘ 又包含 “ 怎么办？可以用转义字符\来标识，比如： 123'I\'m \"OK\"!'#表示的字符串内容是：I'm "OK"! \n表示换行 \t表示制表符 字符 \ 本身也要转义，所以 \ 表示的字符就是 \ Python允许使用 ‘’’…’’’的格式表示多行内容，还可以在前面加上 r 使用 r’’’…’’’ 布尔值在Python中，可以直接用True、False表示布尔值（注意大小写）。 布尔运算 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用 and 、or 和 not 运算and 运算是与运算，只有所有都为 True , and 运算结果才是True： 12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or 运算是或运算，只要其中有一个为 True ，or 运算结果就是 True。 not 运算是非运算，它是一个单目运算符，把True变成False，False变成True。 123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 布尔值经常用在条件判断中，比如：1234if age &gt;= 18: print('adult')else: print('tennager') 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头 动态语言：变量本身类型不固定。静态语言：在定义变量时必须制定变量类型，如果赋值时类型不匹配，就会报错。例如Java语言。12int a = 123;//a是整数型变量a = "ABC"; //错误：不能把字符串赋给整型变量 常量所谓常量就是不能变的变量，比如常用的数学常数 π 就是一个常量。在Python中，通常用全部大写的变量名表示常量： PI = 3.141592653]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 语言简介和开发环境]]></title>
    <url>%2F2018%2F07%2FJava-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Java 语言简介Java是一种高级计算机语言，它是由SUN公司（已被Oracle公司收购）于1995年5月推出的一种一个编写跨平台应用软件、完全面向对象的程序设计语言。 Java语言简单易用、安全可靠，主要面向Internet编程，自问世以来，与之相关的技术和应用发展的非常快。如今，Java技术无处不在。 Java三个开发方向 Java SE(Java Platform Standard Edition)标准版，是为开发普通桌面和商务应用程序提供的解决方案。Java SE是三个平台中最核心的部分，Java EE 和 Java ME 都是从Java SE 的基础上发展而来，Java SE平台中包括了Java最核心的类库，如集合、IO、数据库连接以及网络编程等。 Java EE(Java Platform Enterprise Edition)企业版，是为开发企业级应用程序提供的解决方案。Java EE可以被看做一个技术平台，该平台用于开发、装配以及部署企业级应用程序，其中主要包括Servlet、JSPJavaBean、JDBC、EJB、WebService等技术。 Java ME(Java Platform Micro Edition)小型版，是为了开发电子消费产品和嵌入式设备提供解决方案。 Java语言的特点：简单、面向对象、安全、跨平台、支持多线程。 开发环境搭建SUN公司提供了一套Java开发环境，简称JDK(Java Development Kit),它是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等。 除了JDK，还提供了一种JRE(Java Runtime Environment)工具，它是Java 运行环境。JRE中只包含Java运行工具，JRE = JVM + API，且JDK工具中自带了一个JRE工具，开发人员只用在计算机上安装JDK即可。 JDK目录介绍JDK安装完毕后，会在硬盘上生成一个目录，该目录被称为JDK安装目录。 bin 目录：该目录存放一些可执行程序，如javac.exe（Java 编译器）、java.exe（Java 运行工具）等等。 db 目录：db目录是一个小型的数据库。装一个数据库软件，选择直接使用JavaDB即可。 jre 目录：意为Java程序运行时环境。它包含Java虚拟机，运行时的类包、Java应用启动器以及一个bin目录。不包含开发环境中的开发工具。 include 目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是存放这些东西的。 src.zip 文件：压缩文件，其中存放Java核心类的源代码，通过该文件可以查看Java基础类的源代码。 特别注意： javac.exe 是Java的编译工具，它可以将编写好的Java文件编译成字节码文件（可执行的Java程序）。Java源文件的扩展名为 .java,编译后生成的Java字节码文件的扩展名为.class。 java.exe 是Java运行工具，它会启动一个Java虚拟机（JVM）进程，Java虚拟机相当于一个虚拟的操作系统，它专门负责运行Java 编译器生成的字节码文件（.class 文件） path 环境变量 path环境变量是系统环境变量的一种，它是用于保存一系列的路径，每个路径之间以分号分隔。 设置path环境变量步骤（win10）：此电脑–&gt;右键属性–&gt;高级系统设置–&gt;环境变量–&gt;系统环境变量–&gt;找到Path，将javac命令所在目录（JDK下bin目录）路径粘贴到其中–&gt;设置完毕，打开命令行窗口输入javac，命令行会显示帮助信息。 classpath 环境变量 classpath 环境变量也用于保存一系列路径，它和 path 环境变量的查看与配置方式完全相同。当 Java 虚拟机需要运行一个类时，会在classpath环境变量中锁定路径下寻找所需的 class 文件。注：从JDK5.0开始，如果classpath 环境变量没有进行设置，Java虚拟机会自动将其设置为“.” ，也就是当前目录。 编辑器 notepad++/Editpuls/UltraEdit: 文本编辑器，入门推荐 Eclipse：IDE，插件式，通用灵活，中期可用 Inteilj Idea：IDE，功能强大，新宠，Java EE 和 Java web 开发必备]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 语言简介和初体验]]></title>
    <url>%2F2018%2F07%2FPython%20%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[文章纯手打，如果文章哪里有错别字还请谅解！ Python语言介绍： 面向对象，解释型计算机程序设计 设计哲学：优雅，明确，简单，可读性强 优点：功能强大，开发效率高，应用广泛，易上手，语法简洁 缺点： ①运行速度慢 和C语言相比，因为Python是解释型的语言，代码会在执行时会一行一行地翻译成CPU能理解的机器码 C语言，运行前直接编译成CPU能执行的机器码 ②代码不能加密 用途：网页开发、可视化（GUI）界面开发、网络、系统编程、数据分析、及其学习、网络爬虫、科学计算 著名网站：雅虎地图、谷歌中很多组成部分、Youtube、豆瓣网 与其他语言比较： 123456789//Java public class Main&#123; public static void main(String[] args)&#123; System.out.println("Hello World"); &#125; &#125; 123#Python#!/usr/bin/pythonprint("Hello World") 安装Python和配置环境：1.安装Python 注：确认设备为32位还是64位操作系统，注意平台分为AMD和Intel，特别要注意勾上 Add Python 3.6 to PATH，然后点“Install Now”即可完成安装。 2.启动Python 启动方式：Python图形化界面 Windows:启动命令提示符窗口-&gt;输入python-&gt;退出exit()并回车 Mac&amp;&amp;Linux:-打开终端-&gt;运行python3 3.Python Interpreter(Python解释器) python.exe 为python解释器 4.环境变量 将解释器的路径加入系统环境变量的path中 使用文本编辑器用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行程序了。 Python交互模式和直接运行.py文件有什么区别？ 直接输入 python 直接进入交互模式，相当于启动了Python解释器，但是等你一行一行输入源码，每输入一行就执行一行。 直接运行.py 文件相当于启动了Python解释器，然后一次性执行多行代码。 输入和输出 输出 用print()在括号中加上字符串，就可以想屏幕上输出指定的文字。1print('Hello World!') print()函数也可以接受多个字符串，用逗号”,”隔开，就可以连成一串输出。123print('My name','is','xxx')#输出结果My name is xxx print()会依次打印每个字符串，遇到逗号”,”就会输出一个空格。123print('This is','my','book')#输出结果This is my book print()也可以打印整数，或者计算结果：1234print(300)300print(100 + 200)300 输入 Python提供了一个input(),可以让用户输入字符串，并存放到一个变量里。123name = input() #输入任意字符，按下回车完成输入name #输入变量名name，查看变量内容Michael input()可以让你显示一个字符串来提示用户。 123name = input('please enter your name: ')please enter your name:print('hello,', name) 小结 1.认识Python2.学会如何把Python安装到计算机中，并且熟练打开和退出Python交互式环境。 在Windows上运行Python时，请先启动命令行，然后运行python。 在Mac和Linux上运行Python时，请打开终端，然后运行python3。 3.在Python交互式模式下，可以直接输入代码，然后执行，并立刻得到结果。 命令行模式下，可以直接运行.py文件。4.输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World！]]></title>
    <url>%2FHello-World%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Hello World！博客第一帖。Share to u.]]></content>
  </entry>
</search>
