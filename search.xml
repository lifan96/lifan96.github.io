<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Session之验证码案例</title>
      <link href="/2020/02/04/2020/02/Session%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/02/04/2020/02/Session%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h2><pre><code>1. 访问带有验证码的登录页面login.jsp2. 用户输入用户名，密码以及验证码。* 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误* 如果验证码输入有误，跳转登录页面，提示：验证码错误* 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</code></pre><p><img src="https://tva4.sinaimg.cn/large/80ceacb8ly1gbkboox5mcj211s0h8gmj.jpg" alt="image"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/loginServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        String checkCode = request.getParameter(<span class="string">"checkCode"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先获取服务器生成的验证码</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        String checkCode_session = (String) session.getAttribute(<span class="string">"checkCode_session"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除session中的存储验证码</span></span><br><span class="line">        session.removeAttribute(<span class="string">"checkCode_session"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.先判断验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (checkCode_session != <span class="keyword">null</span> &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode))&#123;</span><br><span class="line">            <span class="comment">//忽略大小写比较</span></span><br><span class="line">            <span class="comment">//验证码正确</span></span><br><span class="line">            <span class="comment">//判断用户名和密码是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"zhangsan"</span>.equals(username) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">                <span class="comment">//登录成功</span></span><br><span class="line">                <span class="comment">//存储信息，用户信息</span></span><br><span class="line">                session.setAttribute(<span class="string">"user"</span>,username);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重定向到success.jsp</span></span><br><span class="line">                response.sendRedirect(request.getContextPath()+<span class="string">"/success.jsp"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//登陆失败</span></span><br><span class="line">                <span class="comment">//存储提示信息到request</span></span><br><span class="line">                request.setAttribute(<span class="string">"login_error"</span>,<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">                <span class="comment">//转发到登录页面</span></span><br><span class="line">                request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//验证码不一致</span></span><br><span class="line">            <span class="comment">//存储提示信息到request</span></span><br><span class="line">            request.setAttribute(<span class="string">"cc_error"</span>,<span class="string">"验证码错误！"</span>);</span><br><span class="line">            <span class="comment">//转发到登录页面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Response之验证码</title>
      <link href="/2020/02/01/2020/02/Response%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2020/02/01/2020/02/Response%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ol><li><p>步骤</p><ul><li>创建对象，在内存中生成图片（验证码图片对象）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">BufferedImage image = <span class="keyword">new</span> BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);</span><br></pre></td></tr></table></figure><ul><li>美化图片</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//美化图片</span></span><br><span class="line">        <span class="comment">//填充背景色</span></span><br><span class="line">        Graphics g = image.getGraphics();  <span class="comment">//画笔对象</span></span><br><span class="line">        g.setColor(Color.PINK);<span class="comment">//设置背景色</span></span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画边框</span></span><br><span class="line">        g.setColor(Color.BLUE);</span><br><span class="line">        g.drawRect(<span class="number">0</span>,<span class="number">0</span>,width-<span class="number">1</span>,height-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"</span>;</span><br><span class="line">        <span class="comment">//生成随机下标</span></span><br><span class="line">        Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ran.nextInt(str.length());</span><br><span class="line">            <span class="comment">//获取字符</span></span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写验证码</span></span><br><span class="line">            g.drawString(ch+<span class="string">""</span>,width/<span class="number">5</span>*i,height/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画干扰线</span></span><br><span class="line">        g.setColor(Color.GREEN);</span><br><span class="line">        <span class="comment">//随机生成坐标点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = ran.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> x2 = ran.nextInt(width);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> y1 = ran.nextInt(height);</span><br><span class="line">            <span class="keyword">int</span> y2 = ran.nextInt(height);</span><br><span class="line">            g.drawLine(x1,y1,x2,y2);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>将图片输出到页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将图片输出到页面展示</span></span><br><span class="line">       ImageIO.write(image,<span class="string">"jpg"</span>,resp.getOutputStream());</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识分析</title>
      <link href="/2019/08/09/2019/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/09/2019/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1g5t4xw7828j20d608bjrw.jpg" alt="批注 2019-08-08 163614"></p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><ol><li><p>为什么要使用索引？ </p><ul><li>快速查询数据</li></ul></li><li><p>什么样的信息能成为索引？</p><ul><li>主键、唯一键以及普通索引等</li></ul></li><li><p>索引的数据结构</p><ul><li>生成索引，建立二叉查找树进行二分查找</li><li>生成索引，建立B-Tree结构进行查找</li><li>生成索引，建立B+-Tree结构进行查找</li><li>生成索引，建立Hash结构进行查找</li></ul></li><li><p>B-Tree</p><ul><li>根节点至少包括两个孩子</li><li>树中每个节点最多含有m个孩子（m&gt;=2）</li><li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子（ceil（）取上限）</li><li>所有叶子节点都位于同一层</li></ul></li><li><p>B+-Tree</p><ul><li>其定义基本与B树相同</li><li><strong>非叶子节点的子树指针与关键字个数相同</strong></li><li>非叶子节点的子树指针P[i]，指向关键字值 [k[i],k[i+1]) 子树</li><li>非叶子节点仅用来索引，数据都保存在叶子节点中</li><li>所有叶子节点均有一个链指针指向下一个叶子节点</li></ul></li><li><p>结论</p><p><strong>B+Tree更适合用来存储索引</strong></p><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更有利于对数据库的扫描</li></ul></li><li><p>Hash索引</p><p>缺点</p><ul><li>仅仅能满足“=”，“IN”，不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用部分索引键查询</li><li>不能避免表扫描</li><li>遇到大量Hash值相等的情况后性能比不一定就会比B-Tree索引高\</li></ul></li><li><p>BitMap索引是个神器（位图索引）</p></li></ol><h2 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h2><ul><li>密集索引文件中的<strong>每个搜索码值都对应一个索引值</strong></li><li>稀疏索引文件<strong>只为索引码的某些值建立索引项</strong></li></ul><p>InnoDB</p><ul><li>若一个主键被定义，该主键则作为密集索引</li><li>若没有主键被定义，该表的第一和唯一非空索引则作为密集索引</li><li>若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>如何定位并优化慢查询SQL</p><ul><li><p>根据慢日志定位慢查询SQL</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4z686ggj20ah03lwen.jpg" alt="photo"></p></li><li><p>使用explain等工具分析SQL</p><ul><li>type：出现index、all则需要优化</li><li>extra：出现using filesort、using temporary则需要优化</li></ul></li><li><p>修改SQL或者尽量让SQL走索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> person_info_large <span class="keyword">add</span> <span class="keyword">index</span> idx_name(<span class="keyword">name</span>); <span class="comment">/*为某个字段增加索引*/</span></span><br><span class="line"><span class="comment">/*强制通过某个索引查询*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> person_info_large <span class="keyword">force</span> <span class="keyword">index</span>(primary);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>联合索引的最左匹配原则的成因</p><p>联合索引：有两个字段组成的索引</p><ul><li>最左匹配原则：mysql会一直向右匹配直到遇到范围查询就停止匹配</li><li>= 和 in 可以乱序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p><strong>直接使用第二个字段是用不到索引的</strong></p></li><li><p>索引是建立得越多越好吗？</p><p>不是。</p><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引也意味着需要更多的空间</li></ul></li></ol><h2 id="MyISAM与InnoDB关于锁方面的区别是什么？"><a href="#MyISAM与InnoDB关于锁方面的区别是什么？" class="headerlink" title="MyISAM与InnoDB关于锁方面的区别是什么？"></a>MyISAM与InnoDB关于锁方面的区别是什么？</h2><ol><li>MyISAM默认用的是表级锁，<strong>不支持行级锁</strong></li><li><strong>InnoDB默认用的是行级锁，也支持表级锁</strong><ul><li>二段锁：加锁和解锁是分成两个步骤进行的</li></ul></li></ol><ul><li><p>共享锁：上了共享锁之后，依然可以上共享锁，不支持上排它锁</p></li><li><p>排它锁：上了排它锁，另外的读或写都是不能操作的</p><p><img src="https://ws3.sinaimg.cn/large/80ceacb8ly1g5t8ivw58ej20d6056gln.jpg" alt="批注 2019-08-09 091319"></p></li></ul><p>MyISAM适合的场景</p><ul><li>频繁执行全表count语句</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><p>InnoDB适合的场景</p><ul><li>数据增删改查都相当频繁</li><li>可靠性比较高，要求支持事务</li></ul><h2 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h2><ul><li>按锁的粒度划分，可分为表级锁、行级锁、页级锁</li><li>按锁级别划分，可分为共享锁、排它锁</li><li>按加锁方式划分，可分为自动锁、显示锁</li><li>按操作划分，可分为DML锁（表数据）、DDL锁（表结构）</li><li>按使用方式划分，可分为乐观锁、悲观锁</li></ul><h2 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h2><p>ACID</p><ul><li>原子性（Atomic）：事务包含的所有操作，要么全部执行，要么全部回滚</li><li>一致性（Consistency）：事务应确保数据库的状态从一致状态到另一个一致状态，一致性状态，也就是数据的完整性</li><li><strong>隔离性（Isolation）</strong>：一个事务的执行不能影响其他事物的执行</li><li>持久性（Durability）：当系统或者介质发生故障时，确保以提交事务的更新不能丢失，即对已提交事物的更新能恢复</li></ul><h2 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h2><ul><li><p>更新丢失（一个事务的更新覆盖了另一个事务的更新）— mysql所有事务隔离级别在数据库层面上均可避免</p></li><li><p><strong>脏读</strong> — READ-COMMTTED事务隔离级别以上可避免</p><p><code>一个事务读到一个未提交事务的数据</code></p></li><li><p><strong>不可重复读</strong> — REPEATABLE-READ事务隔离级别以上可避免</p><p><code>事务A多次读取同一数据，在读取过程中进行了数据的更新并提交，事务A多次读取数据时不一致</code></p></li><li><p><strong>幻读</strong> — SERIALIZABLE事务隔离级别可避免</p><p><code>事务A读取与搜索条件相匹配的若干行，事务B插入或删除行修改事务A的结果集，导致事务A看起来像出现幻觉一样</code></p><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g5t8j3pagvj20kw08mgmk.jpg" alt="批注 2019-08-09 100211"></p></li></ul><h2 id="InnoDB可重复读隔离级别下如何避免幻读"><a href="#InnoDB可重复读隔离级别下如何避免幻读" class="headerlink" title="InnoDB可重复读隔离级别下如何避免幻读"></a>InnoDB可重复读隔离级别下如何避免幻读</h2><ul><li>表象：快照读（非阻塞读） – 伪MVCC<ul><li>当前读：select … lock in share mode,select…for udate，update，delete，insert</li><li>快照读：不加锁的非阻塞读，select</li></ul></li><li>内在：next-key锁（行锁+gap锁）<ul><li>行锁</li><li><strong>Gap锁</strong><ul><li>对主键索引或者唯一索引会用Gap锁吗？<ul><li>如果where条件全部命中，则不会用Gap锁，只会加记录锁</li><li>如果where条件部分命中或者全不命中，则会用Gap锁</li><li>Gap锁会用在非唯一索引或者不走索引的当前读中</li></ul></li></ul></li></ul></li></ul><h2 id="RC、RR级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RR级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RR级别下的InnoDB的非阻塞读如何实现"></a>RC、RR级别下的InnoDB的非阻塞读如何实现</h2><ul><li>数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段</li><li>undo日志</li><li>read view</li></ul><h2 id="语法部分"><a href="#语法部分" class="headerlink" title="语法部分"></a>语法部分</h2><ul><li>GROUP BY</li><li>HAVING：过滤组</li><li>统计相关：COUNT，SUM，MAX，MIN，AVG</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解计算机网络知识点</title>
      <link href="/2019/08/08/2019/08/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/08/08/2019/08/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="网络分层（自底向上）"><a href="#网络分层（自底向上）" class="headerlink" title="网络分层（自底向上）"></a>网络分层（自底向上）</h2><ol><li><p><strong>OSI 七层参考模型</strong></p><p>1.1 物理层</p><ul><li>主要定义物理设备的标准，如网线类型，光纤的接口类型等</li><li>单位：传输<strong>比特流</strong>（0101）<--->转换为机器码</---></li></ul><p>1.2 数据链路层</p><ul><li><p>如何格式化数据以进行传输，控制对物理介质的访问。提供对错误的检测和纠正，确保传输的可</p><p>靠性</p></li><li><p>单位：将比特数据—&gt;<strong>帧</strong></p></li></ul><p>1.3 网络层</p><ul><li>将网络地址翻译成对应的物理地址，如何将发送方的数据路由到接收方</li><li><strong>路由器属于网络层</strong></li><li>单位：<strong>数据报</strong></li><li>主要协议：IP</li></ul><p>1.4 传输层</p><ul><li>解决主机之间的数据传输，可以是不同网络之间</li><li>单位：<strong>分段</strong></li><li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议</li><li>UDP</li></ul><p>1.5 会话层</p><ul><li>建立和管理应用程序之间的通信</li></ul><p>1.6 表示层</p><ul><li>信息的语法语义以及它们的关联</li></ul><p>1.7 应用层</p><ul><li>HTTP协议</li></ul></li><li><p><strong>TCP/IP</strong></p></li></ol><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><ol><li>TCP简介<ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li><li>将应用层的数据流分隔成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，<strong>对方收到则发送ACK确认</strong>，未收到则重传</li><li>使用奇偶校验和来检验数据在传输过程中是否有错误</li></ul></li><li>TCP Flags<ul><li>URG：紧急指针标志  为1时表示有效，为0则忽略</li><li><strong>ACK：确认序号标志</strong>  为1时表示有效，为0不含确认信息，则忽略</li><li>PSH：push标志  为1时指示接收方在接收到的报文段尽快交给应用程序，而不是在缓冲区排队</li><li>RST：重置连接标志 用于重置由于主机崩溃产生的错误连接、非法的报文段和拒绝连接</li><li><strong>SYN：</strong>同步序号，用于建立连接过程</li><li><strong>FIN：</strong>finish标志，用于释放连接</li></ul></li><li><p>流程</p><ul><li>第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，进入SYN_SEND状态，等待服务器确认</li><li>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=ack+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4t6mlcwj20cq08l0th.jpg" alt="批注 2019-08-08 101941"></p></li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>为什么需要三次握手才能建立起连接？</p><p>为了初始化Sequence Number的初始值</p></li><li><p>首次握手的隐患—SYN超时</p><ul><li>Server收到Client的SYN，回复SYN-ACK的时候未收到ACK的确认</li><li>Server不断重试直至超时，Linux默认等待63秒才断开连接</li><li><strong>针对SYN Flood的防护措施</strong><ul><li>SYN队列满后，通过tcp_syncookies参数回发SYN Cookie</li><li>若为正常连接则Client会回发SYN Cookie，直接建立连接</li></ul></li></ul></li><li><p>建立连接后，Client出现故障怎么办？</p><p>保活机制</p><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍未收到响应则中断连接</li></ul></li></ol><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>“挥手”是为了终止连接 </p><ol><li><p>流程</p><ul><li>第一次挥手：Client发送一个FIN，用来关闭Client到server的数据传送，Client进入FIN_WAIT_1状态</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</li></ul><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4tsq86yj20bw08rdgl.jpg" alt="批注 2019-08-08 104547"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3></li><li><p>为什么会有TIME_WAIT状态？</p><ul><li>确保有足够的时间让对方收到ACK包</li><li>避免新旧连接混淆</li></ul></li><li>为什么需要四次握手才能断开连接？<ul><li>因为全双工，发送方和接收方都需要FIN报文和ACK报文</li></ul></li><li>服务器出现大量CLOSE_WAIT状态的原因<ul><li>对方关闭Socket连接，我方忙于读或写，没有及时关闭连接<ul><li>检查代码，特别是释放资源的代码</li><li>检查配置，特别是处理请求的线程配置</li></ul></li></ul></li></ol><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>面向连接 VS 无连接</li><li>可靠性</li><li>有序性</li><li>速度</li><li>量级</li></ul><h2 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h2><ol><li><p>RTT和RTO</p><ul><li>RTT：发送一个数据包到收到对应的ACK，所花费时间</li><li>RTO：重传时间间隔</li></ul></li><li><p>TCP使用滑动窗口做流量控制与乱序重排</p><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul></li><li><p>窗口数据的计算过程</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4ujj3w0j20ev05ydg4.jpg" alt="批注 2019-08-08 111202"></p><ul><li>AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd - LastByteRead)</li><li>EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked)</li></ul></li><li><p>TCP会话的发送方</p><p>四种状态</p><ul><li>Sent and Acknowledged</li><li>Sent But Not Yet Acknowledged（发送窗口）</li><li>Not Sent Recipient Ready to Receive（发送窗口）</li><li>Not Sent Recipient NOT Ready to Receive</li></ul></li><li><p>TCP会话的接收方</p><p>三种状态</p><ul><li>Received and Acknowledged</li><li>Not Yet Received，Transmitter Permitted To Send（接收窗口）</li><li>Not Yet Received，Transmitter May Not Send</li></ul></li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol><li><p>超文本传输协议特点：</p><ul><li>支持客户、服务器模式</li><li>简单快速</li><li>灵活</li><li>无连接</li><li>无状态</li></ul></li><li><p>HTTP请求结构</p><p><img src="https://ws3.sinaimg.cn/large/80ceacb8ly1g5t4vadz7nj20ed04hq36.jpg" alt="批注 2019-08-08 112622"></p></li><li><p>HTTP响应结构</p><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4vpaahyj20ea04ajrl.jpg" alt="批注 2019-08-08 112740"></p></li><li><p>请求/响应的步骤</p><ul><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接收请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端浏览器解析HTML内容</li></ul></li><li><p>HTTP状态码</p><p>五种</p><ul><li>1xx：指示信息—表示请求已接收，继续处理</li><li>2xx：成功—表示请求已被成功接收、理解、接受</li><li>3xx：重定向—要完成请求必须进行更进一步地操作</li><li>4xx：客户端错误—请求有语法错误或请求无法实现</li><li>5xx：服务器端错误—服务器未能实现合法的请求</li></ul></li></ol><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ol><li><p>在浏览器地址栏键入URL，按下回车之后经历的流程？</p><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul></li><li><p>常见的HTTP状态码</p><ul><li>200 OK：正常返回信息</li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在，eg，输入错误的URL</li><li>500 InternalServer Error：服务器发生不可预期的错误</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间可能恢复正常</li></ul></li><li><p>GET请求和POST请求的区别</p><ul><li>Http报文层面：GET将请求信息放在URL,POST放在报文体中</li><li>数据库层面：GET符合幂等性和安全性，POST不符合</li><li>其他层面：GET可以被缓存、被存储，而POST不行</li></ul></li><li><p>Cookie和Session的区别</p><p>4.1 Cookie简介</p><ul><li><p>是由<strong>服务器发给客户端</strong>的特殊信息，以文本的形式存放在客户端</p></li><li><p>客户端再次请求时，会把Cookie回发</p></li><li><p>服务器接收到后，会解析Cookie生成与客户端相对应的内容</p></li><li><p>Cookie的设置以及发送过程</p><p><img src="https://ws1.sinaimg.cn/large/80ceacb8ly1g5t4vy8140j20e606yjrk.jpg" alt="批注 2019-08-08 134015"></p></li></ul><p>4.2 Session简介</p><ul><li><p><strong>服务器端的机制</strong>，在服务器上保存的信息</p></li><li><p>解析客户端请求并操作session id，按需保存状态信息</p></li><li><p>使用Cookie来实现</p></li><li><p>使用URL回写来实现</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4wsjhkgj20dq05nweq.jpg" alt="批注 2019-08-08 134823"></p></li></ul><p>4.3 区别</p><ul><li><strong>Cookie数据存放在客户端的浏览器上，Session数据放在服务器上</strong></li><li><strong>Session相对于Cookie更安全</strong></li><li><strong>若考虑减轻服务器负担，应当使用Cookie</strong><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2></li></ul></li><li><p>SSL简介（Security Sockets Layer，安全套接层）</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统外的API，SSL3.0后更名为TLS</li><li>采用<strong>身份验证和数据加密</strong>保证网络的安全和数据的完整性</li></ul></li><li>加密方式<ul><li>对称加密：加密解密都是用同一个秘钥</li><li>非对称加密：加密使用的秘钥和解密使用的秘钥是不相同的 </li><li>哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆</li><li>数字签名：证明某个消息或文件是某人发出/认同的</li></ul></li><li><p>HTTPS数据传输流程</p><ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</li><li>浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li><li>浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据</li></ul></li><li><p>HTTP和HTTPS的区别</p><ul><li>HTTPS需要到CA申请证书，HTTP不需要 </li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li><li>HTTPS = HTTP +加密 +认证+完整性保护，较HTTP安全</li></ul></li></ol><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4x9lt20j20ex08kgm3.jpg" alt="批注 2019-08-08 154824"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2019/08/07/2019/08/Maven/"/>
      <url>/2019/08/07/2019/08/Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven能解决什么问题"><a href="#Maven能解决什么问题" class="headerlink" title="Maven能解决什么问题"></a>Maven能解决什么问题</h2><ol><li>引入工程所需的各种jar包</li><li>编译代码</li><li>可以进行单元测试</li><li>打包项目、部署项目</li></ol><h2 id="仓库种类"><a href="#仓库种类" class="headerlink" title="仓库种类"></a>仓库种类</h2><ol><li>本地仓库</li><li>远程仓库【私服】</li><li>中央仓库</li></ol><h2 id="Maven常用的命令"><a href="#Maven常用的命令" class="headerlink" title="Maven常用的命令"></a>Maven常用的命令</h2><ol><li><strong>mvn complie</strong>：compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target 目录下。</li><li><strong>mvn test</strong>： maven 工程的测试命令 mvn test，会执行src/test/java下的单元测试类。</li><li><strong>mvn clean</strong>： maven 工程的清理命令，执行 clean 会删除 target 目录及内容。</li><li><strong>mvn package</strong>：package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于web 工程打成war包。</li><li><strong>mvn install</strong>：install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。</li></ol><p>注：当后面的命令执行时，前面的操作过程也都会自动执行，</p><h2 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h2><ul><li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</li><li><strong>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</strong></li><li>Site Lifecycle 生成项目报告，站点，发布站点</li></ul><h2 id="创建web项目问题"><a href="#创建web项目问题" class="headerlink" title="创建web项目问题"></a>创建web项目问题</h2><ul><li><p>出现不能没有创建servlet的选项，在pom文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/08/06/2019/08/redis/"/>
      <url>/2019/08/06/2019/08/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><ol><li>字符串类型 string</li><li>哈希类型 hash ： map格式  </li><li>列表类型 list ： linkedlist格式。<strong>支持重复元素</strong></li><li>集合类型 set  ：<strong>不允许重复元素</strong></li><li>有序集合类型 sortedset：<strong>不允许重复元素，且元素有顺序</strong></li></ol><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><ol><li>存储：set key value</li><li>获取： get key</li><li>删除： del key</li></ol><h3 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h3><ol><li>存储： hset key field value</li><li>获取： hget key field：获取指定的field对应的值<ul><li>hgetall key ：获取所有的field和value</li></ul></li><li>删除： hdel key field</li></ol><h3 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h3><ol><li>添加：可以添加一个元素到列表的头部（左边）或者尾部（右边）<ul><li>lpush key value：将元素加入列表左边</li><li>rpush key value：将元素加入列表右边</li></ul></li><li>获取：lrange key start end：范围获取</li><li>删除：<ul><li>lpop key：删除列表最左边的一个元素，并将元素返回</li><li>rpop key：删除列表最右边的一个元素，并将元素返回</li></ul></li></ol><h3 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型 set"></a>集合类型 set</h3><ol><li>存储：sadd key value</li><li>获取：smembers key:获取set集合中所有元素</li><li>删除：srem key value:删除set集合中的某个元素</li></ol><h3 id="有序集合类型-sortedset"><a href="#有序集合类型-sortedset" class="headerlink" title="有序集合类型 sortedset"></a>有序集合类型 sortedset</h3><ol><li>存储：zadd key score value</li><li>获取：zrange key start end [withscores]</li><li>删除：zrem key value</li></ol><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ol><li>keys * : 查询所有的键</li><li>type key ： 获取键对应的value的类型</li><li>del key：删除指定的key value</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ol><li><p>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p></li><li><p>redis持久化机制：</p><ul><li><p>RDB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 默认方式，不需要进行配置，默认就使用这种机制</span><br><span class="line">* 在一定的间隔时间中，检测key的变化情况，然后持久化数据</span><br><span class="line">1.编辑redis.windows.conf 文件</span><br><span class="line"># after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">save 900 1</span><br><span class="line"># after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">save 300 10</span><br><span class="line"># after 60 sec if at least 10000 keys changed</span><br><span class="line">save 60 10000</span><br><span class="line">2.重新启动redis服务器，并指定配置文件名称</span><br><span class="line">* redis目录下打开cmd，输入redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure></li><li><p>AOF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</span><br><span class="line">1.编辑redis.windows.conf 文件</span><br><span class="line">appendonly no(关闭aof)---&gt;appendonly yes (打开aof)</span><br><span class="line"># appendfsync always ： 每一次操作都进行持久化</span><br><span class="line">appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line"># appendfsync no ： 不进行持久化</span><br><span class="line">2.重新启动redis服务器，并指定配置文件名称</span><br><span class="line">* redis目录下打开cmd，输入redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><ol><li><p>Jedis: 一款java操作redis数据库的工具</p></li><li><p>使用步骤：</p><ul><li>下载jedis的jar包</li><li>使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2.操作</span></span><br><span class="line">jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//3.关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li><li><p>Jedis中的方法与各种数据结构的操作名字一致</p></li></ol><h3 id="Jedis-连接池"><a href="#Jedis-连接池" class="headerlink" title="Jedis 连接池"></a>Jedis 连接池</h3><ol><li>使用<ul><li>创建JedisPool连接池对象</li><li>调用方法 getResource()方法获取Jedis连接</li></ul></li></ol><hr><hr><h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><ol><li><p>为什么Redis能这么快？</p><p>100000+QPS（QPS，每秒内查询的次数）</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，执行下率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程</li></ul></li><li><p>多路I/O复用模型</p><ul><li><p>FD：File Description，文件描述符</p><p>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的的映射</p></li><li><p>Select系统调用</p><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1g5tako0hg9j2098074aa3.jpg" alt="批注 2019-08-09 110044"></p></li></ul></li><li><p><strong>从海量key里查询出某一固定前缀的Key</strong></p><ul><li><strong>摸清数据规模，即问清楚边界</strong></li><li><strong>KEYS pattern：查找所有符合给定模式pattern的key</strong><ul><li>KEYS指令一次性返回所有匹配的key</li><li>键的数量过大会使服务卡顿</li></ul></li><li><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong><ul><li>基于游标的迭代器（cursor），需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li><li>一次返回的数量不可控，只能是大概率符合count参数</li></ul></li><li><strong>使用封装的相关jar包，如jedis，里面的方法进行查询</strong></li></ul></li><li><p>如何通过Redis实现分布式锁</p><p>分布式锁需要解决的问题</p><ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul><p><strong>SETNX key value：如果key不存在，则创建并赋值</strong></p><ul><li>时间复杂度：O(1)</li><li>返回值：设置成功，返回1；设置失败，返回0</li></ul><p><strong>如何解决SETNX长期有效的问题</strong></p><p><strong>EXPIRE key seconds</strong></p><ul><li>设置key的生存时间，当key过期时（生存时间为0），会被自动删除</li><li><strong>缺点：原子性得不到满足</strong></li></ul><p><strong>SET key value [Ex seconds] [PX milliseconds] [NX|XX]</strong></p><ul><li>Ex seconds：设置键的过期时间（秒）</li><li>PX milliseconds：设置键的过期时间（毫秒）</li><li>NX：只在键不存在时，才对建进行设置操作</li><li>XX：只在键已经存在时，才对键进行设置操作</li><li>SET操作成功完成时，返回OK，否则返回nil</li></ul><p><strong>大量的key同时过期的注意事项</strong></p><p>解放方案：在设置key的过期时间的时候，给key加上随机值</p></li><li><p>如何使用Redis做异步队列</p><p><strong>使用List作为队列，RPUSH生产消息，LPOP消费消息</strong></p><ul><li>缺点：没有等待队列里有值就直接消费</li><li>弥补：可以通过在应用层引入Sleep机制去调用LPOP重试</li></ul><p><strong>BLPOP key [key…] timeout：阻塞直到队列有消息或者超时</strong></p><ul><li>缺点：只能供一个消费者消费</li></ul><p><strong>pub/sub：主题订阅者模式</strong></p><ul><li>订阅者（pub）发送消息，订阅者（sub）接受消息</li><li>订阅者可以订阅任意数量的频道（Topic）</li><li>缺点：消费的发布是无状态的，无法保证可达</li></ul></li><li><p>使用Pipeline的好处</p><ul><li><p>批量执行指令，节省多次IO往返的时间</p></li><li><p>有顺序依赖的指令建议分批发送</p></li></ul></li><li><p><strong>Redis的同步机制</strong></p><p>主从同步原理</p><p><strong>全同步过程</strong></p><ul><li>Salve发送sync命令道Master</li><li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li><li>Master将保存数据快照期间接收到的写命令缓存起来</li><li>Master完成写文件操作后，将该文件发送给Salve</li><li>使用新的AOF文件替换掉就的AOF文件</li><li>Master将这期间收集的增量写命令发送给Salve端</li></ul><p><strong>增量同步过程</strong></p><ul><li>Master接收到用户的操作指令，判断是否需要传播到Slave</li><li>将操作记录追加到AOF文件</li><li>将操作传播到其他Salve：<ol><li>对齐主从库</li><li>往响应缓冲写入指令</li></ol></li><li>将缓存中的数据发送给Salve</li></ul></li><li><p>Redis的集群原理</p><ul><li><p>分片：按照某种规则去划分数据，分散存储在多个节点上</p></li><li><p>常规的按照哈希划分无法实现节点的动态增减</p><ul><li><p>一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环</p></li><li><p>将数据key使用相同的函数Hash计算出Hash值</p></li></ul></li><li><p>引入虚拟节点解决数据倾斜的问题</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ajax&amp;Json</title>
      <link href="/2019/08/05/2019/08/AJAX&amp;JSON/"/>
      <url>/2019/08/05/2019/08/AJAX&amp;JSON/</url>
      
        <content type="html"><![CDATA[<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ol><li><p>概念：ASynchronous JavaScript And XML    <strong>异步的JavaScript 和 XML</strong></p><ul><li>异步和同步：客户端和服务器端相互通信的基础上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</span><br><span class="line">异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</span><br><span class="line"></span><br><span class="line">详细解释：</span><br><span class="line">Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</span><br><span class="line">传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</span><br><span class="line"></span><br><span class="line">好处：提升用户体验</span><br></pre></td></tr></table></figure></li><li><p>实现方式：</p><ul><li><p>原生JS实现方式（了解）</p></li><li><p>JQuery实现方式</p><ul><li><p>$.ajax()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fuc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url:<span class="string">"ajaxServlet"</span>, <span class="comment">//请求路径</span></span><br><span class="line">                type:<span class="string">"post"</span>, <span class="comment">//请求方式，默认get</span></span><br><span class="line">                <span class="comment">//data:"username=jack&amp;age", //请求参数</span></span><br><span class="line">                data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;,</span><br><span class="line">                success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                alert(data)</span><br><span class="line">                &#125;,<span class="comment">//响应成功后的回调函数</span></span><br><span class="line">                error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    alert(<span class="string">"出错了..."</span>)</span><br><span class="line">                &#125;,<span class="comment">//表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line">                dataType:<span class="string">"text"</span>,<span class="comment">//设置接收到的数据的格式</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>$.get()：发送get请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 语法：$.get(url, [data], [callback], [type])</span><br><span class="line">* 参数：</span><br><span class="line">* url：请求路径</span><br><span class="line">* data：请求参数</span><br><span class="line">* callback：回调函数</span><br><span class="line">* type：响应结果的类型</span><br></pre></td></tr></table></figure></li><li><p>$.post()：发送post请求</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 语法：$.post(url, [data], [callback], [type])</span><br><span class="line">* 参数：</span><br><span class="line">      * url：请求路径</span><br><span class="line">      * data：请求参数</span><br><span class="line">      * callback：回调函数</span><br><span class="line">      * type：响应结果的类型</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol><li><p>概念：JavaScript Object Notation        JavaScript对象表示法</p><ul><li>json现在<strong>多用于存储和交换文本信息的语法</strong></li><li>进行数据的传输</li><li>JSON 比 XML 更小、更快，更易解析。</li></ul></li><li><p>基本规则</p><ul><li>数据在名称/值对中：json数据是由键值对构成的</li><li><p>键用引号(单双都行)引起来，也可以不使用引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">值得取值类型：</span><br><span class="line">1. 数字（整数或浮点数）</span><br><span class="line">2. 字符串（在双引号中）</span><br><span class="line">3. 逻辑值（true 或 false）</span><br><span class="line">4. 数组（在方括号中）&#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span><br><span class="line">5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125;</span><br><span class="line">6. null</span><br></pre></td></tr></table></figure></li><li><p>数据由逗号分隔：多个键值对由逗号分隔</p></li><li>花括号保存对象：使用{ }定义 json 格式</li><li>方括号保存数组：[]</li></ul></li><li><p>获取数据</p><ul><li><p>json对象.键名</p></li><li><p>json对象[“键名”]</p></li><li><p>数组对象[索引]</p></li><li><p>遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> person = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>,<span class="attr">age</span>:<span class="number">23</span>,<span class="string">'gender'</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> ps = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>, <span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"gender"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>, <span class="string">"age"</span>: <span class="number">24</span>, <span class="string">"gender"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"name"</span>: <span class="string">"王五"</span>, <span class="string">"age"</span>: <span class="number">25</span>, <span class="string">"gender"</span>: <span class="literal">false</span>&#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person)&#123;</span><br><span class="line">            <span class="comment">//alert(key + ":" + person.name);</span></span><br><span class="line">            alert(key + <span class="string">":"</span> + person[key])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; ps.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> p = ps[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> p)&#123;</span><br><span class="line">                alert(key + <span class="string">":"</span> + p[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>JSON数据和Java对象的相互转换</p><ul><li><p>常见的JSON解析器：Jsonlib，Gson，fastjson，jackson</p></li><li><p>JSON转换为Java对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用步骤：</span><br><span class="line">    * 导入jackson的相关jar包</span><br><span class="line">    * 创建Jackson核心对象 ObjectMapper</span><br><span class="line">    * 调用ObjectMapper的相关方法进行转换</span><br><span class="line">    * readValue(json字符串数据，Class)</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>Java对象转换JSON</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用步骤：</span><br><span class="line">* 导入jackson的相关jar包</span><br><span class="line">    * 创建Jackson核心对象 ObjectMapper</span><br><span class="line">    * 调用ObjectMapper的相关方法进行转换</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>转换方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* writeValue(参数1，obj):</span><br><span class="line">参数1：</span><br><span class="line">    File：将obj对象转换为JSON字符串，并保存到指定的文件中</span><br><span class="line">    Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</span><br><span class="line">    OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</span><br><span class="line">* writeValueAsString(obj):将对象转为json字符串</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>注解</p><ul><li>@JsonIgnore：排除属性。</li><li>@JsonFormat：属性值得格式化<ul><li>@JsonFormat(pattern = “yyyy-MM-dd”)</li></ul></li></ul></li><li><p>复杂java对象转换</p><ul><li>List：数组</li><li>Map：对象格式一致</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2019/08/02/2019/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/08/02/2019/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1-软件结构"><a href="#1-1-软件结构" class="headerlink" title="1.1 软件结构"></a>1.1 软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li><li><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li></ul><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p></li><li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p><p><img src="https://ws1.sinaimg.cn/large/80ceacb8gy1g17393zyfmj20dm08qjux.jpg" alt="image"></p></li></ul><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><ul><li><p><strong>UDP</strong>：<em>面向无连接通信协议</em>—&gt;即在数据传输时，数据的发送端和接收端不建立逻辑连接。</p><p>数据报：网络传输的基本单位</p><p>特点：消耗资源小，通信效率高；数据被限制在64kb以内</p><p>应用于：音频、视频和普通数据传输</p></li><li><p><strong>TCP</strong>：传输控制协议；面向连接的通信协议—&gt;即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中<strong>必须要明确客户端与服务器端</strong>，由客户端向服务端发出连接请求，每次连接的创建都需要经过“<strong>三次握手</strong>”。</p><ul><li>第一次握手：客户端向服务器发出连接请求，等待服务器确认</li><li>第二次握手：服务器向客户端返回一个响应，通知客户端收到了连接请求</li><li>第三次握手：客户端再次向服务器端发送确认信息，确认连接</li></ul><p>应用于：下载文件、浏览网页等</p></li></ul><h2 id="1-4-网络编程的三要素"><a href="#1-4-网络编程的三要素" class="headerlink" title="1.4 网络编程的三要素"></a>1.4 网络编程的三要素</h2><ul><li><p><strong>协议</strong></p></li><li><p><strong>IP地址</strong></p><p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</p></li><li><p>IP地址分类</p><ul><li><p>IPv4：<strong>是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式*</strong>，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，<strong>采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code></strong>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul></li><li><p><strong>端口号</strong></p><p>端口号是一个逻辑端口；当我们使用网络软件时，操作系统就会为网络软件分配一个随机的端口号或者网络软件打开的时候系统会指定一个端口号</p><p>组成：有两个字节组成，取值范围在0~65535之间</p><p>注意：1024之前的端口号不能使用，已经被系统分配给已知的网络软件</p><p>​           网络软件的端口号不能重复</p><p>常用端口号：80：网络端口；3306：MySQL；1521：Oracle；8080：Tomcat服务器</p></li></ul><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="两端通信时步骤"><a href="#两端通信时步骤" class="headerlink" title="两端通信时步骤"></a>两端通信时步骤</h3><ol><li>服务器端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功后才能通信。服务器端不可以主动连接客户端。</li></ol><h3 id="Java实现TCP通信的两个类"><a href="#Java实现TCP通信的两个类" class="headerlink" title="Java实现TCP通信的两个类"></a>Java实现TCP通信的两个类</h3><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li><li>简单记：服务器使用客户端的流和客户端交互</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是包含了IP地址和端口号的网络单位。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号</p></li><li><p>参数：</p><p>String host：服务器的名称、服务器的IP地址</p><p>int port：服务器的端口号</p></li><li><p>成员方法：</p><p>OutputStream getOutputStream()：返回此套接字的输出流</p><p>InputStream getInputStream()：返回此套接字的输入流</p><p>void close()：关闭此套接字</p></li></ul><h3 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h3><ol><li>创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流对象</li><li>使用网络字节输出流OutputStream 对象中的方法write，给服务器发送数据</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象</li><li>使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</li><li>释放资源（Socket）</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象</p></li><li><p>当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接</p><p>这时如果服务器没有启动，那么就会抛出异常</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4. 使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象</span></span><br><span class="line">       <span class="comment">//5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        String msg = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>ServerSocket(int port)：创建绑定到特定端口的服务器套接字</li></ul><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li>Socket accept()：侦听并接受到此套接字的连接</li><li>服务器必须明确—&gt;必须知道是哪个客户端请求的服务器，所以可以使用accept方法获取到请求的客户端对象Socket</li></ul><h3 id="服务器端实现步骤"><a href="#服务器端实现步骤" class="headerlink" title="服务器端实现步骤"></a>服务器端实现步骤</h3><ol><li>创建ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accept方法，获取到请求的客户端对象Socket</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流对象InputStream对象</li><li>使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流对象</li><li>使用网络字节输出流OutputStream 对象中的方法write，给客户端回写数据</li><li>释放资源（Socket，ServerSocket）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        String msg = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"收到谢谢"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2019/08/02/2019/08/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/08/02/2019/08/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想: </p><p>​    <strong>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</strong></p><h2 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h2><p>​        由三部分组成:<br>​            a.一些参数<br>​            b.一个箭头<br>​            c.一段代码<br>​        格式:<br>​            (参数列表) -&gt; {一些重写方法的代码};<br>​        解释说明格式:<br>​            ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔<br>​            -&gt;:传递的意思,把参数传递给方法体{}<br>​            {}:重写接口的抽象方法的方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Lambda表达式，实现多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;System.out.println(Thread.currentThread().getName()+<span class="string">"新的线程创建了"</span>);&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h2 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h2><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于多线程</title>
      <link href="/2019/08/02/2019/08/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/02/2019/08/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建多线程"><a href="#1-创建多线程" class="headerlink" title="1. 创建多线程"></a>1. 创建多线程</h2><h3 id="创建Thread类的子类"><a href="#创建Thread类的子类" class="headerlink" title="创建Thread类的子类"></a>创建Thread类的子类</h3><p>java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须<strong>继承Thread类</strong></p><p><strong>实现步骤:</strong><br>  1.创建一个Thread类的子类<br>  2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)<br>  3.创建Thread类的子类对象<br>  4.调用Thread类中的方法start方法,开启新的线程,执行run方法</p><ul><li>void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</li><li>结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。</li><li>多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</li><li>java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>实现步骤:<br>        1.创建一个Runnable接口的实现类<br>        2.在实现类中重写Runnable接口的run方法,设置线程任务<br>        3.创建一个Runnable接口的实现类对象<br>        4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象<br>        5.调用Thread类中的start方法,开启新的线程执行run方法</p><ul><li>实现Runnable接口创建多线程程序的好处:<pre><code>1.避免了单继承的局限性    一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类    实现了Runnable接口,还可以继承其他的类,实现其他的接口2.增强了程序的扩展性,降低了程序的耦合性(解耦)    实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)    实现类中,重写了run方法:用来设置线程任务    创建Thread类对象,调用start方法:用来开启新线程</code></pre></li></ul><h3 id="获取线程名称"><a href="#获取线程名称" class="headerlink" title="获取线程名称"></a>获取线程名称</h3><p>1.使用Thread类中的方法getName()<br>  String getName() 返回该线程的名称。<br>2.可以<strong>先获取到当前正在执行的线程</strong>,使用线程中的方法getName()获取线程的名称<br>  <strong>static Thread currentThread() </strong>返回对当前正在执行的线程对象的引用。<br>  Thread.currentThread().getName()</p><h3 id="设置线程名称（了解）"><a href="#设置线程名称（了解）" class="headerlink" title="设置线程名称（了解）"></a>设置线程名称（了解）</h3><p>1.使用Thread类中的方法setName(名字)<br>  void setName(String name) 改变线程名称，使之与参数 name 相同。<br>2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字<br>  Thread(String name) 分配新的 Thread 对象。</p><h3 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h3><p>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行</p><p>使用：Thread.sleep(暂停时间)           </p><h3 id="匿名内部类实现线程的创建"><a href="#匿名内部类实现线程的创建" class="headerlink" title="匿名内部类实现线程的创建"></a>匿名内部类实现线程的创建</h3><p>匿名:没有名字<br>内部类:写在其他类内部的类</p><p>匿名内部类作用:简化代码<br>把子类继承父类,重写父类的方法,创建子类对象合一步完成<br>把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成<br>匿名内部类的最终产物:子类/实现类对象,而这个类没有名字</p><p>格式:<br>  new 父类/接口(){<br>   重复父类/接口中的方法<br>   };</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程的父类是Thread</span></span><br><span class="line">        <span class="comment">// new MyThread().start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+<span class="string">"黑马"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程的接口Runnable</span></span><br><span class="line">        <span class="comment">//Runnable r = new RunnableImpl();//多态</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+<span class="string">"程序员"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+<span class="string">"传智播客"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-解决线程安全"><a href="#2-解决线程安全" class="headerlink" title="2. 解决线程安全"></a>2. 解决线程安全</h2><h3 id="使用同步代码块"><a href="#使用同步代码块" class="headerlink" title="使用同步代码块"></a>使用同步代码块</h3><p>格式:<br>synchronized(锁对象){<br>   可能会出现线程安全问题的代码(访问了共享数据的代码)<br>   }</p><p>注意:<br>  1.通过代码块中的锁对象,可以使用任意的对象<br>  2.但是必须保证多个线程使用的锁对象是同一个<br>  3.锁对象作用:把同步代码块锁住,只让一个线程在同步代码块中执行</p><h3 id="使用同步方法"><a href="#使用同步方法" class="headerlink" title="使用同步方法"></a>使用同步方法</h3><p>使用步骤:<br>1.把访问了共享数据的代码抽取出来,放到一个方法中<br>2.在方法上添加synchronized修饰符</p><p>格式:定义方法的格式<br>修饰符 synchronized 返回值类型 方法名(参数列表){<br>   可能会出现线程安全问题的代码(访问了共享数据的代码)<br>   }</p><h3 id="使用Lock锁"><a href="#使用Lock锁" class="headerlink" title="使用Lock锁"></a>使用Lock锁</h3><p>解决线程安全问题的三种方案:使用Lock锁<br><strong>java.util.concurrent.locks.Lock接口</strong><br>Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。<br>Lock接口中的方法:<br>  void lock()获取锁。<br>  void unlock()  释放锁。<br>  <strong>java.util.concurrent.locks.ReentrantLock implements Lock接口</strong></p><p>使用步骤:<br>1.在成员位置创建一个ReentrantLock对象<br>2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁<br>3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</p><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3. 线程状态"></a>3. 线程状态</h2><p><img src="https://ws2.sinaimg.cn/large/80ceacb8ly1g0afwosfsjj20im09y0ug.jpg" alt="image"></p><h3 id="Timed-Waiting-（计时等待）"><a href="#Timed-Waiting-（计时等待）" class="headerlink" title="Timed Waiting （计时等待）"></a>Timed Waiting （计时等待）</h3><p>进入到TimeWaiting(计时等待)有两种方式<br>1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态<br>2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态</p><p>唤醒的方法:</p><ul><li>void notify() 唤醒在此对象监视器上等待的单个线程。</li><li>void notifyAll() 唤醒在此对象监视器上等待的所有线程。</li></ul><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g0ag0wars9j20hd0ax0t2.jpg" alt="image"></p><h3 id="BLOCKED-（锁阻塞）"><a href="#BLOCKED-（锁阻塞）" class="headerlink" title="BLOCKED （锁阻塞）"></a>BLOCKED （锁阻塞）</h3><p><img src="https://ws2.sinaimg.cn/large/80ceacb8ly1g0ag14hbjrj20ha0axq38.jpg" alt="image"></p><h3 id="Waiting-（无限等待）"><a href="#Waiting-（无限等待）" class="headerlink" title="Waiting （无限等待）"></a>Waiting （无限等待）</h3><p><img src="https://ws3.sinaimg.cn/large/80ceacb8ly1g0ag3ib6ssj20hl0dpgma.jpg" alt="image"></p><h3 id="等待唤醒案例-线程之间的通信"><a href="#等待唤醒案例-线程之间的通信" class="headerlink" title="等待唤醒案例:线程之间的通信"></a>等待唤醒案例:线程之间的通信</h3><p>创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)<br>创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子</p><p>注意:</p><ul><li>顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行</li><li>同步使用的锁对象必须保证唯一</li><li>只有锁对象才能调用wait和notify方法</li></ul><h2 id="4-线程通信"><a href="#4-线程通信" class="headerlink" title="4. 线程通信"></a>4. 线程通信</h2><blockquote><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p></blockquote><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener</title>
      <link href="/2019/08/01/2019/08/Filter&amp;Listener/"/>
      <url>/2019/08/01/2019/08/Filter&amp;Listener/</url>
      
        <content type="html"><![CDATA[<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><ol><li><p>概念：</p><ul><li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能</li><li>过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li></ul></li><li><p>使用步骤：</p><ul><li><p>定义一个类，实现接口Filter</p></li><li><p>复写方法</p></li><li><p>配置拦截路径</p><ul><li><p>web.xml</p></li><li><p>注解</p><p>@WebFilter(“/*”)//访问所有资源之前，都会执行该过滤器</p></li></ul></li></ul></li><li><p>过滤器细节</p><ul><li><p>web.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.lifan.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--拦截路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>过滤器执行流程</p><ul><li><p>执行过滤器</p></li><li><p>执行放行后的资源</p></li><li><p>回来执行过滤器放行代码下边的代码</p></li></ul></li><li><p>过滤器声明周期方法</p><ul><li>init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。<strong>用于加载资源</strong></li><li>doFilter：每一次请求被拦截资源时，会执行。执行多次</li><li>destory：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。<strong>用于释放资源</strong></li></ul></li><li><p>过滤器配置详解</p><ul><li><p>拦截路径配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 具体资源路径：/index.jsp 只有访问index.jsp资源时，过滤器才会被执行</span><br><span class="line">2. 拦截目录： /user/*访问/user下的所有资源时，过滤器都会被执行</span><br><span class="line">3. 后缀名拦截： *.jsp访问所有后缀名为jsp资源时，过滤器都会被执行</span><br><span class="line">4. 拦截所有资源：/*访问所有资源时，过滤器都会被执行</span><br></pre></td></tr></table></figure></li><li><p>拦截方式配置：资源被访问的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 注解配置：</span><br><span class="line">* 设置dispatcherTypes属性</span><br><span class="line">  1. REQUEST：默认值。浏览器直接请求资源</span><br><span class="line">  2. FORWARD：转发访问资源</span><br><span class="line">  3. INCLUDE：包含访问资源</span><br><span class="line">  4. ERROR：错误跳转资源</span><br><span class="line">  5. ASYNC：异步访问资源</span><br><span class="line">* web.xml配置</span><br><span class="line">* 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可</span><br></pre></td></tr></table></figure></li></ul></li><li><p>过滤器链（配置多个过滤器）</p><ul><li><p>执行顺序：如果有两个过滤器：过滤器1和过滤器2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过滤器1--&gt;过滤器2--&gt;资源执行--&gt;过滤器2--&gt;过滤器1</span><br></pre></td></tr></table></figure></li><li><p>过滤器先后顺序问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 注解配置：按照类名的字符串比较规则比较，值小的先执行</span><br><span class="line">* 如： AFilter 和 BFilter，AFilter就先执行了</span><br><span class="line">2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>增强对象的功能：使用设计模式（一些通用的解决固定问题的方式）</p><ul><li><p>装饰模式</p></li><li><p>代理模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 概念：</span><br><span class="line"> 1. 真实对象：被代理的对象</span><br><span class="line"> 2. 代理对象：</span><br><span class="line"> 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的</span><br><span class="line">* 实现方式：</span><br><span class="line"> 1. 静态代理：有一个类文件描述代理模式</span><br><span class="line"> 2. 动态代理：在内存中形成代理类</span><br><span class="line"> * 实现步骤：</span><br><span class="line"> * 代理对象和真实对象实现相同的接口</span><br><span class="line"> * Proxy.newProxyInstance();</span><br><span class="line"> * 使用代理对象调用方法</span><br><span class="line"> * 增强方法</span><br><span class="line"> * 增强方式：</span><br><span class="line"> * 增强参数列表</span><br><span class="line"> * 增强返回值类型</span><br><span class="line"> * 增强方法体执行逻辑</span><br></pre></td></tr></table></figure></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><ol><li><p>事件监听机制</p><ul><li>事件：一件事情</li><li>事件源：事件发生的地方（比如按钮）</li><li>监听器：一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。当时事件源上发生某个事件后，执行监听器代码</li></ul></li><li><p>ServletContextListener（接口）</p><ul><li><p>创建</p><p>void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法</p></li><li><p>销毁</p><p>void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法</p></li></ul></li><li><p>实现步骤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 定义一个类，实现ServletContextListener接口</span><br><span class="line">   * 复写方法</span><br><span class="line">   * 配置</span><br><span class="line">   * web.xml</span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.lifan.listener.ContextLoderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   * 指定初始化参数<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   * 注解</span><br><span class="line">         @WebListener</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSP&amp;EL&amp;JSTL</title>
      <link href="/2019/07/31/2019/07/JSP&amp;EL&amp;JSTL/"/>
      <url>/2019/07/31/2019/07/JSP&amp;EL&amp;JSTL/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ol><li>概念：Java Server Pages： java服务器端页面</li><li>原理：JSP本质上就是一个Servlet（JSP–&gt;.java–&gt;class–&gt;执行）</li><li>JSP的脚本：<ul><li>&lt;% 代码 %&gt;：定义的java代码，<strong>在service方法中</strong>。service方法中可以定义什么，该脚本中就可以定义什么。</li><li>&lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的<strong>java类的成员位置</strong>（成员变量或方法）。</li><li>&lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。<strong>输出语句中可以定义什么，该脚本中就可以定义什么</strong>。</li></ul></li><li><p>JSP的内置对象：在jsp页面中<strong>不需要获取和创建</strong>，可以直接使用的对象</p><ul><li>request</li><li>response</li><li>out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似</li><li><strong>response.getWriter()和out.write()的区别：</strong><ul><li>在tomcat服务器真正给客户端做出响应之前，<strong>会先找response缓冲区数据，再找out缓冲区数据。</strong></li><li>response.getWriter()数据输出永远在out.write()之前</li></ul></li></ul></li><li><p>指令</p></li></ol><ul><li><p>作用：用于配置JSP页面，导入资源文件</p></li><li><p>格式：</p><p>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2…%&gt;</p></li><li><p>分类：</p><ul><li><p>page：配置JSP页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* contentType：等同于response.setContentType()</span><br><span class="line">* 设置响应体的mime类型以及字符集</span><br><span class="line">* 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</span><br><span class="line">* import：导包</span><br><span class="line">* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</span><br><span class="line">* isErrorPage：标识当前也是是否是错误页面。</span><br><span class="line">* true：是，可以使用内置对象exception</span><br><span class="line">* false：否。默认值。不可以使用内置对象exception</span><br></pre></td></tr></table></figure></li><li><p>include：页面包含的。导入页面的资源文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &lt;%@include file=&quot;top.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure></li><li><p>taglib：导入资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">* prefix：前缀，自定义的</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="6"><li>注释</li></ol><ul><li><p>html注释：\<!-- -->:只能注释html代码片段</p></li><li><p><strong>jsp注释：推荐使用</strong></p><p>&lt;%– –%&gt;：可以注释所有</p></li></ul><ol start="7"><li>内置对象</li></ol><p>变量名                    真实类型                        作用</p><ul><li>pageContext         PageContext        当前页面共享数据，还可以获取其他八个内置对象</li><li>request            HttpServletRequest        一次请求访问的多个资源(转发)</li><li>session            HttpSession                一次会话的多个请求间</li><li>application        ServletContext            所有用户间共享数据</li><li>response            HttpServletResponse        响应对象</li><li>page                Object                   当前页面(Servlet)的对象  this</li><li>out                JspWriter               输出对象，数据输出到页面上</li><li>config            ServletConfig            Servlet的配置对象</li><li>exception            Throwable                异常对象</li></ul><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li><p>M：Model，模型</p><p>完成具体的业务操作，如：查询数据库，封装对象</p></li><li><p>V：View，视图。JSP</p><p>展示数据</p></li><li><p>C：Controller，控制器。Servlet</p><p>获取用户的输入–&gt;调用模型–&gt;将数据交给视图进行展示</p></li><li><p>优缺点：</p><p>优点：</p><ul><li><p>耦合性低，方便维护，可以利于分工协作</p></li><li><p>重用性高</p></li></ul><p>缺点：</p><ul><li>使得项目架构变得复杂，对开发人员要求高</li></ul></li></ul><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ol><li><p>概念：Expression Language 表达式语言</p></li><li><p>作用：替换和简化jsp页面中java代码的编写</p></li><li><p>语法：${表达式}</p></li><li><p><strong>注意：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* jsp默认支持el表达式的。如果要忽略el表达式</span><br><span class="line">1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式</span><br><span class="line">2. \$&#123;表达式&#125; ：忽略当前这个el表达式</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li><p>运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 算数运算符： + - * /(div) %(mod)</span><br><span class="line">2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=</span><br><span class="line">3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)</span><br><span class="line">4. 空运算符： empty</span><br><span class="line">* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</span><br><span class="line">* $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0</span><br><span class="line">* $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0</span><br></pre></td></tr></table></figure></li><li><p>获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. el表达式只能从域对象中获取值</span><br><span class="line">2. 语法：</span><br><span class="line">* $&#123;域名称.键名&#125;：从指定域中获取指定键的值</span><br><span class="line">* 域名称：</span><br><span class="line">1. pageScope--&gt; pageContext</span><br><span class="line">2. requestScope--&gt; request</span><br><span class="line">3. sessionScope--&gt; session</span><br><span class="line">4. applicationScope--&gt; application（ServletContext）</span><br><span class="line">* 举例：在request域中存储了name=张三</span><br><span class="line">* 获取：$&#123;requestScope.name&#125;</span><br><span class="line">* $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</span><br><span class="line">$&#123;name&#125;</span><br><span class="line">* 获取对象、List集合、Map集合的值</span><br><span class="line">* 对象：$&#123;域名称.键名.属性名&#125;</span><br><span class="line">*本质上会去调用对象的getter方法</span><br><span class="line">* 简写：$&#123;键名.属性名&#125;</span><br><span class="line">* List集合：$&#123;域名称.键名[索引]&#125;</span><br><span class="line">* Map集合：</span><br><span class="line">* $&#123;域名称.键名.key名称&#125;</span><br><span class="line">* $&#123;域名称.键名[&quot;key名称&quot;]&#125;</span><br><span class="line">3.隐式对象：</span><br><span class="line">* el表达式中有11个隐式对象</span><br><span class="line">* pageContext：</span><br><span class="line">* 获取jsp其他八个内置对象</span><br><span class="line">* $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><ol><li><p>概念：JavaServer Pages Tag Library  JSP标准标签库</p><ul><li>是由Apache组织提供的开源的免费的jsp标签  &lt;标签&gt;</li></ul></li><li><p>作用：用于简化和替换jsp页面上的java代码</p></li><li><p>使用步骤：</p><ul><li>导入jstl相关jar包</li><li>引入标签库：taglib指令：  &lt;%@ taglib %&gt;</li><li>使用标签</li></ul></li><li><p>常用的 JSTL标签</p><ul><li><p>if：相当于java代码的if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性：</span><br><span class="line">     * test 必须属性，接受boolean表达式</span><br><span class="line">     * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</span><br><span class="line">     * 一般情况下，test属性值会结合el表达式一起使用</span><br><span class="line"> 注意：</span><br><span class="line">     * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签</span><br></pre></td></tr></table></figure></li><li><p>choose：相当于java代码的switch语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 使用choose标签声明         相当于switch声明</span><br><span class="line">* 使用when标签做判断             相当于case</span><br><span class="line">* 使用otherwise标签做其他情况的声明    相当于default</span><br></pre></td></tr></table></figure></li><li><p>foreach：相当于java代码的for语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">普通遍历（for）：</span><br><span class="line">    属性：</span><br><span class="line">* begin：开始值</span><br><span class="line">* end：结束值（包含）</span><br><span class="line">* var：临时变量</span><br><span class="line">* step：步长</span><br><span class="line">* varStatus：循环状态对象</span><br><span class="line">* index：容器中元素的索引，从0开始</span><br><span class="line">* count：循环次数，从1开始</span><br><span class="line">遍历容器（foreach）：</span><br><span class="line">属性：</span><br><span class="line">* items：容器对象</span><br><span class="line">* var：容器中的临时变量</span><br><span class="line">* varStatus：循环状态对象</span><br><span class="line">* index：容器中元素的索引，从0开始</span><br><span class="line">* count：循环次数，从1开始</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>会话技术</title>
      <link href="/2019/07/30/2019/07/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/07/30/2019/07/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><ol><li><p>会话：<strong>一次会话</strong>中包含多次请求和响应。</p><ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，<strong>直到有一方断开为止</strong></li></ul></li><li>功能：在一次会话的范围内的多次请求间，<strong>共享数据</strong></li><li><p>方式：</p><ul><li><p><strong>客户端</strong>会话技术：Cookie</p></li><li><p><strong>服务器端</strong>会话技术：Session</p></li></ul></li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ol><li><p>概念：<strong>客户端会话技术，将数据保存到客户端</strong></p></li><li><p>使用步骤：</p><ul><li>创建Cookie对象，绑定数据<ul><li>new Cookie(String name,String value)</li></ul></li><li>发送Cookie对象<ul><li>response.addCookie(Cookie cookie) </li></ul></li><li>获取Cookie，拿到数据<ul><li>Cookie[]  request.getCookies() </li></ul></li></ul></li><li><p>实现原理</p><ul><li>基于<strong>响应头set-cookie</strong>和<strong>请求头cookie</strong>实现</li></ul></li><li><p>Cookie 细节</p><ul><li><p><strong>一次可不可以发送多个cookie?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</span><br></pre></td></tr></table></figure></li><li><p><strong>cookie在浏览器中保存多长时间？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 默认情况下，当浏览器关闭后，Cookie数据被销毁</span><br><span class="line">* 持久化存储：setMaxAge(int seconds)</span><br><span class="line">* 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</span><br><span class="line">* 负数：默认值</span><br><span class="line">* 零：删除cookie信息</span><br></pre></td></tr></table></figure></li><li><p><strong>cookie能不能存中文？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 在tomcat 8 之前 cookie中不能直接存储中文数据。</span><br><span class="line">* 需要将中文数据转码 ---&gt; 一般采用URL编码(%E3)</span><br><span class="line">* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</span><br></pre></td></tr></table></figure></li><li><p><strong>cookie共享问题？</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</span><br><span class="line">* 默认情况下cookie不能共享</span><br><span class="line">* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</span><br><span class="line">* 如果要共享，则可以将path设置为&quot;/&quot;</span><br><span class="line">2. 不同的tomcat服务器间cookie共享问题？</span><br><span class="line">* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</span><br><span class="line">* setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Cookie 的特点和作用</p><p>特点：</p><ul><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的<strong>大小有限制</strong>(4kb) 以及 对同一个域名下的总cookie<strong>数量也有限制</strong>(20个)</li></ul><p>作用：</p><ul><li>cookie一般用于存储少量的<strong>不太敏感的数据</strong></li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ul></li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol><li><p>概念：服务器端会话技术，<strong>在一次会话的多次请求间共享数据</strong>，将数据保存在服务器端的对象中。</p></li><li><p>入门：</p><ul><li><p>获取HTTPSession对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure></li><li><p>使用HTTPSession对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理：Session的实现是依赖于Cookie的。</p></li><li><p>细节：</p><ul><li><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 默认情况下。不是。</span><br><span class="line">* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。</span><br><span class="line">Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());</span><br><span class="line">c.setMaxAge(60*60);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li><li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</span><br><span class="line">* session的钝化：</span><br><span class="line">* 在服务器正常关闭之前，将session对象系列化到硬盘上</span><br><span class="line">* session的活化：</span><br><span class="line">* 在服务器启动后，将session文件转化为内存中的session对象即可。</span><br></pre></td></tr></table></figure></li><li><p><strong>Session什么时候被销毁？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 服务器关闭</span><br><span class="line">* session对象调用invalidate() 自杀</span><br><span class="line">* session默认失效时间 30分钟</span><br><span class="line">选择性配置修改（web.xml）</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Session的特点</p><ul><li>session用于存储一次会话的多次请求的数据，<strong>存在服务器端</strong></li><li><p>session可以存储<strong>任意类型，任意大小的数据</strong></p></li><li><p><strong>session与Cookie的区别：</strong></p><ul><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Response</title>
      <link href="/2019/07/29/2019/07/Response/"/>
      <url>/2019/07/29/2019/07/Response/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol><li><p>请求消息：客户端发送给服务器端的数据</p><ul><li><p>数据格式：</p><ul><li><p>请求行</p></li><li><p>请求头</p></li><li><p>请求空行</p></li><li><p>请求体</p></li></ul></li></ul></li><li><p>响应消息：服务器端发送给客户端的数据</p><ul><li><p>数据格式：</p><ul><li><p>响应行</p><ul><li><p>组成：协议和版本  响应状态码   状态码描述</p></li><li><p>响应状态码：服务器告诉客户端浏览器请求和响应的一个状态</p><ul><li><p>1XX：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p></li><li><p>2XX：成功。代表：200</p></li><li><p>3XX：重定向。代表：302(重定向)，304(访问缓存)</p></li><li><p>4XX：客户端错误</p><p>404（请求路径没有对应的资源） </p><p>405：请求方式没有对应的doxxx方法</p></li><li><p>5XX：服务器端错误。代表：500(服务器内部出现异常)</p></li></ul></li></ul></li><li><p>响应头</p><ul><li>格式：头名称 ：值</li><li>常见响应头：<ul><li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul><li>in-line:默认值,在当前页面内打开</li><li>attachment;filename=xxx：以附件形式打开响应体。文件下载</li></ul></li></ul></li></ul></li><li><p>响应空行</p></li><li><p>响应体：传输的数据</p></li></ul></li></ul></li></ol><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="功能：设置响应消息"><a href="#功能：设置响应消息" class="headerlink" title="功能：设置响应消息"></a>功能：设置响应消息</h3><ol><li><p>设置响应行</p><ul><li>格式：HTTP/1.1 200 ok</li><li>设置状态码：setStatus(int sc) </li></ul></li><li><p>设置响应头</p><ul><li>setHeader(String name, String value) </li></ul></li><li><p>设置响应体</p><ul><li><p>步骤：</p><p>① 获取输出流</p><ul><li>字符输出流：PrintWriter getWriter()</li><li>字节输出流：ServletOutputStream getOutputStream()</li></ul><p>② 使用输出流，将数据输出到客户端浏览器</p></li></ul></li></ol><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ol><li><p>方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 设置状态码为302</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">//2.设置响应头location</span></span><br><span class="line">response.setHeader(<span class="string">"location"</span>,<span class="string">"/day15/responseDemo2"</span>);</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/day15/responseDemo2"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="转发和重定向之间的区别"><a href="#转发和重定向之间的区别" class="headerlink" title="转发和重定向之间的区别"></a>转发和重定向之间的区别</h3><p>重定向的特点：<strong>redirect</strong></p><ol><li>地址栏发生变化</li><li>重定向可以访问其他站点(服务器)的资源</li><li>重定向是两次请求。<strong>不能使用request对象来共享数据</strong></li></ol><p>转发的特点：<strong>forward</strong></p><ol><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求，可以使用request对象来共享数据</li></ol><h3 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h3><p>步骤：</p><ol><li>获取<strong>字符输出流</strong></li><li>输出数据</li></ol><p>注意：</p><p><strong>乱码问题：</strong></p><ul><li><p>PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1</p></li><li><p>设置该流的默认编码</p></li><li><p>告诉浏览器响应体使用的编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的形式，设置编码，是在获取流之前设置</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="服务器输出字节数据到浏览器"><a href="#服务器输出字节数据到浏览器" class="headerlink" title="服务器输出字节数据到浏览器"></a>服务器输出字节数据到浏览器</h3><p>步骤：</p><ol><li><p>获取<strong>字节输出流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream sos = response.getOutputStream();</span><br></pre></td></tr></table></figure></li><li><p>输出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sos.write(<span class="string">"你好"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br></pre></td></tr></table></figure></li></ol><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><ol><li><p>概念：代表整个web应用，可以和程序的容器(服务器)来通信，一个web项目只包含一个</p></li><li><p>获取：</p><ul><li><p>通过 request  对象获取</p><p>request.getServletContext();</p></li><li><p>通过 HttpServlet 获取</p><p>this.getServletContext();</p></li></ul></li><li><p>获取MIME类型：</p><ul><li><p>MIME类型：在互联网通信过程中定义的一种文件数据类型</p><ul><li>格式： 大类型/小类型   text/html        image/jpeg</li><li>获取：String getMimeType(String file) </li></ul></li></ul></li><li><p>域对象：共享数据</p><ul><li>setAttribute(String name,Object value)</li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li><li><strong>ServletContext对象范围：所有用户所有请求的数据</strong></li></ul></li><li><p>获取文件的真实(服务器)路径</p><ul><li>方法：String getRealPath(String path) </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC相关问题</title>
      <link href="/2019/07/29/2019/07/jdbc%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/29/2019/07/jdbc%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="导入驱动jar包"><a href="#导入驱动jar包" class="headerlink" title="导入驱动jar包"></a>导入驱动jar包</h2><ol><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li><strong>右键–&gt;Add As Library</strong></li></ol><h2 id="各个对象"><a href="#各个对象" class="headerlink" title="各个对象"></a>各个对象</h2><ol><li><p>DriverManager：驱动管理对象</p><pre><code>* 功能：① 注册驱动：**告诉程序该使用哪一个数据库驱动jar**static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><pre><code>    **注意：mysql 5之后的驱动jar包可以省略注册驱动的步骤。**​     ② 获取数据库连接：​        方法：static Connection getConnection(String url, String user, String password) ​            参数：​                url：指定连接的路径​                语法：jdbc:mysql://ip地址(域名):端口号/数据库名称​                例子：jdbc:mysql://localhost:3306/db3​                    **细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简                                写为：jdbc:mysql:///数据库名称**​                user：用户名​                password：密码 </code></pre><ol start="2"><li><p>Connection：数据库连接对象</p><ul><li><p>功能：</p><p>① 获取执行sql 的对象</p></li><li><p>Statement createStatement()</p></li></ul><ul><li><p>PreparedStatement prepareStatement(String sql)  </p><p>②管理事务：</p></li><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit() </li><li>回滚事务：rollback() </li></ul></li><li><p>Statement：执行sql的对象</p><p>  ① 执行sql</p><ul><li>boolean execute(String sql) ：可以执行任意的sql 了解 </li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句<ul><li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</li><li>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</li></ul></li></ul></li><li><p>ResultSet：结果集对象,封装查询结果</p><ul><li>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</li></ul><ul><li><p>getXxx(参数):获取数据</p><pre><code>- Xxx：代表数据类型   如： int getInt() ,    String getString()</code></pre><ul><li>参数：<ol><li>int：代表列的编号,从1开始   如： getString(1)</li><li>String：代表列名称。 如： getDouble(“balance”)</li></ol></li></ul></li><li><p><strong>结果集对象也需要关闭资源</strong></p></li></ul></li><li><p><strong>PerparedStatement :执行sql对象</strong></p><p>  ① SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><ul><li><p>输入用户任意，输入密码 ‘a’ or ‘a’ = ‘a’  (false or true)</p><p>② 解决SQL注入问题：使用 PreparedStatement 对象来解决</p><p>③ 预编译的SQL：参数使用 ？作为占位符</p><p>④ 给 ？赋值：</p><p>方法：setxxx(参数1，参数2)</p><pre><code>- 参数1：？的位置 从1开始- 参数2：？的值</code></pre></li></ul></li></ol><pre><code>## JDBC事务### 操作- 开启事务：setAutoCommit(boolean autoCommit)：参数设置为false，即开始，默认为关闭  - 在执行sql之前开启事务- 提交事务：commit()  - 当所有sql都执行万提交事务- 回滚事务：rollback()  - 在catch中回滚事务## 数据库连接池&gt; 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。好处：    1. 节约资源     2. 用户访问高效标准接口：DataSource - 方法：  - 获取连接：getConnection()  - 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接- 数据库厂商实现  - C3P0：数据库连接池技术  - Druid：数据库连接池实现技术，由阿里巴巴提供的### C3P0数据库连接池技术步骤：1. 导入jar包   - c3p0-0.9.5.2.jar   - mchange-commons-java-0.2.12.jar   - mysql-connector-java-5.1.37-bin.jar（切记不能忘了导入这个）2. 定义配置文件   - 名称： c3p0.properties 或者 c3p0-config.xml   - 路径：直接将文件放在src目录下即可。3. 创建核心对象    - 数据库连接池对象 ComboPooledDataSource4. 获取连接： getConnection注意：1. 使用默认配置   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br></pre></td></tr></table></figure>2. 使用指定名称配置   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource ds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">"otherc3p0"</span>);</span><br></pre></td></tr></table></figure>### Druid数据库连接池技术步骤：1.  导入jar包   - druid-1.0.9.jar2. 定义配置文件   - properties形式   - 可以叫任意名称，可以放在任意目录下3. 加载配置文件，使用Properties类4. 获取数据库连接池对象：通过工厂类获取  DruidDataSourceFactory5. 获取连接：getConnection定义工具类：1. 定义一个类 JDBCUtils2. 提供静态代码块加载配置文件，初始化连接池对象3. 提供方法   - 获取连接方法：通过数据库连接池获取连接   - 释放资源   - 获取连接池的方法 ## Spring JDBC步骤：1. 导入jar包2. 创建JdbcTemplate对象，依赖于数据源DataSource   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(ds);</span><br></pre></td></tr></table></figure>3. 调用JdbcTemplate的方法来完成CRUD的操作   - update()：执行DML语句。增、删、改语句   - queryForMap()：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 。**注意：这个方法查询的结果集长度只能是1（真能查询一条记录）**   - queryForList()：查询结果将结果集封装为list集合   - query()：查询结果，将结果封装为JavaBean对象     - query的参数：RowMapper       - 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装       - new BeanPropertyRowMapper&lt;类型&gt;(类型.class)   - queryForObject：查询结果，将结果封装为对象     - 一般用于聚合函数的查询</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>servlet相关</title>
      <link href="/2019/07/25/2019/07/servlet%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/25/2019/07/servlet%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类，<strong>实现Servlet接口</strong></p></li><li><p>实现接口中的方法</p></li><li><p>配置Servlet（在web.xml中配置，web-app标签中）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.lifan.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><ol><li>当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的中资源路径</li><li>查找web.xml文件，是否有对应的 <url-parttern>标签体内容</url-parttern></li><li>如果有，则会 找到对应的<servlet-calss>全类名</servlet-calss></li><li>tomact将字节码文件加载进内存，并创建其对象</li><li>调用其方法</li></ol><h2 id="Servlet-中的生命周期"><a href="#Servlet-中的生命周期" class="headerlink" title="Servlet 中的生命周期"></a>Servlet 中的生命周期</h2><ol><li><p>Servlet被创建时执行：执行init方法，只执行一次</p><ul><li><p><strong>Servlet 什么时候被创建？</strong></p><ul><li><p>默认情况下，第一次访问时，Servlet被创建</p></li><li><p>可配置执行Servlet配置的时机</p><ul><li><p>在<servlet>下配置</servlet></p><ul><li><p><strong>第一次被访问时</strong>，创建</p><p><load-on-startup>的值为负数</load-on-startup></p></li><li><p>在<strong>服务器启动时</strong>，创建</p><p><load-on-startup>的值为0或正整数</load-on-startup></p></li></ul></li></ul></li><li><p><strong>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例</strong></p><ul><li>多个用户同时访问时，可能存在线程安全问题</li><li>解决办法：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</li></ul></li></ul></li></ul></li><li><p>提供服务：执行service方法，执行多次</p><ul><li>每次访问Servlet时，Service方法都会被调用一次。</li></ul></li><li><p>被销毁：执行destroy方法，只执行一次 </p><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li><li>只有服务器正常关闭时，才会执行destroy方法。</li><li><strong>destroy方法在Servlet被销毁之前执行</strong>，一般用于释放资源</li></ul></li></ol><h2 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h2><p><strong>支持注解配置。可以不需要web.xml了</strong></p><p>步骤：</p><ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法.</li><li>在类上使用@WebServlet注解，进行配置<ul><li>@WebServlet(“资源路径”)</li></ul></li></ol><h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><ol><li><p>GenericServlet 抽象类（儿子）：将Servlet接口中做了默认空实现，只将service()方法作为抽象</p><ul><li>定义servlet类时，可以继承GenericServlet，实现 service()方法即可</li></ul></li><li><p>HttpServlet 抽象类（孙子）：对 http协议的一种封装，简化操作</p><ul><li>定义类继承HttpServlet</li></ul></li></ol><ul><li>复写doGet/doPost方法</li></ul><h2 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h2><ol><li><p>urlPatterns:Servlet访问路径</p><ul><li><p>一个Servlet可以定义多个访问路径：@WebServlet({“/d4”,”/dd4”}</p></li><li><p>路径定义规则</p><p><strong>/xxx</strong></p><p>/xxx/xxx：多层路径，目录结构</p><p>*.do</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat启动相关问题</title>
      <link href="/2019/07/25/2019/07/Tomcat%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/25/2019/07/Tomcat%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ol><li><p>黑窗口一闪而过：</p><ul><li><p>原因： 没有正确配置JAVA_HOME环境变量</p></li><li><p>解决方案：正确配置JAVA_HOME环境变量</p></li></ul></li><li><p>启动报错：</p><ul><li><p>暴力：找到占用的端口号，并且找到对应的进程，杀死该进程</p><ul><li>netstat -ano</li></ul></li><li><p>温柔：修改自身的端口号 conf/server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8888"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8445"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。- 好处：在访问时，就不用输入端口号</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li><p>直接将项目放到webapps目录下即可。</p><ul><li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。<pre><code>war包会自动解压缩</code></pre></li></ul></li><li><p>配置conf/server.xml文件</p><p>在<host>标签体中配置</host></p><context docbase="D:\hello" path="/hehe"><ul><li>docBase:项目存放的路径</li><li>path：虚拟目录</li></ul></context></li><li><p>在conf\Catalina\localhost创建任意名称的xml文件。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注解相关问题</title>
      <link href="/2019/07/25/2019/07/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/25/2019/07/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="预定义注解"><a href="#预定义注解" class="headerlink" title="预定义注解"></a>预定义注解</h2><ul><li>@Override：检测被该注解标注的方法是否是继承自父类（接口）的</li><li>@Deprecated：该注解标注的内容，表示已过时</li><li>@SuppressWarnings：压制警告<ul><li>一般传递参数@suppressWarnings(“all”)</li></ul></li></ul><h2 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h2><p>本质上就是一个接口，该接口默认继承Annotation接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义了属性，给属性赋值"><a href="#定义了属性，给属性赋值" class="headerlink" title="定义了属性，给属性赋值"></a>定义了属性，给属性赋值</h2><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置</li><li>@Retention：描述注解被保留的阶段</li><li>@Document：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Http相关</title>
      <link href="/2019/07/25/2019/07/Http%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/25/2019/07/Http%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Http特点"><a href="#Http特点" class="headerlink" title="Http特点"></a>Http特点</h2><ol><li>基于TCP/IP的高级协议</li><li>默认端口号:80</li><li>基于请求/响应模型的:一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol><p>历史版本：</p><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接</li></ul><h2 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h2><ol><li><p>请求行</p><p>请求方式  请求url  请求协议/版本</p><ul><li>请求方式<ul><li>GET</li><li>POST</li></ul></li></ul></li><li><p>请求头</p><p>请求头名称 ：请求头值 </p><ul><li>User-Agent：浏览器告诉服务器，我访问你 使用的浏览器版本信息<ul><li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li></ul></li><li>Referer：<a href="http://localhost/login.html" target="_blank" rel="noopener">http://localhost/login.html</a><ul><li>告诉服务器，我(当前请求)从哪里来？</li><li>作用：防盗链、统计工作</li></ul></li></ul></li><li><p>请求空行</p><p>空行（起分隔作用）</p></li><li><p>请求体（正文）</p><ul><li>封装POST请求消息的请求参数的</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Request</title>
      <link href="/2019/07/25/2019/07/Request/"/>
      <url>/2019/07/25/2019/07/Request/</url>
      
        <content type="html"><![CDATA[<h2 id="Request和Response对象原理"><a href="#Request和Response对象原理" class="headerlink" title="Request和Response对象原理"></a>Request和Response对象原理</h2><ol><li>Tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo1的对象</li><li>Tomcat服务器，会创建request和 response对象，request对象中封装请求数据</li><li>Tomcat将request和response两个对象传递给service方法，并且调用service方法</li><li>程序员通过request对象获取请求数据，通过response对象来设置响应消息数据</li><li>服务器再给浏览器做出响应之前，会从response对象中拿程序员设置的响应数据</li></ol><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><ol><li><p>继承体系结构</p><p>ServletRequest（接口）</p><p>​         |  继承</p><p>HttpServletRequest（接口）</p><p>​          | 实现</p><p>org.apache.catalina.connector.RequestFacade@202c2dc1（Tomcat中）</p></li><li><p>获取请求消息</p><ul><li><p><strong>获取请求行数据</strong></p><p>方法：</p><ul><li><p>获取请求方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>获取虚拟目录：/day14</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取Servlet路径：/demo1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletPath</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取Get请求参数：name=zhansan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>获取请求URI</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getRequestURI</span><span class="params">()</span> <span class="comment">// /day14/demo1</span></span></span><br><span class="line"><span class="function">StringBUffer <span class="title">getRequestURL</span><span class="params">()</span> <span class="comment">// http://localhost:8080/day14/demo1</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取协议版本：HTTP/1.1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProtocol</span><span class="params">()</span>  <span class="comment">//父类中</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取客户机的IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getRemoteAddr</span><span class="params">()</span> <span class="comment">//父类中</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>请求头数据</strong></p><p>方法：</p><ul><li><strong>String getHeader(String name)：通过请求头的名称获取请求头的值</strong></li><li><p>Enumeration<string> getHeaderNames()：获取所有请求头名称</string></p></li><li><p><strong>获取请求体数据</strong></p><ul><li><strong>只有POST请求方式，才有请求体</strong>，在请求体中封装了POST请求的请求参数</li><li><p>步骤：</p><ul><li>获取流对象<ul><li><strong>BufferedReader getReader()：获取字符输入流，只能操作字符数据-</strong>ServletInputStream getInputStream()：获取字节输入流，可以操作所有所有类型的数据</li></ul></li><li>再从流对象中拿数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol><ol start="3"><li><p>其他功能</p><ul><li><p><strong>获取请求参数通用方式</strong>（get和post通用）</p><ul><li><strong>String getPrarmeter(String name)：根据请求参数名称获取请求参数值</strong></li><li>String[] getPrarmeterValues(String name)：根据请求参数名称获取请求参数值的数组</li><li>Enumeration<string> getParameterNames()：获取所有请求参数名称</string></li><li>Map&lt;String,String[ ]&gt; getParameterMap()：获取所有参数的map集合</li></ul></li><li><p><strong>请求转发</strong></p><p>步骤 ：</p><ul><li><p>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher (String Path)</p></li><li><p>通过RequestDispatcher 对象调用方法转发：forward(ServletRequest request ,ServletResponse response)</p></li><li><p><strong>特点：</strong></p><ul><li><p>浏览器地址状态栏路径不发生变化</p></li><li><p>只能转发到当前服务器内部资源中</p></li><li><p><strong>转发是一次请求</strong></p></li></ul></li><li><p><strong>共享数据</strong></p><p>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</p><p>方法：</p><ul><li>setAttribute(String name,Object obj)：存储数据</li><li>Object getAttribute(String name)：通过键获取值</li><li>removeAttribute(String name)：通过键移除键值对</li></ul></li></ul></li><li><p>获取ServletContext：</p><p>ServletContext getServletContext()</p></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### 中文乱码问题</span><br><span class="line">    </span><br><span class="line">- get方式：Tomcat 8 已经将中文乱码问题解决</span><br><span class="line">    </span><br><span class="line">- post方式：会乱码</span><br><span class="line">    </span><br><span class="line">  解决：在获取参数前，设置编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="BeanUtils工具类"><a href="#BeanUtils工具类" class="headerlink" title="BeanUtils工具类"></a>BeanUtils工具类</h2><p>   简化数据封装，用于封装JavaBean的</p><ol><li>JavaBean：标准的Java类<ul><li>要求：    </li><li>类必须被public修饰<pre><code>- 必须提供空参的构造器 - 成员变量必须使用private修饰 - 提供公共setter和getter方法</code></pre></li></ul></li><li>功能：封装数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XML笔记</title>
      <link href="/2019/07/24/2019/07/xml%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/24/2019/07/xml%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li>xml文档的后缀名 .xml</li><li>xml第一行必须定义为文档声明</li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li></ol><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><ol><li>文档声明<ul><li>格式：&lt;?xml 属性列表 ?&gt;</li><li>属性列表：<ul><li>version：版本号，必须的属性</li><li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone：是否独立<ul><li>取值：<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ul></li><li>属性：id属性值唯一</li><li>文本：CDATA区：在该区域中的数据会被原样展示<ul><li>格式：&lt; ! [ CATA [ 数据 ] ]&gt;</li></ul></li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>规定xml文档的书写规则</p><ol><li><p>分类：</p><ul><li>DTD：一种简单的约束技术</li><li>Schema：一种复杂的约束技术 </li></ul></li><li><p>DTD：</p><ul><li><p>引入 ：</p><ul><li>内部文档：将约束规则定义在XML文档中（了解）</li><li>外部文档：<ul><li>本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt;</li><li>网络：&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件的位置URL”&gt;</li></ul></li></ul></li><li><p>缺陷：内容不能限定</p></li></ul></li><li><p>Schema：</p><ul><li><p>引入：</p><ul><li><p>填写xml文档的根元素</p></li><li><p>引入xsi前缀.  xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a></p></li><li><p>引入xsd文件命名空间.  xsi:schemaLocation=”<a href="http://www.itcast.cn/xml" target="_blank" rel="noopener">http://www.itcast.cn/xml</a>  student.xsd”</p></li><li><p>为每一个xsd约束声明一个前缀,作为标识  xmlns=”<a href="http://www.itcast.cn/xml&quot;" target="_blank" rel="noopener">http://www.itcast.cn/xml&quot;</a> </p></li></ul></li></ul></li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>操作文档，将文档的数据读取到内存中</p><ul><li>操作XML文档<ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol></li><li>解析XML的方式<ol><li><strong>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树</strong><ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li></ol></li></ul><ol start="2"><li>SAX：逐行读取，基于事件驱动的。<ul><li>优点：不占内存。</li><li>缺点：只能读取，不能增删改</li></ul></li></ol><h2 id="常见的解析器"><a href="#常见的解析器" class="headerlink" title="常见的解析器"></a>常见的解析器</h2><ol><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li><li>PULL：Android操作系统内置的解析器，sax方式的。</li></ol><h3 id="使用Jsoup"><a href="#使用Jsoup" class="headerlink" title="使用Jsoup"></a>使用Jsoup</h3><p>步骤：</p><ol><li>导入jar包</li><li>获取Document对象</li><li>获取对应的标签Element对象</li><li>获取数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsoupDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//2.获取Document对象，根据XML文档</span></span><br><span class="line">        <span class="comment">//2.1获取student.xml的path</span></span><br><span class="line">        String path = JsoupDemo1.class.getClassLoader().getResource(<span class="string">"student.xml"</span>).getPath();</span><br><span class="line">        <span class="comment">//2.2解析XML文档，获取dom树</span></span><br><span class="line">        Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">//3.获取元素对象Elements（可以看成集合）</span></span><br><span class="line">        Elements elements = document.getElementsByTag(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        <span class="comment">//根据索引获取值</span></span><br><span class="line">        Element element = elements.get(<span class="number">0</span>);</span><br><span class="line">        String name = element.text();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><ol><li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p><ul><li>parse：解析html或xml文档，返回Document<ul><li><strong>parse(File in, String charsetName)：解析xml或html文件的。</strong></li><li>parse(String html)：解析xml或html字符串</li><li><strong>parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的</strong></li></ul></li></ul></li><li><p>Document：文档对象。代表内存中的dom树</p><ul><li>获取Element对象<ul><li>getElementById(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag(String tagName)：根据标签名称获取元素对象集</li><li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul></li><li><p>Elements：元素Element对象的集合。可以当做 ArrayList<element>来使用</element></p></li><li><p>Element：元素对象</p><p>① 获取子元素对象</p><p>② 获取属性值</p><ul><li>String attr(String key)：根据属性名称获取属性值</li></ul><p>③ 获取文本内容</p><ul><li>String text()：获取所有字标签纯文本内容</li><li>String html()：获取标签体的所有内容(包括字标签的标签和文本内容)</li></ul></li><li><p>Node：节点对象</p><ul><li>是Document和Element的父类</li></ul></li></ol><h2 id="快捷查询方式"><a href="#快捷查询方式" class="headerlink" title="快捷查询方式"></a>快捷查询方式</h2><ol><li>selector：选择器<ul><li>使用的方法：Elements select(String cssQuery)<ul><li>语法：参考Selector类中定义的语法</li></ul></li></ul></li><li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<ul><li>使用Jsoup的Xpath需要额外导入jar包。<ul><li>JsoupXpath-0.3.2.jar</li></ul></li><li>查询w3cshool参考手册，使用xpath的语法完成查询</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射相关问题</title>
      <link href="/2019/07/22/2019/07/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/22/2019/07/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="三种字节码加载方式"><a href="#三种字节码加载方式" class="headerlink" title="三种字节码加载方式"></a>三种字节码加载方式</h2><ol><li><p>第一阶段：是字节码文件</p><p>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象</p><p>全类名：包名.类名</p><p><strong>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</strong></p></li><li><p>第二个阶段：已经将class加载进内存中</p><p>类名.class：通过类名的属性class获取<br><strong>多用于参数的传递</strong></p></li><li><p>第三阶段：已经有对象</p><p>对象.getClass()：getClass()方法在Object类中定义着</p><p><strong>多用于对象的获取字节码的方式</strong></p></li></ol><h2 id="不带declare和带declare的区别"><a href="#不带declare和带declare的区别" class="headerlink" title="不带declare和带declare的区别"></a>不带declare和带declare的区别</h2><ul><li>不带的只能获取公共成员变量、构造方法和方法</li><li>带的可以或群全部的成员变量、构造方法和方法（需要暴力反射）</li></ul><h2 id="暴力反射"><a href="#暴力反射" class="headerlink" title="暴力反射"></a>暴力反射</h2><p>访问私有成员变量、构造方法和方法都可以使用暴力反射（主要解决私有修饰符访问错误）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定名称的成员变量</span></span><br><span class="line">        Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line">        <span class="comment">//忽略访问权限修饰符的安全检查</span></span><br><span class="line">        d.setAccessible(<span class="keyword">true</span>);  <span class="comment">//暴力反射</span></span><br><span class="line">        Object value2 = d.get(p);</span><br><span class="line">        System.out.println(value2);</span><br></pre></td></tr></table></figure><h2 id="使用空参构造方法创建对象"><a href="#使用空参构造方法创建对象" class="headerlink" title="使用空参构造方法创建对象"></a>使用空参构造方法创建对象</h2><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p><h2 id="getMethods"><a href="#getMethods" class="headerlink" title="getMethods()"></a>getMethods()</h2><p>获取类中所有的方法（是包含Object中的方法）</p><h2 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取Person的Class对象</span></span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line"><span class="comment">//2.获取类名</span></span><br><span class="line">String className = personClass.getName();</span><br><span class="line">System.out.prinln(className);</span><br></pre></td></tr></table></figure><h2 id="手写小框架"><a href="#手写小框架" class="headerlink" title="手写小框架"></a>手写小框架</h2><blockquote><p>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</p></blockquote><ul><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lifan.reflect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            前提：不能改变类的任何代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.在程序中加载读取配置文件</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//1.2.1获取class目录下的一个配置文件</span></span><br><span class="line">        ClassLoader classLoader = ReflectTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"pro.properties"</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取配置文件中定义的数据</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-基础篇</title>
      <link href="/2019/06/24/2019/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2019/06/24/2019/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一、为什么很多编程语言中数组都从0下标开始的"><a href="#一、为什么很多编程语言中数组都从0下标开始的" class="headerlink" title="一、为什么很多编程语言中数组都从0下标开始的"></a>一、为什么很多编程语言中数组都从0下标开始的</h3><blockquote><p>数组（Array）是一种<strong>线性表</strong>数据结构。它用一组<strong>连续的内存空间</strong>，来存储一组<strong>具有相同类型的数据</strong>。</p></blockquote><h4 id="1-如何实现随机访问？"><a href="#1-如何实现随机访问？" class="headerlink" title="1. 如何实现随机访问？"></a>1. 如何实现随机访问？</h4><ul><li><p>当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><p><strong>a[i] address = base_address + i * data_type_size</strong></p><p><strong>base_address</strong>：内存块首地址</p><p><strong>data_type_size</strong>：数组中每个元素的大小（），数组中存储int类型，data_type_size为4个字节</p></li><li><p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1) 。</strong></p></li></ul><h4 id="2-低效的“插入”和“删除”操作"><a href="#2-低效的“插入”和“删除”操作" class="headerlink" title="2. 低效的“插入”和“删除”操作"></a>2. 低效的“插入”和“删除”操作</h4><ul><li><p>如果我们需要将一个数据插入到数组中的<strong>第 k 个位置</strong>。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位；如果在<strong>数组的末尾插入元素</strong>，那就不需要移动数据了，这时的时间复杂度为 O(1) 。但如果在<strong>数组的开头插入元素</strong>，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n) 。</p></li><li><p>如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果<strong>删除数组末尾的数据</strong>，则最好情况时间复杂度为 O(1) ；如果<strong>删除开头的数据</strong>，则最坏情况时间复杂度为 O(n)。</p></li></ul><h4 id="3-警惕数组越界访问问题"><a href="#3-警惕数组越界访问问题" class="headerlink" title="3. 警惕数组越界访问问题"></a>3. 警惕数组越界访问问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>; <span class="comment">// java.lang.ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure><h4 id="4-容器是否能完全代替数组？"><a href="#4-容器是否能完全代替数组？" class="headerlink" title="4. 容器是否能完全代替数组？"></a>4. 容器是否能完全代替数组？</h4><ul><li>ArrayList最大的优势就是可以将很多数组操作的细节封装起来</li><li>支持动态扩容</li><li><strong>在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适</strong></li></ul><h4 id="5-解答"><a href="#5-解答" class="headerlink" title="5. 解答"></a>5. 解答</h4><ul><li><p><strong>公式对比</strong>：</p><p>以0为起始下标：a[k]_address = base_address + k * type_size</p><p>以1位起始下标：a[k]_address = base_address + (k-1)*type_size</p></li><li><p><strong>结论</strong>：数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="一、如何实现LRU缓存淘汰算法？"><a href="#一、如何实现LRU缓存淘汰算法？" class="headerlink" title="一、如何实现LRU缓存淘汰算法？"></a>一、如何实现LRU缓存淘汰算法？</h3><blockquote><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：<strong>先进先出策略 FIFO</strong> （ First In ， First Out ）、<strong>最少使用策略 LFU</strong> （ Least Frequently Used ）、<strong>最近最少使用策略 LRU</strong> （ Least Recently Used ）。</p></blockquote><h4 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h4><p>我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，<strong>头结点用来记录链表的基地址</strong>。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是<strong>指向一个空地址NULL</strong>，表示这是链表上最后一个结点</p><ul><li><strong>查找</strong>：链表要想随机访问第 k 个元素，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</li><li><strong>插入和删除</strong></li></ul><p><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1g4srcdkavej20qe0efq3s.jpg" alt="插入和删除"></p><h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2. 循环链表"></a>2. 循环链表</h4><ul><li><strong>循环链表的尾结点指针是指向链表的头结点</strong>。</li><li><strong>循环链表的优点是从链尾到链头比较方便</strong>。</li><li>当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。</li></ul><h4 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3. 双向链表"></a>3. 双向链表</h4><ul><li><p>向链表，顾名思义，<strong>它支持两个方向</strong>，每个结点不止有一个后继指针 next 指向后面的结点，<strong>还有一个前驱指针 prev 指向前面的结点</strong>。</p><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1g4srkgt6jpj20pp08uwez.jpg" alt="双向链表"></p></li><li><p><strong>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。</strong></p></li></ul><h4 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4. 双向循环链表"></a>4. 双向循环链表</h4><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1g4srxt9fa7j20qy0bk756.jpg" alt="双向循环链表"></p><h4 id="5-数组和链表的最大区别"><a href="#5-数组和链表的最大区别" class="headerlink" title="5. 数组和链表的最大区别"></a>5. 数组和链表的最大区别</h4><p><strong>数组的缺点是大小固定</strong>，一经声明就要占用整块<strong>连续内存空间</strong>。如果声明的<strong>数组过大</strong>，系统可能没有足够的连续内存空间分配给它，导致 “ <strong>内存不足</strong>（ out of memory ） ” 。如果声明的<strong>数组过小</strong>，则可能<strong>出现不够用的情况</strong>。这时只能再申请一个更大的内存空间，把原数组拷贝进去，<strong>非常费时</strong>。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><h4 id="6-解答"><a href="#6-解答" class="headerlink" title="6. 解答"></a>6. 解答</h4><p>我们维护一个<strong>有序单链表</strong>，<strong>越靠近链表尾部的结点是越早之前访问的</strong>。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ul><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul></li></ul><h4 id="7-设计思想"><a href="#7-设计思想" class="headerlink" title="7. 设计思想"></a>7. 设计思想</h4><p>时空替换思想： “ 用空间换时间 ”  与 “ 用时间换空间 ”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-入门篇</title>
      <link href="/2019/06/23/2019/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2019/06/23/2019/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="10个数据结构"><a href="#10个数据结构" class="headerlink" title="10个数据结构"></a>10个数据结构</h2><blockquote><p>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</p></blockquote><h2 id="10个算法"><a href="#10个算法" class="headerlink" title="10个算法"></a>10个算法</h2><blockquote><p>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回朔算法、动态规划、字符串匹配算法</p></blockquote><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="一、如何分析算法的执行效率和资源消耗"><a href="#一、如何分析算法的执行效率和资源消耗" class="headerlink" title="一、如何分析算法的执行效率和资源消耗"></a>一、如何分析算法的执行效率和资源消耗</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; ++i)&#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第 2 、 3 行代码分别需要 1 个 unit_time 的执行时间，第 4 、 5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(O) = O(f(n))</span><br></pre></td></tr></table></figure><p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。<br>当 n 很大时，你可以把它想象成 10000 、 100000 。而公式中的<strong>低阶、常量、系数</strong>三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。</p><h4 id="2-分析时间复杂度3个方法"><a href="#2-分析时间复杂度3个方法" class="headerlink" title="2. 分析时间复杂度3个方法"></a>2. 分析时间复杂度3个方法</h4><ul><li><p>只关注循环执行次数最多的一段代码</p></li><li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p><p>如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))</p></li><li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><p>如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</p></li></ul><h4 id="3-几种常见时间复杂度实例分析"><a href="#3-几种常见时间复杂度实例分析" class="headerlink" title="3. 几种常见时间复杂度实例分析"></a>3. 几种常见时间复杂度实例分析</h4><blockquote><p>常量阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n^2)…</p><p>指数阶O(2^n)、阶乘阶O(n!)</p></blockquote><ul><li><p><strong>O(1)</strong></p><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p></li><li><p><strong>O(logn)、O(nlogn)</strong></p><p>2^x =n –&gt; x = log2n</p><p>对数之间是可以互相转换的，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn) 。</p><p>将O(logn)循环n次就是O(nlogn)，比如，归并排序、快速排序的时间复杂度都是 O(nlogn) 。</p></li><li><p><strong>O(m+n)、O(m*n)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">sum_1 = sum_1 + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">sum_2 = sum_2 + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出， m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n) 。</p></li></ul><hr><hr><h4 id="4-空间复杂度分析"><a href="#4-空间复杂度分析" class="headerlink" title="4. 空间复杂度分析"></a>4. 空间复杂度分析</h4><p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p><h4 id="5-常见空间复杂度"><a href="#5-常见空间复杂度" class="headerlink" title="5. 常见空间复杂度"></a>5. 常见空间复杂度</h4><blockquote><p>O(1)、O(n)、O(n^2)</p></blockquote><h3 id="二、浅析最好、最坏、平均、均摊时间复杂度"><a href="#二、浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="二、浅析最好、最坏、平均、均摊时间复杂度"></a>二、浅析最好、最坏、平均、均摊时间复杂度</h3><ul><li><strong>最好情况时间复杂度</strong>就是，在最理想的情况下，执行这段代码的时间复杂度。</li><li><strong>最坏情况时间复杂度</strong>就是，在最糟糕的情况下，执行这段代码的时间复杂度。</li><li><strong>平均时间复杂度</strong>：用代码在所有情况下执行的次数的加权平均值表示。</li><li><strong>均摊时间复杂度</strong>：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li><li>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度</li></ul><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Collection、泛型</title>
      <link href="/2019/01/29/2019/01/%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/29/2019/01/%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有什么区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="https://ws2.sinaimg.cn/large/80ceacb8ly1fzokmrh2u3j211s0eu3zx.jpg" alt="image"></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建集合对象 </span></span><br><span class="line">    <span class="comment">// 使用多态形式</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 使用方法</span></span><br><span class="line">    <span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    coll.add(<span class="string">"小李广"</span>);</span><br><span class="line">    coll.add(<span class="string">"扫地僧"</span>);</span><br><span class="line">    coll.add(<span class="string">"石破天"</span>);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    System.out.println(<span class="string">"判断  扫地僧 是否在集合中"</span>+coll.contains(<span class="string">"扫地僧"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    System.out.println(<span class="string">"删除石破天："</span>+coll.remove(<span class="string">"石破天"</span>));</span><br><span class="line">    System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    Object[] objects = coll.toArray();</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">System.out.println(objects[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void  clear() 清空集合</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line"><span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><p><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p></li><li><p><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p></li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>Iterator接口使用步骤：</p><ol><li>Collection接口中有一个方法，<code>iterator()</code>，这个方法返回的就是迭代器的实现类对象</li><li>使用Iterator接口中的方法hashNext判断还有没有下一个元素</li><li>使用Iterator接口中的方法next取出集合中的下一个元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1fzolk7k3ckj211s0eumyf.jpg" alt="image"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，<strong>不要在遍历的过程中对集合元素进行增删操作</strong>。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       <span class="comment">//使用增强for遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    <span class="comment">//使用增强for遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">"abc"</span>);</span><br><span class="line">coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">"大胡子登登"</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<object> list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<string>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</string></p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<string>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</string></p></li></ul><ul><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">"♥"</span>);</span><br><span class="line">        colors.add(<span class="string">"♦"</span>);</span><br><span class="line">        colors.add(<span class="string">"♠"</span>);</span><br><span class="line">        colors.add(<span class="string">"♣"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">"J"</span>);</span><br><span class="line">        numbers.add(<span class="string">"Q"</span>);</span><br><span class="line">        numbers.add(<span class="string">"K"</span>);</span><br><span class="line">        numbers.add(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">"小☺"</span>);</span><br><span class="line">        pokerBox.add(<span class="string">"大☠"</span>);  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">"令狐冲："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"田伯光："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"绿竹翁："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"底牌："</span>+dipai);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象04</title>
      <link href="/2018/08/27/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104/"/>
      <url>/2018/08/27/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><blockquote><p>由于参数类型不同而导致执行效果各异的现象就是多态。</p></blockquote><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><blockquote><p>在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口 Animal</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;        <span class="comment">//定义抽象shout()方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Cat类实现Animal接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现sout()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Dog类实现Animal接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现shout()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal an1 = <span class="keyword">new</span> Cat();   <span class="comment">//创建Cat对象，使用Animal类型的变量an1引用</span></span><br><span class="line">        Animal an2 = <span class="keyword">new</span> Dog();   <span class="comment">//创建Dog对象，使用Animal类型的变量an2引用</span></span><br><span class="line">        animalShout(an1);         <span class="comment">//调用animalShout()方法，将an1作为参数传入</span></span><br><span class="line">        animalShout(an2);         <span class="comment">//调用animalShout()方法，将an2作为参数传入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义静态的animalShout()方法，接受一个Animal类型的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalShout</span><span class="params">(Animal an)</span></span>&#123;</span><br><span class="line">        an.shout();               <span class="comment">//调用实际参数的shout()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h2><blockquote><p>当子类对象当作父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类中的某些方法。</p></blockquote><ul><li>Java 提供了一个关键字instanceof,它可以判断一个对象是否为某个类（或接口）的实例或者子类实例。</li></ul><blockquote><p>对象（或者对象引用变量） instanceof 类（或接口）</p></blockquote><hr><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><ul><li>final 修饰的变量（成员变量和局部变量）是常量，只能赋值一次。</li><li>final 修饰的方法不能被子类重写。</li><li>final 修饰的类不能被继承。</li></ul><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ul><li>静态变量</li></ul><blockquote><p>在定义一个类时，只是在描述某类事物的特征和行为，并没有产生具体的数据。只有通过new关键字创建该类的实例对象后，系统才会为每个对象分配空间，存储各自数据。某些特定的数据在内存中只有一份，而且能够被一个类的所有实例对象所共享。</p></blockquote><p><strong>在Java类中，可以使用static 关键字来修饰成员变量，该变量称作静态变量。静态变量被所有实例共享，可以使用“类名.变量名”的形式来访问或赋值。</strong></p><p><strong>注：static 关键字只能用于修饰成员变量，不能用于修饰局部变量。</strong></p><ul><li>静态方法</li></ul><blockquote><p>在不创建对象的情况下就可以调用某个方法，也可以说是使该方法不必和对象绑在一起。只需在类中定义的方法前加上static关键字即可，这种方法为静态方法。静态方法可以使用“类名.方法名”的 方式来访问。</p></blockquote><p><strong>注：在一个静态方法中只能访问用 static 修饰的成员，原因在于没有被 static 修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</strong></p><ul><li>静态代码块</li></ul><blockquote><p>在Java中，使用一对大括号包围起来的若干行代码被称为一个代码块，用static 关键字修饰的代码块称为静态代码块。</p></blockquote><p><strong>当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次。</strong></p><ul><li>单例模式</li></ul><blockquote><p>单例模式是Java中的一种设计模式，它是指在设计一个类时，需要保证在整个程序运行期间针对该类只存在一个实例对象，就好像我们生存的世界只有一个月亮。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="comment">//自己创建一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single INSTANCE = <span class="keyword">new</span> Single(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;                   <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;  <span class="comment">//提供返回该对象的静态方法</span></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类的构造方法使用 private 修饰，声明为私有，这样就不能在类的外部使用new关键字来创建实例对象了。</li><li>在类的内部创建一个该类的实例对象，并使用静态变量INSTANCE引用该对象，由于变量应该禁止外界直接访问，因此使用private修饰，声明为私有成员。</li><li>为了让类的外部能够获得类的实例对象，需要定义一个静态方法 getInstance(),用于返回该类实例INSTANCE。由于方法是静态的，外界可以通过：类名.方法名的方式来访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象03</title>
      <link href="/2018/08/26/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103/"/>
      <url>/2018/08/26/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承的实现extends"><a href="#继承的实现extends" class="headerlink" title="继承的实现extends"></a>继承的实现extends</h2><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1fun9snri09j208504nt8y.jpg" alt="image"></p><blockquote><p>在 Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。</p></blockquote><ul><li>在程序中，如果想<strong>声明一个类继承另一个类，需要使用 extends 关键字。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个 Animal 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    String name;               <span class="comment">//定义name属性</span></span><br><span class="line">    <span class="comment">//定义动物叫的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物发出叫声"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义 Dog 类继承Animal 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个打印 name 的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();           <span class="comment">//创建一个Dog类的实例对象</span></span><br><span class="line">        dog.name=<span class="string">"沙皮狗"</span>；             <span class="comment">//为Dog类的 name 属性进行赋值</span></span><br><span class="line">        dog.printName()；              <span class="comment">//为Dog类的 getInfo()方法</span></span><br><span class="line">        dog.shout();                  <span class="comment">//调用Dog类继承来的 shout()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>① 在Java中，类只支持单继承，不允许多重继承，也就是一个类只能拥有一个直接父类。</strong></p><p><strong>② 多个类可以继承一个父类。</strong></p><p><strong>③在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如 C类继承自 B类，而B类又可以去继承 A类，这时，C类也可以称作 A类的子类。</strong></p><p><strong>④在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。</strong></p><hr><h2 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h2><blockquote><p>在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p></blockquote><ul><li>在子类中重写的方法需要和父类被重写的方法具有<strong>相同的方法名、参数列表以及返回值类型</strong>。</li><li>子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限。如父类中的方法是public 的，子类的方法就不能是 private 的。</li></ul><hr><h2 id="抽象类-abstract-class"><a href="#抽象类-abstract-class" class="headerlink" title="抽象类 abstract class"></a>抽象类 abstract class</h2><blockquote><p>当定义一个类时，常常需要定义一些方法来描述该类的行为特征，但有时这些方法实现的方式是无法确定的。例如 Animal 类，shout()方法用于表示动物的叫声，但针对不同的动物，叫声也是不同的，因此在 shout() 方法中无法准确描述动物的叫声。针对这种情况，Java允许在定义方法时不写方法体，<strong>不包括方法体的方法为抽象方法，抽象方法必须使用 abstract 关键字来修饰。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;         <span class="comment">//定义抽象方法 shout()</span></span><br></pre></td></tr></table></figure><blockquote><p>当一个类中包含了抽象方法，该类必须使用 abstract 关键字来修饰，使用 abstract 关键字修饰的类为抽象类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义抽象类 Animal</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义抽象方法 shout()</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>① 包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需使用 abstract 关键字来修饰即可。</strong></p><p><strong>② 抽象类是不可以被实例化的，因为抽象类中可能包含抽象方法，抽象方法没有方法体，不可以被调用。</strong></p><p><strong>③ 如果想调用抽象类中定义的方法，需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义抽象类 Animal</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义抽象方法 shout()</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Dog类继承抽象类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法 shout()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();   <span class="comment">//创建Dog类的实例对象</span></span><br><span class="line">        dog.shout();           <span class="comment">//调用dog对象实现的shout()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>如果一个抽象类中的所有方法都是抽象的，则可以将这个类用另外一种方式来定义，叫接口。</p></blockquote><ul><li>在定义接口时，需要使用interface关键字来声明。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ID=<span class="number">1</span>;      <span class="comment">//定义全局常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>; <span class="comment">//定义抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在接口中定义的方法和变量都包含一些默认修饰符。接口中定义的方法默认使用“public abstarct”来修饰，即抽象方法。接口中的变量默认使用“public static fianl”来修饰，即全局常量。</li><li>由于接口中的方法都是抽象方法，因此不能通过实例化对象的方式来调用接口中的方法。这就需要定义一个类，并使用 implements 关键字实现接口中的所有方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了Animal接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ID=<span class="number">1</span>;      <span class="comment">//定义全局常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>; <span class="comment">//定义抽象方法 breathe()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dog类实现了Animal接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现 breathe()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗在呼吸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现 run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(); <span class="comment">//创建Dog类的实例对象</span></span><br><span class="line">        dog.breathe();     <span class="comment">//调用Dog类的breathe()方法</span></span><br><span class="line">        dog.run();        <span class="comment">//调用Dog类的run()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在程序中，还可以定义一个接口使用 extends 关键字去继承另一个接口。</li></ul><h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><ul><li>接口中的方法都是抽象的，不能实例化对象。</li><li>当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。</li><li>一个类通过 implements 关键字实现接口时，可以实现多个接口，被实现的多个接口之间要用逗号隔开。</li><li>一个接口可以通过 extends 关键字继承多个接口，接口之间用逗号隔开。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Running</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flying</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eating</span> <span class="keyword">extends</span> <span class="title">Running</span>,<span class="title">Flying</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个类在继承另一个类的同时还可以实现接口，此时，extends 关键字必须位于 implements 关键字之前。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canidae</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123; <span class="comment">//先继承后实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象02</title>
      <link href="/2018/08/23/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A102/"/>
      <url>/2018/08/23/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A102/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><blockquote><p>在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类被称作<strong>成员内部类</strong>。<strong>在成员内部类中可以访问外部类的所有成员。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">4</span>; <span class="comment">//定义类的成员变量</span></span><br><span class="line">    <span class="comment">//下面的代码定义了一个成员方法，方法中访问内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的代码定义了一个成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//在成员内部类的方法中访问外部类的成员变量</span></span><br><span class="line">            System.out.println(<span class="string">"num = "</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer; <span class="comment">//创建外部类对象</span></span><br><span class="line">        outer.test();            <span class="comment">//调用test()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想通过外部类去访问内部类，则需要通过外部类对象去创建内部类对象。</p><blockquote><p>外部类名<strong>.</strong>内部类名 变量名 = new 外部类名()<strong>.</strong>new 内部类名();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outuer().new Inner();<span class="comment">//创建内部类对象</span></span><br><span class="line">        inner.show();                                <span class="comment">//调用 test() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：如果内部类被声明为私有，外界将无法访问。</strong></p><hr><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>可以使用 static 关键字来修饰一个成员内部类，该内部类被称作静态内部类。它可以在不创建外部类对象的情况下被实例化。</p></blockquote><blockquote><p>外部类名<strong>.</strong>内部类名 变量名 = new 外部类名<strong>.</strong>内部类名();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//下面的代码定义了一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"num = "</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();<span class="comment">//创建内部类对象</span></span><br><span class="line">        inner.show();                         <span class="comment">//调用内部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：① 在静态内部类中只能访问外部类的静态成员。<br>② 在静态内部类中可以定义静态的成员，而在非静态的内部类中不允许定义静态的成员。</strong></p><hr><h2 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h2><blockquote><p>方法内部类是指在成员方法中定义的类，它<strong>只能在当前方法中被使用</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">4</span>;                         <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//下面是方法中定义的内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"num = "</span>+num);<span class="comment">//访问外部类成员</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();                   <span class="comment">//创建内部类对象</span></span><br><span class="line">        in.show();                                <span class="comment">//调用内部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();               <span class="comment">//创建外部类对象</span></span><br><span class="line">        outer.test();                            <span class="comment">//调用 test() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><blockquote><p>匿名内部类是实现接口的一种简便写法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) 或 父接口()&#123;</span><br><span class="line">    <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象01</title>
      <link href="/2018/08/08/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A101/"/>
      <url>/2018/08/08/2018/08/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A101/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向对象特点：封装性、继承性、多态性</p></blockquote><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>类是对某一类事物的抽象描述，它用于描述一组对象的共同特征和行为。</li><li>对象用于表示现实中该类事物的个体。</li><li>类中可以定义<strong>成员变量</strong>和<strong>成员方法</strong>，其中成员变量用于描述对象的特征，也被称作属性。成员方法用于描述对象的行为，可简称方法。</li><li>定义在类中的变量称为<strong>成员变量</strong>，定义方法在方法中的变量称为<strong>局部变量</strong>。</li></ul><h2 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h2><ul><li><p>在 Java 程序中可以使用 <strong>new 关键字</strong>来创建对象。</p><blockquote><p>类名 对象名称 = new 类名 ( ) ;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;   <span class="comment">//类中定义的变量被称作成员变量</span></span><br><span class="line">    <span class="comment">//定义speak()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">60</span>;   <span class="comment">//方法内部定义的变量被称作局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"大家好，我今年"</span>+age+<span class="string">"岁!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <img src="https://ws2.sinaimg.cn/large/80ceacb8ly1fug2j0xm9kj20ek08d3z7.jpg" alt="image"></p><ul><li><p>通过对象的引用来访问对象所有的成员。</p><blockquote><p>对象引用 <strong>.</strong> 对象成员</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();  <span class="comment">//创建第一个Person对象</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();  <span class="comment">//创建第二个Person对象</span></span><br><span class="line">        p1.age = <span class="number">18</span>;               <span class="comment">//为age属性赋值</span></span><br><span class="line">        p1.speak();                <span class="comment">//调用对象方法</span></span><br><span class="line">        p2.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/80ceacb8ly1fug2vno33jj20cs09gjs8.jpg" alt="image"></p></li><li><p>Java虚拟机会自动为成员变量初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值。</p><p><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1fug3bqi3kaj20tg07lgn0.jpg" alt="image"></p></li><li><p><strong>当没有任何变量引用这个对象时，它将成为垃圾对象，不能再被实现。</strong></p></li></ul><h2 id="类成员的封装"><a href="#类成员的封装" class="headerlink" title="类成员的封装"></a>类成员的封装</h2><ul><li>所谓类的封装是指在定义一个类时，将类中的<strong>属性私有化</strong>，即使用 <strong>private 关键字</strong>来修饰。</li><li>私有属性只能在它所在类中被访问。</li><li>为了能让外界访问私有属性，需要提供一些使用 public 修饰的公有方法，其中包括用于获取属性值的 getXxx() 方法和设置属性值的 setXxx() 方法。 </li></ul><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在一个类中定义的方法如果同时满足以下三个条件，该方法称为构造方法：</p><ol><li>方法名与类名相同。</li><li>在方法名的前面没有返回值类型的声明。</li><li>在方法中不能使用 return 语句返回一个值。</li></ol><ul><li><strong>new 语句不仅会实例化类对象，还会调用类中的构造方法。</strong></li><li>在一个类中除了定义无参的构造方法，还可以定义有参的构造方法，通过有参的构造方法就可以实现对属性的赋值。</li></ul><h2 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h2><ul><li><p>与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个<strong>构造方法的参数类型或个数不同</strong>即可。</p></li><li><p><strong>注：</strong></p><p><strong>1.  在Java中的每个类都至少有一个构造方法，如果一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么也不做。</strong></p><p><strong>2. 构造方法不用 private 修饰 ，通常用 public 来修饰</strong>。</p></li></ul><h2 id="this-关键字的使用"><a href="#this-关键字的使用" class="headerlink" title="this 关键字的使用"></a>this 关键字的使用</h2><ul><li><p>this 关键字在程序中的三种常见用法：</p><ol><li><p>通过 this 关键字可以明确地去访问一个类的成员变量，解决与局部变量名称冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 this 关键字调用成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMouth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.openMonth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法是在实例化对象时被Java虚拟机自动调用的，在程序中不能像调用其他方法一样去掉用构造方法，但可以在一个构造方法中使用“ <strong>this([参数1，参数2…])</strong>”的形式来调用其他的构造方法。</p><ul><li><p>只能在构造方法中使用 this 调用其他构造方法，不能在成员方法中使用。</p></li><li><p>在构造方法中，使用 this 调用构造方法的语句必须位于第一行，且只能出现一次。</p></li><li><p>不能在一个类的两个构造方法中使用 this 互相调用。</p></li></ul></li></ol></li></ul><h2 id="super-关键字的使用"><a href="#super-关键字的使用" class="headerlink" title="super 关键字的使用"></a>super 关键字的使用</h2><ul><li><p>问题：当子类重写父类的方法后，子类对象无法访问父类被重写的方法。</p><p>解决：Java 提供一个 super 关键字用于访问父类的成员。</p></li><li><p>使用 super 关键字调用父类的成员变量和成员方法。</p><blockquote><p>super.成员变量</p><p>super.成员方法([参数1，参数2…])</p></blockquote></li><li><p>使用 super 关键字调用父类的构造方法。</p><blockquote><p>super([参数1，参数2…])</p></blockquote></li><li><p><strong>注意：</strong></p><p><strong>1. 通过 super 调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。</strong></p><p><strong>2. 在定义一个类时，如果没有特殊需求，尽量在类中定义一个无参的构造方法，避免被继承时出现错误。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言基础05</title>
      <link href="/2018/08/05/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8005/"/>
      <url>/2018/08/05/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8005/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><blockquote><p>在程序运行的过程中，会发生各种非正常状况，比如程序运行时磁盘空间不足，网络连接中断，被装载的类不存在。针对这种情况，在Java语言中，引入了异常，以异常类的形式对这些非正常情况进行封装，通过异常处理机制对程序运行时发生的各种问题进行处理。</p></blockquote><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1fu5y1awhtnj20ex07rgmd.jpg" alt="image"></p><blockquote><p>Throwable 有两个直接子类Error 和 Exception，其中Error代表程序中产生的错误，Exception代表程序中产生的异常。</p></blockquote><ul><li><p>Error 类称为错误类，它表示Java 运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。</p></li><li><p>Exception 类称为异常类，它表示程序本身可以处理的错误，在开发Java程序中进行的异常处理，都是针对Exception类及其子类。在Exception 类的众多子类中有一个特殊的<strong>RuntimeException类，该类及其子类用于表示运行时异常</strong>，除了此类，Exception 类下所有其他的子类都用于表示编译时异常。</p></li><li><p>Throwable 类中的常用方法</p><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1fu5y9wks7nj20m103rq3u.jpg" alt="image"></p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>try … catch</p><blockquote><p>Java 中提供一种对异常进行处理的方式——异常捕获</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionType(Exception 类及其子类) e)&#123;</span><br><span class="line">    <span class="comment">//对ExceptionType的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在try 代码块中编写可能发生异常的Java 语句，catch 代码块中编写针对异常进行处理的代码。当try 代码块的程序发生了异常，系统会将这个异常的信息封装成一个异常对象，并将这个对象传递给catch代码块。catch 代码块需要一个参数指明它所能够接受的异常类型，这个参数的类型必须是Exception类或其子类。</p><hr></li><li><p>finally</p><blockquote><p>在程序中，有时候我们希望语句无论程序是否发生异常都要执行，这个时候在try … catch语句后，加一个 finally 代码块。</p></blockquote><p><strong>注：</strong></p><p><strong>不论程序是否发生异常还是使用 return 语句结束，finally语中的语句都会执行。用途：例如释放系统资源。</strong></p><p><strong>在try … catch中如果执行了System.exit(0)语句，finally中的语句就不会执行。System.exit(0)表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行。</strong></p><hr></li><li><p>throws</p><blockquote><p>如果去调用一个别人写的方法时，是否知道别人写的方法是否会异常呢？这就很难做出判断。针对这种情况，Java中允许在方法的后面使用 throws 关键字对外声明该方法有可能发生的异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则无法编译通过。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名([参数<span class="number">1</span>，参数<span class="number">2</span>...])<span class="keyword">throws</span> ExceptionType1[,ExceptionType2...]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述语法格式中可以看出，throws关键字需要写在方法声明的后面，throws后面需要声方法中发生异常的类型，通常将这种做法称为<strong>方法声明抛一个异常。</strong></p></li></ul><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><ol><li><p>编译时异常</p><p>在Java中，Exception 类除了RuntimeException 类及其子类都是编译时异常。编译时异常的特点是Java 编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。</p><p><strong>处理编译时期的异常的两种方式：</strong></p><ul><li>使用 try … catch 语句对异常进行捕获。</li><li>使用 throws 关键字声明抛出异常，调用者对其处理。</li></ul><hr></li><li><p>运行时异常</p><p>RuntimeException 类及其子类都是运行时异常。运行时异常特点是Java编译器不会对其检查，也就是说，当程序中出现这类异常时，即使没有使用 try … catch 语句捕获或使用 throws 关键字声明抛出，程序也能编译通过，运行时异常一般是由程序中的逻辑错误引起的，在程序运行时无法恢复。</p></li></ol><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><blockquote><p>Java允许用户自定义异常，但自定义的异常类必须继承自 Exception 或其子类。</p></blockquote>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的代码是自定义一个异常类继承自 Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();           <span class="comment">//调用 Exception 无参的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">//调用 Exception 有参的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，如果没有特殊的要求，自定义的异常类只需继承 Exception 类，在构造方法中使用 super() 语句调用Exception 的构造方法即可。</p><p>使用自定义异常使用 throw 关键字，throw 关键字用于在方法中抛出异常的实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> Exception异常对象</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言基础04</title>
      <link href="/2018/08/03/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004/"/>
      <url>/2018/08/03/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004/</url>
      
        <content type="html"><![CDATA[<h1 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h1><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><ul><li><p>方法定义</p><p>在Java中，声明一个方法的具体语法格式如下：</p><blockquote><p>修饰符 返回值类型 方法名([参数类型 参数名1，参数类型 参数名2，…]){</p><pre><code>执行语句...return 返回值；</code></pre><p>}</p></blockquote><p>方法的返回值必须为方法声明的返回值类型，如果方法中没有返回值，返回值类型要声明为void，此时，方法中return语句可以省略。</p></li><li><p>方法调用</p><blockquote><p>方法名（参数列表）</p></blockquote></li><li><p>参数的传递</p><ul><li><p>值传递</p><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，<strong>此时内存中存在两个相等的基本类型，即实际参数和形式参数</strong>，<strong>后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</strong>。 </p></li><li><p>引用传递</p><p>也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址； <strong>在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象</strong>。 </p></li></ul></li><li><p>变量作用域</p><ul><li><p>全局变量</p><p>定义：又称“外部变量”，它不属于哪个方法，作用域从定义的地址开始到源文件结束。</p></li><li><p>局部变量</p><p>定义：在方法内定义的变量称为“局部变量”或“临时变量”，方法结束后局部变量占用的内存将被释放。</p></li></ul></li></ul><h2 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h2><blockquote><p>Java 允许在一个程序中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。<strong>注：方法的重载与返回值类型无关。</strong></p></blockquote><h2 id="方法的递归"><a href="#方法的递归" class="headerlink" title="方法的递归"></a>方法的递归</h2><blockquote><p>方法的递归是指在一个方法的内部调用自身的过程，<strong>递归必须要有结束条件</strong>，不然就会陷入无限递归的状态，永远无法结束调用。</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>数组是一种数据结构，用来存储<strong>同一类型值的</strong>集合。通过整型下标（下标从0开始）可以访问数组中的每一个值。</p></blockquote><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><ol><li><p><strong>动态初始化</strong></p><p>在声明数组变量时，需要指出数组类型（数据元素类型后紧跟[]）和数组变量名字。</p><blockquote><p>int[] a;</p></blockquote><p>上面这条语句只声明了变量a，并没有将a初始化一个真正的数组。应该使用new运算符创建数组。</p><blockquote><p>int[] a = new int[100];</p></blockquote><p>这条语句创建了一个可以存储100个整型的数组。数组长度不要求是常量：new int[n]会创建一个长度为n的数组。</p></li><li><p><strong>静态初始化</strong></p><blockquote><p>int[] a = {2,3,8,5,4,6};</p></blockquote><p>这种语法形式可以在不创建新变量的情况下重新初始化一个数组。</p></li></ol><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    a[i] = i; <span class="comment">//fills the array with numbers 0 to 99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个数字数组时，所有元素都初始化为0。</li><li>boolean 数组的元素会初始化为false。</li><li>对象数组的元素则初始化为一个特殊值null，这表示这些元素还未存放对象。</li></ul><h2 id="数组元素个数"><a href="#数组元素个数" class="headerlink" title="数组元素个数"></a>数组元素个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取数组元素个数使用array.length。</li><li><strong>一旦创建了数组，就不能再改变它的大小。</strong></li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ol><li><p>数组声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a;</span><br></pre></td></tr></table></figure></li><li><p>数组初始化</p><ul><li><p>静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure></li><li><p>动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言基础03</title>
      <link href="/2018/08/01/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003/"/>
      <url>/2018/08/01/2018/08/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>在Java中，使用算术运算符+、-、*、/表示加减乘除运算。当参与/运算的两个操作数是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作用%表示。</p><p><strong>注：</strong>整数被0除将会产生一个异常，而浮点数被0除将会得到一个无穷大或NaN结果。</p></blockquote><ul><li><p>二元运算符</p><blockquote><p>x += 4;//等价于 x = x + 4;</p></blockquote></li><li><p>自增运算符与自减运算符</p><ol><li><p>前缀方式：++n</p></li><li><p>后缀方式：n++</p><p>区别：前缀方式先对变量进行 +1 运算；后缀方式则先使用变量原来的值，在对变量进行 +1 运算。</p></li></ol></li><li><p>关系运算符与boolean运算符</p><ol><li><p>使用两个等号 == 检测是否相等。</p><blockquote><p>3 == 7 //值为false</p></blockquote></li><li><p>使用 != 检测是否不相等。</p><blockquote><p>3! = 7 //值为true</p></blockquote></li><li><p>经常使用的还有&lt;(小于)、&gt;（大于）、&lt;=（小于等于）和 &gt;=（大于等于）。</p></li><li><p>用&amp;&amp;表示逻辑 “与” 、用 ||表示逻辑 “或”。</p><blockquote><p>如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p><p>expression1 &amp;&amp; expression2</p><p>expression1 || expression2</p></blockquote></li><li><p>三元操作符 ?:</p><blockquote><p>condition ? expression1 : expression2</p><p>当条件condition 为 true 时计算第1个表达，否则计算第2个表达。例：</p><p>x&lt;y ? x : y //返回 x 和 y 中较小的那个值。</p></blockquote></li></ol></li><li><p>位运算符</p><blockquote><p>&amp;(“与”)、|（“或”）、^（“异或”）、~（“非”）</p></blockquote></li></ul><hr><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><blockquote><p>Java 中4种访问修饰符public / protected / default(friendly) / private</p></blockquote><ol><li>对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。 </li><li>对于protected修饰符，它主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。 </li><li>对于default来说，有点的时候也成为friendly（友员），它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。 </li><li>对于private来说，它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。 </li></ol><ul><li>下表为Java访问控制符的含义和使用情况 :</li></ul><p><img src="https://ws4.sinaimg.cn/large/80ceacb8ly1ftvokyhvx5j20jx05laa4.jpg" alt="image"></p><p>  区别：</p><p>  (1) public:可以被所有其他类所访问。</p><p>  (2) private:只能被自己修改。</p><p>  (3) protected:自身，子类及同一个包中类可以访问。</p><p>  (4) default(默认):同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</p><p>  <strong>注意</strong>：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。 </p><hr><h1 id="基本结构语句"><a href="#基本结构语句" class="headerlink" title="基本结构语句"></a>基本结构语句</h1><ul><li><p>顺序结构语句</p></li><li><p>选择结构语句</p><ul><li><p>if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statement1.</span><br><span class="line">        statement2</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    statement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重选择：switch 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>：</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case 标签可以是：</p><ul><li>类型为 char、byte、short 或 int（或其包装类）的常量表达式。</li><li>枚举常量</li><li>字符串字面量</li></ul></li></ul></li><li><p>循环结构语句</p><ul><li><p>while循环</p><p>当条件为true时，while循环执行一条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while 循环语句首先检测循环条件。因此，循环体中的代码有可能不被执行。</p></li><li><p>do while循环<br>如果希望循环体至少执行一次，则应该将检测条件放在最后。使用do/while循环语句执行这种操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">while</span>()</span><br></pre></td></tr></table></figure><p>这种循环语句先执行语句，再检测循环条件；然后重复语句，再检测循环条件，以此类推。</p></li><li><p>for循环</p><p>for 循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。下面程序将数字1~10输出到屏幕上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>;i++)</span><br><span class="line">    System.out.println(i);</span><br></pre></td></tr></table></figure><p>for语句的第一部分通常用于对计数器初始化；第二部分给出每次新一轮循环执行前要检测的循环条件；第三部分指示如何更新计数器。</p><p><strong>注：如果在for语句内部定义一个变量，这个变量就不能在循环体之外使用。另一方面，可以在各自独立的不同for循环中定义同名的变量。</strong></p></li><li><p>for each 循环</p><p>语句格式：for(variable :collection) statement </p><p>定义一个变量暂存集合中的每一个元素，并执行相应的语句/语句块。collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element : a)</span><br><span class="line">    System.out.println(element);</span><br></pre></td></tr></table></figure><p>这个循环应该读作“循环a中的每一个元素”。</p></li><li><p>循环控制 break 和 continue 语句</p><ul><li>break 的作用就是跳出一个循环或者结束一个循环。</li><li>continue 的作用是立即结束本次循环，继续执行下一次循环。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言基础02</title>
      <link href="/2018/07/29/2018/07/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002/"/>
      <url>/2018/07/29/2018/07/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h2><blockquote><p>Java 是一种强类型语言（每一个变量必须声明一种类型）。在Java中，一共有8种数据类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符类型char和一种表示真值的boolean类型。</p></blockquote><h3 id="1-1-整型（表示没有小数部分的数值，允许为负数）"><a href="#1-1-整型（表示没有小数部分的数值，允许为负数）" class="headerlink" title="1.1.整型（表示没有小数部分的数值，允许为负数）"></a>1.1.整型（表示没有小数部分的数值，允许为负数）</h3><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftqok9zd9bj20ng047t9t.jpg" alt="image"></p><ul><li>int 最常用</li><li>long 类型，数值后有一个<strong>后缀L</strong>，用于表示比如星球上的居住人数。</li><li>byte 和 short 类型用于特定场合。比如，底层的文件处理或者需要控制占用存储空间量的大数组。</li></ul><hr><h3 id="1-2-浮点类型（表示有小数部分的数值）"><a href="#1-2-浮点类型（表示有小数部分的数值）" class="headerlink" title="1.2.浮点类型（表示有小数部分的数值）"></a>1.2.浮点类型（表示有小数部分的数值）</h3><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftqoqxm1bgj20mx02owff.jpg" alt="image"></p><ul><li><p>double 表示这种类型的数值精度是 float 类型的两倍（双精度数值），绝大部分应用程序采用这种数据类型。</p></li><li><p>float类型（单精度数值），数值后有一个<strong>后缀F</strong>，在很多情况下，精度难以满足，所以有很少的情况适合使用float类型。</p><p><strong>注:</strong>没有后缀 F 的默认为 double 类型。</p></li></ul><hr><h3 id="1-3-char-类型（表示单个字符，通常用来表示字符常量，用单引号’-‘括起来）"><a href="#1-3-char-类型（表示单个字符，通常用来表示字符常量，用单引号’-‘括起来）" class="headerlink" title="1.3.char 类型（表示单个字符，通常用来表示字符常量，用单引号’ ‘括起来）"></a>1.3.char 类型（表示单个字符，通常用来表示字符常量，用单引号’ ‘括起来）</h3><h3 id="1-4-boolean-类型"><a href="#1-4-boolean-类型" class="headerlink" title="1.4.boolean 类型"></a>1.4.boolean 类型</h3><ul><li>boolean 类型有两个值：false 和 true，用来判断逻辑条件。整型值和布尔值之间不能转换。</li></ul><hr><h2 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2.字符串（String）"></a>2.字符串（String）</h2><blockquote><p>Java 字符串就是Unicode 字符序列。Java 没有内置的字符串类型，而是预先定义了一个类String，每个<strong>用双引号括起来的字符串</strong>都是String类的一个实例。</p></blockquote><h3 id="2-1-子串"><a href="#2-1-子串" class="headerlink" title="2.1.子串"></a>2.1.子串</h3><ul><li><p>String 类的 substring 方法可以从一个较大的字符串提取一个子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//输出：Hel</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-拼接"><a href="#2-2-拼接" class="headerlink" title="2.2.拼接"></a>2.2.拼接</h3><ul><li><p>Java 语言允许使用 + 号连接（拼接）两个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"Hello "</span>;</span><br><span class="line">String b = <span class="string">"World!"</span>;</span><br><span class="line">String message = a + b;</span><br><span class="line">System.out.println(message);<span class="comment">//输出：Hello World!</span></span><br></pre></td></tr></table></figure></li><li><p>当一个字符串与一个非字符串的值进行拼接时，<strong>后者</strong>被转换成字符串。</p></li></ul><h3 id="2-3-不可变字符串"><a href="#2-3-不可变字符串" class="headerlink" title="2.3.不可变字符串"></a>2.3.不可变字符串</h3><ul><li>Sring 类没有提供用于修改字符串的方法。由于不能修改，所以在Java文档中将String 类对象称为不可变字符串。</li></ul><h3 id="2-4-检测字符串是否相等"><a href="#2-4-检测字符串是否相等" class="headerlink" title="2.4.检测字符串是否相等"></a>2.4.检测字符串是否相等</h3><ul><li><p>可以用 <strong>equals</strong>方法检测两个字符串是否相等。对于表达式：s.equals(t)，如果字符串s与字符串t相等，则返回true，否则，返回false。</p><p><strong>注：</strong>不能使用 == 运算符号检测两个字符串是否相等！这个运算符只能确定两个字符串是否放在同一个位置上（同一地址）。</p></li></ul><h3 id="2-5-空串与Null串"><a href="#2-5-空串与Null串" class="headerlink" title="2.5.空串与Null串"></a>2.5.空串与Null串</h3><ul><li><p>空串 “ ” 是长度为0的字符串。可以使用代码检查一个字符串是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">""</span>))</span><br></pre></td></tr></table></figure><p>空串是一个Java对象，有自己的串长度（0）和内容（空）。</p></li><li><p>String还可以放一个特殊的值，名为 null，这表示没有任何对象与该变量有关。要检查一个字符串是否为 null ，要使用以下条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></li><li><p>要检查一个字符串既不是 null 也不是空串，需要使用以下条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; str.length() != <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之二分查找法</title>
      <link href="/2018/07/27/2018/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
      <url>/2018/07/27/2018/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简单查找法"><a href="#简单查找法" class="headerlink" title="简单查找法"></a>简单查找法</h2><p>使用简单查找法查找元素时，在最糟情况下需要查看每个元素。因此，如果列表包含8个数字，你最多需要检查8个数字。用O(n)表示简单查找法的运行时间。</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><blockquote><p>二分查找是一种算法，其输入是一个<strong>有序的元素列表</strong>。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回 null 。</p></blockquote><ul><li>猜数字游戏（1-100）</li></ul><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1fto3tbqjgsj20ob06bgn6.jpg" alt="image"></p><p>小了，但排除了一半的数字！至此，你知道1～50都小了。接下来，你猜75。</p><p><img src="https://ws2.sinaimg.cn/large/80ceacb8ly1fto3uux3svj20iu070q3t.jpg" alt="image"></p><p>大了，那余下的数字又排除了一半！使用二分查找时，你猜测的是中间的数字，从而每次都<br>将余下的数字排除一半。接下来，你猜63（50和75中间的数字）。</p><p><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1fto3vjk0brj20mz06hq4j.jpg" alt="image"></p><p>这就是二分法。</p><p><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1fto3w30ewoj20rx04aq3m.jpg" alt="image"></p><hr><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>log 10 100相当于问“将多少个10相乘的结果为100”。答案是两个：10 × 10 = 100。因此，log 10 100 = 2。对数运算是幂运算的逆运算。用O(log2 n)表示二分法的运行时间，也就是O(log n)。</p><hr><h2 id="一些常见的大O运行时间"><a href="#一些常见的大O运行时间" class="headerlink" title="一些常见的大O运行时间"></a>一些常见的大O运行时间</h2><p><strong>下面按从快到慢的顺序列出经常遇到的5种大O运行时间：</strong></p><ul><li><p>O(log n)：对数时间，这样的算法包括二分查找。</p></li><li><p>O(n)：线性时间，这样的算法包括简单查找。</p></li><li><p>O(n * log n)：这样的算法包括快速排序。</p></li><li><p>O(n2)：这样的算法包括选择排序。</p></li><li><p>O(n!)：这样的算法包括旅行商问题的解决方案。</p></li></ul><hr><h2 id="旅行商"><a href="#旅行商" class="headerlink" title="旅行商"></a>旅行商</h2><p>有一位旅行商。<br>他需要前往5个城市。</p><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1fto4hxgkp8j20a707xaar.jpg" alt="image"></p><p>这位旅行商（姑且称之为Opus吧）要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。</p><p><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1fto4ixqt99j20hd072t9j.jpg" alt="image"></p><p>推而广之，涉及n个城市时，需要执行n!（n的阶乘）次操作才能计算出结果。因此运行时间为O(n!)，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>二分查找的速度比简单查找要快许多，数据越大，差距就越明显。</li><li>O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。</li><li>算法运行时间并不以秒为单位。</li><li>算法运行时间是从其增速的角度来度量的。</li><li>算法运行时间用大O表示法表示。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记01</title>
      <link href="/2018/07/26/2018/07/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>/2018/07/26/2018/07/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><blockquote><p><strong>pwd</strong> 命令用于显示当前目录</p><p>初始化一个仓库，使用 <strong>git init</strong> 命令</p><p>查看文件内容：使用 <strong>cat <file></file></strong>命令</p><p>修改文件内容：使用 <strong>vi <file></file></strong> 命令</p></blockquote><ul><li><p>添加文件到Git仓库，分两步：</p><p>1.使用命令 <strong>git add <file></file></strong>，注意，可反复多次使用，添加多个文件。</p><p>2.使用命令 <strong>git commit -m <message></message></strong>，完成           -m 后输入本次提交说明</p></li></ul><p><strong>注：</strong>Windows目录一定要使用英文路径，绝不能出现中文。</p><hr><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><blockquote><p>要随时掌握工作区的状态，使用 <strong>git status</strong> 命令</p><p>如果 <strong>git status</strong> 告诉你有文件被修改过，用 <strong>git diff</strong> 可以查看修改内容</p><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用got reset –hard commit_id</p></blockquote><ul><li>穿梭前，用 <strong>git log</strong> 可以查看提交的历史，以便确定要回退带哪个版本  参数 –pretty=oneline（简洁版）</li><li>要重返未来，用<strong>git reflog</strong>查看历史命令，以便确定要回到未来那个版本（关机重启、命令窗口关闭使用此方法）</li></ul><p><strong>注：</strong>在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上个版本就是HEAD~100。例：git rest –hard HEAD^,查找时版本号没必要写全，Git会自动查找。</p><hr><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p>工作区：就是电脑里能看到的目录，如：learngit</p><p>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftn7bsbhttj20cq06iaa8.jpg" alt="image"></p><p><strong>stage(index)</strong>为暂存区</p><p>Git自动创建第一个<strong>分支master</strong></p><p>指向master的一个<strong>指针HEAD</strong></p><p>分解：</p><pre><code>① 使用git add 实际上就是把文件添加到暂存区② 使用git commit 实际上就是把暂存区的所有内容提交到当前分支</code></pre><p>创建Git版本库时，Git自动创建了一个master分支，所以，git commit就是往分支master上提交更改</p><hr><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><p><strong>注：</strong>每修改一次需要git add，不然不会进入commit 中</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>场景一：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改版，使用命令 <strong>git checkout  –file</strong>。</li><li>场景二：当你不但改乱了工作区某个文件的内容，还添加到暂存区时，想丢弃修改，分两步，第一步用命令<strong>git reset HEAD file </strong>就回到了场景1，然后使用场景一的方法。</li><li>场景三：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本回退</strong>一节，前提是没有推送到远程仓库 。</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>命令<strong>rm file</strong>用于删除工作区的文件。</p><p>命令 <strong>git rm file</strong> 用于删除一个文件。如果一个文件已经被提交到版本库，用于那不要担心删除，但是只能恢复到文件最新版本，且会丢失最后一次提交后修改的内容。 </p>]]></content>
      
      
      <categories>
          
          <category> 多学一招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各进制之间的转换</title>
      <link href="/2018/07/24/2018/07/%E5%90%84%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/07/24/2018/07/%E5%90%84%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-十进制和二进制之间的转换"><a href="#1-十进制和二进制之间的转换" class="headerlink" title="1.十进制和二进制之间的转换"></a>1.十进制和二进制之间的转换</h3><ul><li><p>十进制转二进制</p><p>十进制转换成二进制就是一个除以2取余的过程。最后将所有余数倒序排列，得到的数就是转换的果。</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1ftkx3k4negj205205fwek.jpg" alt="image"></p></li><li><p>二进制转十进制</p><p>二进制转换成十进制要从右向左用二进制位上的每个数去乘以2的相应次方。</p><p>如：把一个二进制数0100 0100转换为十进制，转换方式如下：</p><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1ftkztt9xmtj20ia00tjrr.jpg" alt="image"></p></li></ul><h3 id="2-二进制和八进制、十六进制之间的转换"><a href="#2-二进制和八进制、十六进制之间的转换" class="headerlink" title="2.二进制和八进制、十六进制之间的转换"></a>2.二进制和八进制、十六进制之间的转换</h3><ul><li><p>二进制转八进制</p><p>二进制转八进制时，首先需要将二进制数自右向左<strong>每三位</strong>分成一段，然后将二进制的每段的三位转为八进制的一位，转换过程中数值的对应关系如下。（<strong>注意八进制必须以0为开头</strong>）</p><p><img src="https://ws3.sinaimg.cn/large/80ceacb8ly1ftl04ao351j20jm040mxs.jpg" alt="image"></p></li><li><p>二进制转十六进制</p><p>二进制转十六进制，首先需要将二进制数<strong>每四位</strong>分成一段，查表转换即可。（<strong>注意十六进制必须以0x或0X开头</strong>）</p><p><img src="https://wx1.sinaimg.cn/large/80ceacb8ly1ftl07u2ifkj20ju04jt9s.jpg" alt="image"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多学一招 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言基础01</title>
      <link href="/2018/07/24/2018/07/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001/"/>
      <url>/2018/07/24/2018/07/Java-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><blockquote><p>关键字的编程语言里事先定义好并赋予了特殊含义的单词，也称作保留词。</p><p>使用Java关键字时，有几个要注意的地方：</p><ul><li>所有程序的关键字都是小写。</li><li>程序中的标识符不能以关键字命名。</li></ul></blockquote><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><blockquote><p>在编程中，经常需要在程序中定义一些符号来标记一些名称，如包名，类名，方法名，参数名，变量名等，这些符号被称为标识符。</p><p>定义标识符应遵循以下规则：</p><ul><li>包名所有字母一律小写，例如：cn.lisite.test。</li><li>类名和接口名每个单词的首字母都要大写，例如：Person。</li><li>常量名和方法名的每一个单词首字母小写，从第二个单词首字母大写，例如：lineNumber。</li><li>在程序中，应尽量使用有意义的单词来定义标识符，使得程序便于阅读。</li></ul></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>注释是对程序的某个功能或某行代码的解释说明，它只是在Java源文件中有效，在编译程序时编译器会忽略这些注释信息，不会将其编译到class字节码文件中去。</p><p>Java 中的注释有三种类型，具体如下：</p><ul><li>单行注释，用符号“//”表示。</li><li>多行注释，以符号“ / <em> ”开头，以符号” </em> / “结尾。</li><li>文档注释，以符号“ /*<em> ”开头，并在这是内容末尾以“ </em>/ ”结束。</li></ul></blockquote><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1.整型常量"></a>1.整型常量</h4><p>整型常量是整数类型的数据，有二进制、八进制、十进制和十六进制4种表示形式。</p><ul><li>二进制：由数字0和1组成的数字序列，前面要以 0b 或者 0B 开头。</li><li>八进制：以0开头并且其后由0~7范围内（包括 0 和 7 ）的整数组成的数字序列。</li><li>十进制：由数字0~9范围内（包括0和9）的整数组成的数字序列。</li><li>十六进制：以 0x 或者 0X 开头并且其后由0~9,A~F（包括两端）组成的数字序列。</li></ul><h4 id="2-浮点数常量"><a href="#2-浮点数常量" class="headerlink" title="2.浮点数常量"></a>2.浮点数常量</h4><p>浮点数常量就是在数学中用到的小数，分为 float 单精度浮点数和 double 双精度浮点数两种类型。</p><ul><li>单精度浮点数：后面以F或f结尾</li><li>双精度浮点数：后面以D或d结尾</li></ul><p><strong>注：在使用浮点数时也可以在结尾处不加任何的后缀，虚拟机会默认为 double 双精度浮点数。</strong></p><h4 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3.字符常量"></a>3.字符常量</h4><p>字符常量用以表示一个字符，一个字符常量要用一对英文半角格式的单引号 ‘ ‘ 引起来。</p><p><strong>注：因为Java采用的是Unicode字符集，Unicode字符以 \u 开头，空白字符在Unicode码表中对应的值为 ‘\u0000’ 。</strong></p><h4 id="4-字符串常量"><a href="#4-字符串常量" class="headerlink" title="4.字符串常量"></a>4.字符串常量</h4><p>字符串常量用以表示一串连续的字符，一个字符串常量要用一对英文半角格式的双引号 “ “ 引起来。</p><p><strong>注：一个字符串可以包含一个字符或多个字符，也可以不包含任何字符，即长度为0。</strong></p><h4 id="5-布尔常量"><a href="#5-布尔常量" class="headerlink" title="5.布尔常量"></a>5.布尔常量</h4><p>布尔常量即布尔型的两个值 true 和 false ，该常量用于区分一个事物的真与假。</p><h4 id="6-null-常量"><a href="#6-null-常量" class="headerlink" title="6.null 常量"></a>6.null 常量</h4><p>null 常量只有一个值 null ，表示对象的引用为空。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 函数</title>
      <link href="/2018/07/22/2018/07/Python-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/22/2018/07/Python-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><blockquote><p>Python内置了很多有用的函数，我们可以直接调用。</p></blockquote><ul><li>调用求绝对值函数 abs 函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-20</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>函数max() 可以接手任意多个参数，并返回最大的那个：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">-5</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>int()、float()、str()、bool()函数可以把其他数据类型转换成相对应的数据类型：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><blockquote><p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号 : ，然后，在缩进块中编写函数体，函数的 返回值 用 return语句 返回。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名 <span class="params">(参数)</span>:</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>如果没有 return 语句，函数执行完毕后也会返回结果，只是结果为 None 。return None 可以简写为 return。 函数可以同时返回多个值，但其实就是一个tuple。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><ul><li>位置参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poewr</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure><p>对于 power(x) 函数，参数x就是一个位置参数。</p><ul><li>默认参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x,n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>对于 power()函数，参数 n=2就是一个默认参数。</p><p><strong>设置默认参数时，有几点要注意：</strong></p><blockquote><ol><li>必选参数在前，默认参数在后，否则Python的解释器会报错。</li><li>如何设置默认参数，当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>默认参数必须指向不变对象。</li></ol></blockquote><p><strong>使用默认参数的好处？</strong></p><blockquote><p>最大的好处是能降低调用函数的难度。</p></blockquote><ul><li>可变参数</li></ul><blockquote><p>在Python函数中，还可以定义可变参数 。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>*numbers 是可变参数，numbers 接收的是一个tuple。</p><p>把 list 或 tuple的元素变成可变参数传进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>*nums 表示把 nums 这个 list 的所有元素作为可变参数传进去。</p><ul><li>关键字参数</li></ul><blockquote><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,**kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>,name,<span class="string">'age:'</span>,age,<span class="string">'other:'</span>,kw)</span><br></pre></td></tr></table></figure><p>**kw是关键字参数，kw接收的是一个dict。</p><p><strong>关键字参数有什么用？</strong></p><blockquote><p>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 </p></blockquote><ul><li>命名关键字参数</li></ul><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 city 和 job 作为关键字参数。这种方式定义的函数如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name,age,*,city,job)</span>:</span></span><br><span class="line">    print(name,age,city,job)</span><br></pre></td></tr></table></figure><p>和关键字参数 *<em>kw不同 ，命名关键字参数需要一个特殊分隔符 </em> ， * 后面的参数被视为命名关键字参数。 </p><ul><li>参数组合</li></ul><blockquote><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 </strong></p></blockquote><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><blockquote><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算阶乘 n! = 1 x 2 x 3 x ... x n,用函数fact(n)表示fact(n) = n! = fact(n-1) x n</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p><strong>递归函数的优点是定义简单，逻辑清晰。缺点是过深的调用会导致栈溢出。</strong></p><ul><li>解决递归调用栈溢出的方法是通过<strong>尾递归优化</strong></li></ul><blockquote><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num,product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>,num * product)</span><br></pre></td></tr></table></figure><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言基础04</title>
      <link href="/2018/07/20/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004/"/>
      <url>/2018/07/20/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-的特性"><a href="#Python-的特性" class="headerlink" title="Python 的特性"></a>Python 的特性</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><blockquote><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>,<span class="string">'Bob'</span>,<span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>,<span class="string">'Bob'</span>,<span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure><ul><li><p>变量 classmates 就是一个 list 。用<strong>len()</strong> 函数可以获得list<strong>元素的个数</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>用索引来访问list中每一个位置的元素，记得<strong>索引是从 0 开始的</strong>。当索引超出范围，Python会报一个IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是<strong>len(classmates) - 1</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Michael'</span></span><br></pre></td></tr></table></figure></li><li><p>除了计算索引位置外，还可用 -1 做索引，直接获取最后一个元素，以此类推，可以获取倒数第二个、第三个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br></pre></td></tr></table></figure></li><li><p>list 是一个可变的有序表，可以使用函数 <strong>append()</strong> 往 list 中追加元素到<strong>末尾</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>,<span class="string">'Bob'</span>,<span class="string">'Tracy'</span>,<span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用函数 <strong>insert()</strong> 将元素插入到指定位置，比如索引为 1 的位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>,<span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></li><li><p>要删除list <strong>末尾的元素</strong>，用 <strong>pop()</strong> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></li><li><p>要删除指定位置的元素，用 <strong>pop(i)</strong> 方法，其中 i 是索引位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></li><li><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></li><li><p>list 里面的元素的数据类型也可以不同，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</span><br></pre></td></tr></table></figure></li><li><p>list 元素也可以是另一个 list（list的嵌套），比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><p>拆开写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br><span class="line"><span class="comment">#如果想拿到 ‘php’ 可以写成p[1] 或者 s[2][1]，因此 s 可以看成是一个二维数组。</span></span><br></pre></td></tr></table></figure></p><ul><li>如果list中一个元素也没有，就是一个<strong>空的list，它的长度为0</strong>。</li></ul><hr><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><blockquote><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就<strong>不能修改</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>,<span class="string">'Bob'</span>,<span class="string">'Tracy'</span>)</span><br></pre></td></tr></table></figure><p><strong>!!!注：</strong>classmates这个tuple不能变了，<strong>它没有append(),insert()这样的方法</strong>，其他获取元素的方法和list是一样的，但不能赋值成另外的元素。</p><ul><li><p>不可变的tuple有什么意义？？？<br><br>因为tuple不可变，所以代码更加安全。如果可能，能用tuple替代list就尽量用tuple。</p></li><li><p>tuple的陷阱：当定义一个tuple时，在定义的时候，tuple的元素就必须确定下来。如果要定义一个空的tuple，可以写成（）；但是，要定义一个只有1个元素的tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 </p><p>所以，<strong>只有1个元素的tuple</strong>定义时必须加一个<strong>逗号,</strong>，来消除歧义： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言基础03</title>
      <link href="/2018/07/19/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003/"/>
      <url>/2018/07/19/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基础语法分为两块，包含条件判断和循环两块。条件判断主要是if语句的相关使用。循环主要是while模块的使用。</p></blockquote><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>在Python程序中，用 if 语句实现：<br><img src="https://wx4.sinaimg.cn/large/80ceacb8ly1ftf20ds8lrj204u086aai.jpg" alt="image1"><br><strong>注意不要少了冒号 ：</strong></p><h3 id="if-语句完整结构："><a href="#if-语句完整结构：" class="headerlink" title="if 语句完整结构："></a>if 语句完整结构：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">&lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="comment">#elif 为 else if 的缩写</span></span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">&lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">&lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="if-语句特点："><a href="#if-语句特点：" class="headerlink" title="if 语句特点："></a>if 语句特点：</h3><p><strong>条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。</strong></p><p><strong>!!!注：</strong>因为 input() 返回的数据类型是 str ， str 不能直接和整数比较，必须先把 str 转换成整数。Python提供了 int() 函数来完成这件事情。</p><hr><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p><strong>循环是让计算机做重复任务的有效的方法。</strong></p><ul><li>第一种循环：for … in 循环，比如计算1-10的整数之和，可以用一个sum变量做累加。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]:</span><br><span class="line">sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><ul><li>第二种循环：while 循环，只要满足条件，就不断循环，条件不满足时退出循环。比如计算100以内所有奇数之和。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">sum = sum + n</span><br><span class="line">n= n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>　　在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。　　</p><h1 id="break-和-comtinue"><a href="#break-和-comtinue" class="headerlink" title="break 和 comtinue"></a>break 和 comtinue</h1><blockquote><p>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。<strong>要特别注意</strong>，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言基础02</title>
      <link href="/2018/07/17/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002/"/>
      <url>/2018/07/17/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1ftblmcf9kij20gg06a0ss.jpg" alt="image1"></p><ul><li><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p></li><li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/80ceacb8ly1ftblnpacltj208j07qdg8.jpg" alt="image2"></p><ul><li>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</li></ul><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftblp0mtntj208e07edg3.jpg" alt="image3"></p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><blockquote><p>在最新的Python 3版本中，字符串是以<strong>Unicode编码</strong>的，也就是说，Python的字符串支持多语言。</p></blockquote><p>对于单个字符的编码：</p><ul><li><p>ord() 函数获取字符的整数表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br></pre></td></tr></table></figure></li><li><p>chr() 函数把编码转换成对应的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>由于 Python 的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。 </p></blockquote><ul><li><p>Python 对 bytes 类型的数据用<strong>带b前缀</strong>的单引号或双引号表示：x = b’ABC’</p></li><li><p>以Unicode表示的<code>str</code>通过 encode() 方法可以编码为指定的 bytes。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注："><a href="#注：" class="headerlink" title="!!!注："></a><strong>!!!注</strong>：<br></h3><p>1.纯英文的 str 可以用 ASCII 编码为 bytes，内容是一样的。<br><br>2.含有中文的 str 可以用 UTF-8 编码为bytes，但无法用 ASCII 编码，因为中文编码超出了 ASCII 编码的范围，Python会报错。</p><hr><blockquote><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 bytes  。要把 bytes 变为str ，就需要用 decode() 方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure><h3 id="注：-1"><a href="#注：-1" class="headerlink" title="!!!注："></a><strong>!!!注</strong>：<br></h3><p>1.如果 bytes 中包含无法解码的字节，decode() 方法会报错。<br><br>2.如果 bytes 中只有一小部分无效字节，可以传入errors=’ignore’ 忽略错误的字节。</p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>要计算 str 包含<strong>多少个字符</strong>，可以用 len() 函数。<br></p></li><li><p>要计算 bytes 包含<strong>多少个字节</strong>，可以用 len() 函数。<br></p></li><li><p>在操作字符串时，我们经常遇到 str 和 bytes 的互相转换。为了避免乱码问题，应当始终坚持使用 UTF-8 编码对 str 和 bytes 进行转换。<br></p></li><li><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure></li></ul><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。</p><hr><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1ftbncmjqnvj20c206f0st.jpg" alt="image3"></p><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></span><br></pre></td></tr></table></figure><p>常见的占位符有：</p><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">替换内容</th></tr></thead><tbody><tr><td style="text-align:center">%d</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制整数</td></tr></tbody></table><h3 id="注：-2"><a href="#注：-2" class="headerlink" title="!!!注："></a><strong>!!!注</strong>：<br></h3><p>1.格式化整数和浮点数还可以指定是否补0和整数与小数的位数。</p><p>2.如果你不太确定应该用什么，%s 永远起作用，它会把任何数据类型转换为字符串。</p><p>3.有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%。</p><h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3><blockquote><p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'</span>.format(<span class="string">'小明'</span>, <span class="number">17.125</span>)</span><br><span class="line"><span class="string">'Hello, 小明, 成绩提升了 17.1%'</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言基础01</title>
      <link href="/2018/07/16/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001/"/>
      <url>/2018/07/16/2018/07/Python-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：　　</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，<strong>十六进制</strong>用 <strong>0x</strong> 前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><strong>浮点数也就是小数</strong>，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把<strong>10用e替代</strong>，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p><strong>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</strong></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是以单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来的任意文本，比如’abc’，”xyz”等等。<strong>请注意</strong>，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><p>如果字符串内部既包含 ‘ 又包含 “ 怎么办？可以用<strong>转义字符\</strong>来标识，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'I\'m \"OK\"!'</span></span><br><span class="line"><span class="comment">#表示的字符串内容是：</span></span><br><span class="line">I<span class="string">'m "OK"!</span></span><br></pre></td></tr></table></figure><ul><li><p>\n表示换行</p></li><li><p>\t表示制表符</p></li><li><p>字符 \ 本身也要转义，所以 \ 表示的字符就是 \ </p></li><li><p>Python允许使用 <strong>‘’’…’’’</strong>的格式表示多行内容，还可以在前面加上 <strong>r</strong> 使用 <strong>r’’’…’’’</strong></p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>在Python中，可以直接用True、False表示布尔值<strong>（注意大小写）</strong>。</p><ul><li><p>布尔运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">5</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值可以用 and 、or 和 not 运算<br><br>and 运算是<strong>与运算</strong>，只有所有都为 True , and 运算结果才是True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ul><p>　　or 运算是<strong>或运算</strong>，只要其中有一个为 True ，or 运算结果就是 True。<br><br>　　not 运算是<strong>非运算</strong>，它是一个<strong>单目运算符</strong>，把True变成False，False变成True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>　　布尔值经常用在条件判断中，比如：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> print(<span class="string">'tennager'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>空值是Python里一个特殊的值，用None表示。<strong>None不能理解为0</strong>，因为0是有意义的，而None是一个特殊的空值。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。<br></p><p>变量在程序中就是用一个变量名表示了，变量名必须是<strong>大小写英文、数字和 _ 的组合，且不能用数字开头</strong></p><p><strong>动态语言</strong>：变量本身类型不固定。<br><br><strong>静态语言</strong>：在定义变量时必须制定变量类型，如果赋值时类型不匹配，就会报错。例如Java语言。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;<span class="comment">//a是整数型变量</span></span><br><span class="line">a = <span class="string">"ABC"</span>; <span class="comment">//错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量就是不能变的变量，比如常用的数学常数 π 就是一个常量。在Python中，通常用<strong>全部大写</strong>的变量名表示常量：</p><blockquote><p>PI = 3.141592653</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 语言简介和开发环境</title>
      <link href="/2018/07/15/2018/07/Java-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/07/15/2018/07/Java-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-语言简介"><a href="#Java-语言简介" class="headerlink" title="Java 语言简介"></a>Java 语言简介</h3><p>Java是一种高级计算机语言，它是由SUN公司（已被Oracle公司收购）于1995年5月推出的一种一个编写<strong>跨平台</strong>应用软件、完全<strong>面向对象</strong>的程序设计语言。</p><p>Java语言<strong>简单易用、安全可靠</strong>，主要面向Internet编程，自问世以来，与之相关的技术和应用发展的非常快。如今，Java技术无处不在。</p><p>Java三个开发方向</p><ul><li><p>Java  SE(Java Platform Standard Edition)标准版，是为开发普通桌面和商务应用程序提供的解决方案。Java SE是三个平台中最核心的部分，Java EE 和 Java ME 都是从Java SE 的基础上发展而来，<strong>Java SE平台中包括了Java最核心的类库</strong>，如集合、IO、数据库连接以及网络编程等。</p></li><li><p>Java EE(Java Platform Enterprise Edition)企业版，是为开发企业级应用程序提供的解决方案。Java EE可以被看做一个技术平台，该平台用于开发、装配以及部署企业级应用程序，其中主要包括Servlet、JSPJavaBean、JDBC、EJB、WebService等技术。</p></li><li><p>Java ME(Java Platform Micro Edition)小型版，是为了开发电子消费产品和嵌入式设备提供解决方案。</p></li></ul><p><strong>Java语言的特点</strong>：简单、面向对象、安全、跨平台、支持多线程。</p><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p>SUN公司提供了一套Java开发环境，简称<strong>JDK</strong>(Java Development Kit),它是整个Java的核心，其中包括Java编译器、Java运行工具、Java文档生成工具、Java打包工具等。</p><p>除了JDK，还提供了一种<strong>JRE</strong>(Java Runtime Environment)工具，它是Java 运行环境。JRE中只包含Java运行工具，<strong>JRE = JVM + API</strong>，且<strong>JDK工具中自带了一个JRE工具</strong>，开发人员只用在计算机上<strong><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">安装JDK即可</a></strong>。</p><h4 id="JDK目录介绍"><a href="#JDK目录介绍" class="headerlink" title="JDK目录介绍"></a>JDK目录介绍</h4><p>JDK安装完毕后，会在硬盘上生成一个目录，该目录被称为JDK安装目录。</p><ul><li><p>bin 目录：该目录存放一些可执行程序，如javac.exe（Java 编译器）、java.exe（Java 运行工具）等等。</p></li><li><p>db 目录：db目录是一个小型的数据库。装一个数据库软件，选择直接使用JavaDB即可。</p></li><li><p>jre 目录：意为Java程序运行时环境。它包含Java虚拟机，运行时的类包、Java应用启动器以及一个bin目录。<strong>不包含开发环境中的开发工具。</strong></p></li><li><p>include 目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是存放这些东西的。</p></li><li><p>src.zip 文件：压缩文件，其中存放Java核心类的源代码，通过该文件可以查看Java基础类的源代码。</p></li></ul><h4 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h4><blockquote><ul><li><p><strong>javac.exe</strong> 是Java的编译工具，它可以将编写好的Java文件编译成字节码文件（可执行的Java程序）。Java源文件的扩展名为 <strong>.java</strong>,编译后生成的Java字节码文件的扩展名为<strong>.class</strong>。</p></li><li><p><strong>java.exe</strong> 是Java运行工具，它会启动一个<strong>Java虚拟机（JVM）</strong>进程，Java虚拟机相当于一个虚拟的操作系统，它专门负责运行Java 编译器生成的字节码文件（.class 文件）</p></li></ul></blockquote><h4 id="path-环境变量"><a href="#path-环境变量" class="headerlink" title="path 环境变量"></a>path 环境变量</h4><blockquote><p>path环境变量是系统环境变量的一种，它是用于保存一系列的路径，每个路径之间以分号分隔。</p></blockquote><p>设置path环境变量步骤（win10）：此电脑–&gt;右键属性–&gt;高级系统设置–&gt;环境变量–&gt;系统环境变量–&gt;找到Path，将javac命令所在目录（JDK下bin目录）路径粘贴到其中–&gt;设置完毕，打开命令行窗口输入javac，命令行会显示帮助信息。</p><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftah5z7ugdj20r60e7dgw.jpg" alt="image"></p><h4 id="classpath-环境变量"><a href="#classpath-环境变量" class="headerlink" title="classpath 环境变量"></a>classpath 环境变量</h4><blockquote><p>classpath 环境变量也用于保存一系列路径，它和 path 环境变量的查看与配置方式完全相同。当 Java 虚拟机需要运行一个类时，会在classpath环境变量中锁定路径下寻找所需的 class 文件。<strong>注</strong>：从JDK5.0开始，如果classpath 环境变量没有进行设置，Java虚拟机会自动将其设置为“.” ，也就是当前目录。</p></blockquote><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><p><a href="https://notepad-plus.en.softonic.com/" target="_blank" rel="noopener">notepad++</a>/<a href="https://www.editplus.com/download.html" target="_blank" rel="noopener">Editpuls</a>/<a href="http://www.ultraedit.com/downloads/uex.html" target="_blank" rel="noopener">UltraEdit</a>: 文本编辑器，入门推荐</p></li><li><p><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a>：IDE，插件式，通用灵活，中期可用</p></li><li><p><a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">Inteilj Idea</a>：IDE，功能强大，新宠，Java EE 和 Java web 开发必备</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言简介和初体验</title>
      <link href="/2018/07/11/2018/07/Python%20%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/07/11/2018/07/Python%20%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%92%8C%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章纯手打，如果文章哪里有错别字还请谅解！</p></blockquote><hr><h3 id="Python语言介绍："><a href="#Python语言介绍：" class="headerlink" title="Python语言介绍："></a>Python语言介绍：</h3><ul><li><p><strong>面向对象，解释型计算机程序设计</strong></p></li><li><p><strong>设计哲学</strong>：优雅，明确，简单，可读性强</p></li><li><p><strong>优点</strong>：功能强大，开发效率高，应用广泛，易上手，语法简洁</p></li><li><p><strong>缺点</strong>：</p><p>①运行速度慢    和C语言相比，因为Python是解释型的语言，代码会在执行时会一行一行地翻译成CPU能理解的机器码<br><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1ftac0qb0eqj20am05274d.jpg" alt="image01"></p><p>C语言，运行前直接编译成CPU能执行的机器码</p><p>②代码不能加密</p><p> <strong>用途</strong>：网页开发、可视化（GUI）界面开发、网络、系统编程、数据分析、及其学习、网络爬虫、科学计算    </p></li><li><p><strong>著名网站</strong>：雅虎地图、谷歌中很多组成部分、Youtube、豆瓣网</p></li><li><p><strong>与其他语言比较</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">print(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://wx3.sinaimg.cn/large/80ceacb8ly1ftac6vgrd4j20by050t8w.jpg" alt="image2"></h2><h2 id="安装Python和配置环境："><a href="#安装Python和配置环境：" class="headerlink" title="安装Python和配置环境："></a>安装Python和配置环境：</h2><p>1.安装Python</p><p><strong>注</strong>：确认设备为32位还是64位操作系统，注意平台分为AMD和Intel，特别要注意勾上    Add Python 3.6 to PATH，然后点“Install Now”即可完成安装。</p><p>2.启动Python</p><ul><li><p>启动方式：Python图形化界面</p></li><li><p>Windows:启动命令提示符窗口-&gt;输入python-&gt;退出exit()并回车</p></li><li><p>Mac&amp;&amp;Linux:-打开终端-&gt;运行python3</p></li></ul><p>3.Python Interpreter(Python解释器)</p><ul><li>python.exe 为python解释器</li></ul><p>4.环境变量</p><ul><li>将解释器的路径加入系统环境变量的path中</li></ul><hr><h3 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h3><p>用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行程序了。</p><p><strong>Python交互模式和直接运行.py文件有什么区别？</strong></p><ul><li>直接输入 python 直接进入交互模式，相当于启动了Python解释器，但是等你一行一行输入源码，每输入一行就执行一行。</li><li>直接运行.py 文件相当于启动了Python解释器，然后一次性执行多行代码。</li></ul><p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ftacckvcyaj208w06oweh.jpg" alt="image3"></p><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul><li>输出</li></ul><p>　　用print()在括号中加上字符串，就可以想屏幕上输出指定的文字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure></p><p>　　print()函数也可以接受多个字符串，用逗号”,”隔开，就可以连成一串输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'My name'</span>,<span class="string">'is'</span>,<span class="string">'xxx'</span>)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">My name <span class="keyword">is</span> xxx</span><br></pre></td></tr></table></figure></p><p>　　print()会依次打印每个字符串，遇到逗号”,”就会输出一个空格。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'This is'</span>,<span class="string">'my'</span>,<span class="string">'book'</span>)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">This <span class="keyword">is</span> my book</span><br></pre></td></tr></table></figure></p><p>　　print()也可以打印整数，或者计算结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">300</span>)</span><br><span class="line"><span class="number">300</span></span><br><span class="line">print(<span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure></p><ul><li>输入</li></ul><p>　　Python提供了一个input(),可以让用户输入字符串，并存放到一个变量里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = input() <span class="comment">#输入任意字符，按下回车完成输入</span></span><br><span class="line">name <span class="comment">#输入变量名name，查看变量内容</span></span><br><span class="line">Michael</span><br></pre></td></tr></table></figure></p><p>　　input()可以让你显示一个字符串来提示用户。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'please enter your name: '</span>)</span><br><span class="line">please enter your name:</span><br><span class="line">print(<span class="string">'hello,'</span>, name)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>1.认识Python<br>2.学会如何把Python安装到计算机中，并且熟练打开和退出Python交互式环境。</p><ul><li>在Windows上运行Python时，请先启动命令行，然后运行python。</li><li>在Mac和Linux上运行Python时，请打开终端，然后运行python3。</li></ul><p>3.在Python交互式模式下，可以直接输入代码，然后执行，并立刻得到结果。<br>　命令行模式下，可以直接运行.py文件。<br>4.输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World！</title>
      <link href="/2018/07/09/Hello-World%EF%BC%81/"/>
      <url>/2018/07/09/Hello-World%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wx2.sinaimg.cn/large/80ceacb8ly1ft3l7ku2b9j20m80dwq3z.jpg" alt="enter image description here"></p><h1 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello World！"></a>Hello World！</h1><h2 id="博客第一帖。"><a href="#博客第一帖。" class="headerlink" title="博客第一帖。"></a>博客第一帖。</h2><h2 id="Share-to-u"><a href="#Share-to-u" class="headerlink" title="Share to u."></a>Share to u.</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
