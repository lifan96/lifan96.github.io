---
title: 关于多线程
date: 2019-08-02 18:23:13
categories: Java
---

## 1. 创建多线程

### 创建Thread类的子类

java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须**继承Thread类**

**实现步骤:**
  1.创建一个Thread类的子类
  2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)
  3.创建Thread类的子类对象
  4.调用Thread类中的方法start方法,开启新的线程,执行run方法

- void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
- 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。
- 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
- java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行

### 实现Runnable接口

实现步骤:
        1.创建一个Runnable接口的实现类
        2.在实现类中重写Runnable接口的run方法,设置线程任务
        3.创建一个Runnable接口的实现类对象
        4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象
        5.调用Thread类中的start方法,开启新的线程执行run方法

- 实现Runnable接口创建多线程程序的好处:
          1.避免了单继承的局限性
              一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类
              实现了Runnable接口,还可以继承其他的类,实现其他的接口
          2.增强了程序的扩展性,降低了程序的耦合性(解耦)
              实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)
              实现类中,重写了run方法:用来设置线程任务
              创建Thread类对象,调用start方法:用来开启新线程

### 获取线程名称
1.使用Thread类中的方法getName()
  String getName() 返回该线程的名称。
2.可以**先获取到当前正在执行的线程**,使用线程中的方法getName()获取线程的名称
  **static Thread currentThread() **返回对当前正在执行的线程对象的引用。
  Thread.currentThread().getName()

### 设置线程名称（了解）

1.使用Thread类中的方法setName(名字)
  void setName(String name) 改变线程名称，使之与参数 name 相同。
2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字
  Thread(String name) 分配新的 Thread 对象。

### 线程睡眠

public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行

使用：Thread.sleep(暂停时间)           

### 匿名内部类实现线程的创建

匿名:没有名字
内部类:写在其他类内部的类
    
匿名内部类作用:简化代码
把子类继承父类,重写父类的方法,创建子类对象合一步完成
把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成
匿名内部类的最终产物:子类/实现类对象,而这个类没有名字
    
格式:
  new 父类/接口(){
   重复父类/接口中的方法
   };

```java
public class Demo01InnerClassThread {
    public static void main(String[] args) {
        //线程的父类是Thread
        // new MyThread().start();
        new Thread(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"黑马");
                }
            }
        }.start();

        //线程的接口Runnable
        //Runnable r = new RunnableImpl();//多态
        Runnable r = new Runnable(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"程序员");
                }
            }
        };
        new Thread(r).start();

        //简化接口的方式
        new Thread(new Runnable(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"传智播客");
                }
            }
        }).start();
    }
}

```

## 2. 解决线程安全

### 使用同步代码块

格式:
synchronized(锁对象){
   可能会出现线程安全问题的代码(访问了共享数据的代码)
   }

注意:
  1.通过代码块中的锁对象,可以使用任意的对象
  2.但是必须保证多个线程使用的锁对象是同一个
  3.锁对象作用:把同步代码块锁住,只让一个线程在同步代码块中执行

### 使用同步方法

使用步骤:
1.把访问了共享数据的代码抽取出来,放到一个方法中
2.在方法上添加synchronized修饰符

格式:定义方法的格式
修饰符 synchronized 返回值类型 方法名(参数列表){
   可能会出现线程安全问题的代码(访问了共享数据的代码)
   }

### 使用Lock锁

解决线程安全问题的三种方案:使用Lock锁
**java.util.concurrent.locks.Lock接口**
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
Lock接口中的方法:
  void lock()获取锁。
  void unlock()  释放锁。
  **java.util.concurrent.locks.ReentrantLock implements Lock接口**

使用步骤:
1.在成员位置创建一个ReentrantLock对象
2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

## 3. 线程状态

![image](https://ws2.sinaimg.cn/large/80ceacb8ly1g0afwosfsjj20im09y0ug.jpg)

### Timed Waiting （计时等待）

进入到TimeWaiting(计时等待)有两种方式
1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态
2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态

唤醒的方法:

- void notify() 唤醒在此对象监视器上等待的单个线程。
- void notifyAll() 唤醒在此对象监视器上等待的所有线程。

![image](https://ws4.sinaimg.cn/large/80ceacb8ly1g0ag0wars9j20hd0ax0t2.jpg)

### BLOCKED （锁阻塞）

![image](https://ws2.sinaimg.cn/large/80ceacb8ly1g0ag14hbjrj20ha0axq38.jpg)

### Waiting （无限等待）

![image](https://ws3.sinaimg.cn/large/80ceacb8ly1g0ag3ib6ssj20hl0dpgma.jpg)

### 等待唤醒案例:线程之间的通信
创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)
创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子

注意:

- 顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行
- 同步使用的锁对象必须保证唯一
- 只有锁对象才能调用wait和notify方法

## 4. 线程通信

> **概念：**多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。

**为什么要处理线程间通信：**

多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。

**如何保证线程间通信有效利用资源：**

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— **等待唤醒机制。**

**调用wait和notify方法需要注意的细节**

1. wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。

