---
title: 理解计算机网络知识点
date: 2019-08-08 15:23:13
categories: Java
---
## 网络分层（自底向上）

1. **OSI 七层参考模型**

   1.1 物理层

   - 主要定义物理设备的标准，如网线类型，光纤的接口类型等
   - 单位：传输**比特流**（0101）<--->转换为机器码

   1.2 数据链路层

   - 如何格式化数据以进行传输，控制对物理介质的访问。提供对错误的检测和纠正，确保传输的可

     靠性

   - 单位：将比特数据--->**帧**

   1.3 网络层

   - 将网络地址翻译成对应的物理地址，如何将发送方的数据路由到接收方
   - **路由器属于网络层**
   - 单位：**数据报**
   - 主要协议：IP

   1.4 传输层

   - 解决主机之间的数据传输，可以是不同网络之间
   - 单位：**分段**
   - TCP：面向连接的、可靠的、基于字节流的传输层通信协议
   - UDP

   1.5 会话层

   - 建立和管理应用程序之间的通信

   1.6 表示层

   - 信息的语法语义以及它们的关联

   1.7 应用层

   - HTTP协议

2. **TCP/IP**

## TCP的三次握手

1. TCP简介
   - 面向连接的、可靠的、基于字节流的传输层通信协议
   - 将应用层的数据流分隔成报文段并发送给目标节点的TCP层
   - 数据包都有序号，**对方收到则发送ACK确认**，未收到则重传
   - 使用奇偶校验和来检验数据在传输过程中是否有错误
2. TCP Flags
   - URG：紧急指针标志  为1时表示有效，为0则忽略
   - **ACK：确认序号标志**  为1时表示有效，为0不含确认信息，则忽略
   - PSH：push标志  为1时指示接收方在接收到的报文段尽快交给应用程序，而不是在缓冲区排队
   - RST：重置连接标志 用于重置由于主机崩溃产生的错误连接、非法的报文段和拒绝连接
   - **SYN：**同步序号，用于建立连接过程
   - **FIN：**finish标志，用于释放连接
3. 流程
   - 第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，进入SYN_SEND状态，等待服务器确认
   - 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
   - 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=ack+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
   
   ![批注 2019-08-08 101941](https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4t6mlcwj20cq08l0th.jpg)

### 问题

1. 为什么需要三次握手才能建立起连接？

   为了初始化Sequence Number的初始值

2. 首次握手的隐患---SYN超时

   - Server收到Client的SYN，回复SYN-ACK的时候未收到ACK的确认
   - Server不断重试直至超时，Linux默认等待63秒才断开连接
   - **针对SYN Flood的防护措施**
     - SYN队列满后，通过tcp_syncookies参数回发SYN Cookie
     - 若为正常连接则Client会回发SYN Cookie，直接建立连接

3. 建立连接后，Client出现故障怎么办？

   保活机制

   -  向对方发送保活探测报文，如果未收到响应则继续发送
   - 尝试次数达到保活探测数仍未收到响应则中断连接

## TCP的四次挥手

“挥手”是为了终止连接 

1. 流程

   - 第一次挥手：Client发送一个FIN，用来关闭Client到server的数据传送，Client进入FIN_WAIT_1状态
   - 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态
   - 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK
   - 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手

   ![批注 2019-08-08 104547](https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4tsq86yj20bw08rdgl.jpg)
### 问题

1. 为什么会有TIME_WAIT状态？
   - 确保有足够的时间让对方收到ACK包
   - 避免新旧连接混淆
2. 为什么需要四次握手才能断开连接？
   - 因为全双工，发送方和接收方都需要FIN报文和ACK报文
3. 服务器出现大量CLOSE_WAIT状态的原因
   - 对方关闭Socket连接，我方忙于读或写，没有及时关闭连接
     - 检查代码，特别是释放资源的代码
     - 检查配置，特别是处理请求的线程配置

## TCP和UDP的区别

- 面向连接 VS 无连接
- 可靠性
- 有序性
- 速度
- 量级

## TCP的滑动窗口

1. RTT和RTO

   - RTT：发送一个数据包到收到对应的ACK，所花费时间
   - RTO：重传时间间隔

2. TCP使用滑动窗口做流量控制与乱序重排

   - 保证TCP的可靠性
   - 保证TCP的流控特性

3. 窗口数据的计算过程

   ![批注 2019-08-08 111202](https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4ujj3w0j20ev05ydg4.jpg)

   - AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd - LastByteRead)
   - EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked)

4. TCP会话的发送方

   四种状态

   - Sent and Acknowledged
   - Sent But Not Yet Acknowledged（发送窗口）
   - Not Sent Recipient Ready to Receive（发送窗口）
   - Not Sent Recipient NOT Ready to Receive

5. TCP会话的接收方

   三种状态

   - Received and Acknowledged
   - Not Yet Received，Transmitter Permitted To Send（接收窗口）
   - Not Yet Received，Transmitter May Not Send

## HTTP

1. 超文本传输协议特点：

   - 支持客户、服务器模式
   - 简单快速
   - 灵活
   - 无连接
   - 无状态

2. HTTP请求结构

   ![批注 2019-08-08 112622](https://ws3.sinaimg.cn/large/80ceacb8ly1g5t4vadz7nj20ed04hq36.jpg)

3. HTTP响应结构

   ![批注 2019-08-08 112740](https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4vpaahyj20ea04ajrl.jpg)

4. 请求/响应的步骤

   - 客户端连接到Web服务器
   - 发送HTTP请求
   - 服务器接收请求并返回HTTP响应
   - 释放TCP连接
   - 客户端浏览器解析HTML内容

5. HTTP状态码

   五种

   - 1xx：指示信息---表示请求已接收，继续处理
   - 2xx：成功---表示请求已被成功接收、理解、接受
   - 3xx：重定向---要完成请求必须进行更进一步地操作
   - 4xx：客户端错误---请求有语法错误或请求无法实现
   - 5xx：服务器端错误---服务器未能实现合法的请求

### 问题

1. 在浏览器地址栏键入URL，按下回车之后经历的流程？

   - DNS解析
   - TCP连接
   - 发送HTTP请求
   - 服务器处理请求并返回HTTP报文
   - 浏览器解析渲染页面
   - 连接结束

2. 常见的HTTP状态码

   - 200 OK：正常返回信息
   - 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
   - 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
   - 403 Forbidden：服务器收到请求，但是拒绝提供服务
   - 404 Not Found：请求资源不存在，eg，输入错误的URL
   - 500 InternalServer Error：服务器发生不可预期的错误
   - 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间可能恢复正常

3. GET请求和POST请求的区别

   - Http报文层面：GET将请求信息放在URL,POST放在报文体中
   - 数据库层面：GET符合幂等性和安全性，POST不符合
   - 其他层面：GET可以被缓存、被存储，而POST不行

4. Cookie和Session的区别

   4.1 Cookie简介

   - 是由**服务器发给客户端**的特殊信息，以文本的形式存放在客户端
   
   - 客户端再次请求时，会把Cookie回发

   - 服务器接收到后，会解析Cookie生成与客户端相对应的内容

   - Cookie的设置以及发送过程

     ![批注 2019-08-08 134015](https://ws1.sinaimg.cn/large/80ceacb8ly1g5t4vy8140j20e606yjrk.jpg)
   
   4.2 Session简介
   
     - **服务器端的机制**，在服务器上保存的信息
   
     - 解析客户端请求并操作session id，按需保存状态信息
   
     - 使用Cookie来实现
   
     - 使用URL回写来实现
   
       ![批注 2019-08-08 134823](https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4wsjhkgj20dq05nweq.jpg)
   
   4.3 区别
   
   - **Cookie数据存放在客户端的浏览器上，Session数据放在服务器上**
   - **Session相对于Cookie更安全**
   - **若考虑减轻服务器负担，应当使用Cookie**
## HTTP和HTTPS的区别

1. SSL简介（Security Sockets Layer，安全套接层）
   - 为网络通信提供安全及数据完整性的一种安全协议
   - 是操作系统外的API，SSL3.0后更名为TLS
   - 采用**身份验证和数据加密**保证网络的安全和数据的完整性
2. 加密方式
   - 对称加密：加密解密都是用同一个秘钥
   - 非对称加密：加密使用的秘钥和解密使用的秘钥是不相同的 
   - 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
   - 数字签名：证明某个消息或文件是某人发出/认同的
3. HTTPS数据传输流程
   - 浏览器将支持的加密算法信息发送给服务器
   - 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
   - 浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器
   - 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
   - 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据
   
4. HTTP和HTTPS的区别
   - HTTPS需要到CA申请证书，HTTP不需要 
   - HTTPS密文传输，HTTP明文传输
   - 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
   - HTTPS = HTTP +加密 +认证+完整性保护，较HTTP安全

## Socket

![批注 2019-08-08 154824](https://ws4.sinaimg.cn/large/80ceacb8ly1g5t4x9lt20j20ex08kgm3.jpg)





   