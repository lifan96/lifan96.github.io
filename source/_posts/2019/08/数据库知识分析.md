---
title: 数据库知识分析
date: 2019-08-09 15:23:13
categories: Java
---
## 设计数据库

![批注 2019-08-08 163614](https://wx3.sinaimg.cn/large/80ceacb8ly1g5t4xw7828j20d608bjrw.jpg)

## 索引模块

1. 为什么要使用索引？ 

   - 快速查询数据

2. 什么样的信息能成为索引？

   - 主键、唯一键以及普通索引等

3. 索引的数据结构

   - 生成索引，建立二叉查找树进行二分查找
   - 生成索引，建立B-Tree结构进行查找
   - 生成索引，建立B+-Tree结构进行查找
   - 生成索引，建立Hash结构进行查找

4. B-Tree

   - 根节点至少包括两个孩子
   - 树中每个节点最多含有m个孩子（m>=2）
   - 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子（ceil（）取上限）
   - 所有叶子节点都位于同一层

5. B+-Tree

   - 其定义基本与B树相同
   - **非叶子节点的子树指针与关键字个数相同**
   - 非叶子节点的子树指针P[i]，指向关键字值 [k[i],k[i+1]) 子树
   - 非叶子节点仅用来索引，数据都保存在叶子节点中
   - 所有叶子节点均有一个链指针指向下一个叶子节点

6. 结论

   **B+Tree更适合用来存储索引**

   - B+树的磁盘读写代价更低
   - B+树的查询效率更加稳定
   - B+树更有利于对数据库的扫描

7. Hash索引

   缺点

   - 仅仅能满足“=”，“IN”，不能使用范围查询
   - 无法被用来避免数据的排序操作
   - 不能利用部分索引键查询
   - 不能避免表扫描
   - 遇到大量Hash值相等的情况后性能比不一定就会比B-Tree索引高\

8. BitMap索引是个神器（位图索引）

## 密集索引和稀疏索引的区别

- 密集索引文件中的**每个搜索码值都对应一个索引值**
- 稀疏索引文件**只为索引码的某些值建立索引项**

InnoDB

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一和唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

### 问题

1. 如何定位并优化慢查询SQL

   - 根据慢日志定位慢查询SQL

     ![photo](https://wx1.sinaimg.cn/large/80ceacb8ly1g5t4z686ggj20ah03lwen.jpg)

   - 使用explain等工具分析SQL

     - type：出现index、all则需要优化
     - extra：出现using filesort、using temporary则需要优化

   - 修改SQL或者尽量让SQL走索引

     ```sql
     alter table person_info_large add index idx_name(name); /*为某个字段增加索引*/
     /*强制通过某个索引查询*/
     select count(id) from person_info_large force index(primary);
     ```

2. 联合索引的最左匹配原则的成因

   联合索引：有两个字段组成的索引

   - 最左匹配原则：mysql会一直向右匹配直到遇到范围查询就停止匹配
   - = 和 in 可以乱序，mysql的查询优化器会帮你优化成索引可以识别的形式

   **直接使用第二个字段是用不到索引的**

3. 索引是建立得越多越好吗？

   不是。

   - 数据量小的表不需要建立索引，建立会增加额外的索引开销
   - 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
   - 更多的索引也意味着需要更多的空间

## MyISAM与InnoDB关于锁方面的区别是什么？

1. MyISAM默认用的是表级锁，**不支持行级锁**
2. **InnoDB默认用的是行级锁，也支持表级锁**
   - 二段锁：加锁和解锁是分成两个步骤进行的

- 共享锁：上了共享锁之后，依然可以上共享锁，不支持上排它锁

- 排它锁：上了排它锁，另外的读或写都是不能操作的

  ![批注 2019-08-09 091319](https://ws3.sinaimg.cn/large/80ceacb8ly1g5t8ivw58ej20d6056gln.jpg)

MyISAM适合的场景

- 频繁执行全表count语句
- 对数据进行增删改的频率不高，查询非常频繁
- 没有事务

InnoDB适合的场景

- 数据增删改查都相当频繁
- 可靠性比较高，要求支持事务

## 数据库锁的分类

- 按锁的粒度划分，可分为表级锁、行级锁、页级锁
- 按锁级别划分，可分为共享锁、排它锁
- 按加锁方式划分，可分为自动锁、显示锁
- 按操作划分，可分为DML锁（表数据）、DDL锁（表结构）
- 按使用方式划分，可分为乐观锁、悲观锁

## 数据库事务的四大特性

ACID

- 原子性（Atomic）：事务包含的所有操作，要么全部执行，要么全部回滚
- 一致性（Consistency）：事务应确保数据库的状态从一致状态到另一个一致状态，一致性状态，也就是数据的完整性
- **隔离性（Isolation）**：一个事务的执行不能影响其他事物的执行
- 持久性（Durability）：当系统或者介质发生故障时，确保以提交事务的更新不能丢失，即对已提交事物的更新能恢复

## 事务隔离级别以及各级别下的并发访问问题

- 更新丢失（一个事务的更新覆盖了另一个事务的更新）--- mysql所有事务隔离级别在数据库层面上均可避免

- **脏读** --- READ-COMMTTED事务隔离级别以上可避免

  `一个事务读到一个未提交事务的数据`

- **不可重复读** --- REPEATABLE-READ事务隔离级别以上可避免

  `事务A多次读取同一数据，在读取过程中进行了数据的更新并提交，事务A多次读取数据时不一致`

- **幻读** --- SERIALIZABLE事务隔离级别可避免

  `事务A读取与搜索条件相匹配的若干行，事务B插入或删除行修改事务A的结果集，导致事务A看起来像出现幻觉一样`
  
  ![批注 2019-08-09 100211](https://ws4.sinaimg.cn/large/80ceacb8ly1g5t8j3pagvj20kw08mgmk.jpg)

## InnoDB可重复读隔离级别下如何避免幻读

- 表象：快照读（非阻塞读） -- 伪MVCC
  - 当前读：select ... lock in share mode,select...for udate，update，delete，insert
  - 快照读：不加锁的非阻塞读，select
- 内在：next-key锁（行锁+gap锁）
  - 行锁
  - **Gap锁**
    - 对主键索引或者唯一索引会用Gap锁吗？
      - 如果where条件全部命中，则不会用Gap锁，只会加记录锁
      - 如果where条件部分命中或者全不命中，则会用Gap锁
      - Gap锁会用在非唯一索引或者不走索引的当前读中

## RC、RR级别下的InnoDB的非阻塞读如何实现

- 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段
- undo日志
- read view

## 语法部分

- GROUP BY
- HAVING：过滤组
- 统计相关：COUNT，SUM，MAX，MIN，AVG