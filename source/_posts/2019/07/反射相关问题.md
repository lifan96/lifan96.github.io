---
title: 反射相关问题
date: 2019-07-22 18:23:13
categories: Java
---

## 三种字节码加载方式

1. 第一阶段：是字节码文件

   Class.forName("全类名")：将字节码文件加载进内存，返回Class对象

   全类名：包名.类名

   **多用于配置文件，将类名定义在配置文件中。读取文件，加载类**

2. 第二个阶段：已经将class加载进内存中

   类名.class：通过类名的属性class获取
   **多用于参数的传递**

3. 第三阶段：已经有对象

   对象.getClass()：getClass()方法在Object类中定义着

   **多用于对象的获取字节码的方式**

## 不带declare和带declare的区别

- 不带的只能获取公共成员变量、构造方法和方法
- 带的可以或群全部的成员变量、构造方法和方法（需要暴力反射）

## 暴力反射

访问私有成员变量、构造方法和方法都可以使用暴力反射（主要解决私有修饰符访问错误）

```java
//获取指定名称的成员变量
        Field d = personClass.getDeclaredField("d");
        //忽略访问权限修饰符的安全检查
        d.setAccessible(true);  //暴力反射
        Object value2 = d.get(p);
        System.out.println(value2);
```

## 使用空参构造方法创建对象

如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法

## getMethods()

获取类中所有的方法（是包含Object中的方法）

## 获取类名

```java
//1.获取Person的Class对象
        Class personClass = Person.class;
//2.获取类名
String className = personClass.getName();
System.out.prinln(className);
```

## 手写小框架

> 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法

- 实现：
  1. 配置文件
  2. 反射
- 步骤：
  1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
  2. 在程序中加载读取配置文件
  3. 使用反射技术来加载类文件进内存
  4. 创建对象
  5. 执行方法

```java
package cn.lifan.reflect;



import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * 框架类
 */
public class ReflectTest {
    public static void main(String[] args) throws Exception {
        //可以创建任意类的对象，可以执行任意方法
        /*
            前提：不能改变类的任何代码
         */
        //1.在程序中加载读取配置文件
        //1.1创建Properties对象
        Properties pro = new Properties();
        //1.2加载配置文件，转换为一个集合
        //1.2.1获取class目录下的一个配置文件
        ClassLoader classLoader = ReflectTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("pro.properties");
        pro.load(is);

        //获取配置文件中定义的数据
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");

        //3.加载该类进内存
        Class cls = Class.forName(className);

        //4.创建对象
        Object obj = cls.newInstance();

        //5.获取方法对象
        Method method = cls.getMethod(methodName);

        //6.执行方法
        method.invoke(obj);
    }
}

```

