---
title: 数据结构与算法-入门篇
date: 2019-06-23 15:23:13
categories: 数据结构与算法
---

## 10个数据结构

> 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

## 10个算法

> 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回朔算法、动态规划、字符串匹配算法

## 复杂度分析

### 一、如何分析算法的执行效率和资源消耗

```c
int cal(int n){
    int sum = 0;
    int i = 1;
    for(; i <= n; ++i){
        sum = sum + i;
    }
    return sum;
}
/*
第 2 、 3 行代码分别需要 1 个 unit_time 的执行时间，第 4 、 5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time 
*/
```

#### 1. 大O表示法

```
T(O) = O(f(n))
```

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
当 n 很大时，你可以把它想象成 10000 、 100000 。而公式中的**低阶、常量、系数**三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。

#### 2. 分析时间复杂度3个方法

- 只关注循环执行次数最多的一段代码

- 加法法则：总复杂度等于量级最大的那段代码的复杂度

  如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))

- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

  如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))

#### 3. 几种常见时间复杂度实例分析

> 常量阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n^2)...
>
> 指数阶O(2^n)、阶乘阶O(n!)

- **O(1)**

  O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

- **O(logn)、O(nlogn)**

  2^x =n --> x = log2n

  对数之间是可以互相转换的，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn) 。

  将O(logn)循环n次就是O(nlogn)，比如，归并排序、快速排序的时间复杂度都是 O(nlogn) 。

- **O(m+n)、O(m*n)**

  ```c
  int cal(int m, int n) {
  	int sum_1 = 0;
  	int i = 1;
  	for (; i < m; ++i) {
  		sum_1 = sum_1 + i;
  	}
  	int sum_2 = 0;
  	int j = 1;
  	for (; j < n; ++j) {
  		sum_2 = sum_2 + j;
  	}
  	return sum_1 + sum_2;
  }
  ```

  从代码中可以看出， m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n) 。

------

------

  #### 4. 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

#### 5. 常见空间复杂度

> O(1)、O(n)、O(n^2)

### 二、浅析最好、最坏、平均、均摊时间复杂度

- **最好情况时间复杂度**就是，在最理想的情况下，执行这段代码的时间复杂度。
- **最坏情况时间复杂度**就是，在最糟糕的情况下，执行这段代码的时间复杂度。
- **平均时间复杂度**：用代码在所有情况下执行的次数的加权平均值表示。
-  **均摊时间复杂度**：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。
- 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度

---

---

