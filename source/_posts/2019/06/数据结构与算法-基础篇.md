---
title: 数据结构与算法-基础篇
date: 2019-06-24 10:23:13
categories: 数据结构与算法
---

## 数组

### 一、为什么很多编程语言中数组都从0下标开始的

>数组（Array）是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组**具有相同类型的数据**。

#### 1. 如何实现随机访问？

- 当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

  **a[i] address = base_address + i * data_type_size**

  **base_address**：内存块首地址

  **data_type_size**：数组中每个元素的大小（），数组中存储int类型，data_type_size为4个字节

- **数组支持随机访问，根据下标随机访问的时间复杂度为 O(1) 。**

#### 2. 低效的“插入”和“删除”操作

- 如果我们需要将一个数据插入到数组中的**第 k 个位置**。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位；如果在**数组的末尾插入元素**，那就不需要移动数据了，这时的时间复杂度为 O(1) 。但如果在**数组的开头插入元素**，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n) 。

- 如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果**删除数组末尾的数据**，则最好情况时间复杂度为 O(1) ；如果**删除开头的数据**，则最坏情况时间复杂度为 O(n)。

#### 3. 警惕数组越界访问问题

```java
int[] a = new int[3];
a[3] = 1; // java.lang.ArrayIndexOutOfBoundsException
```

#### 4. 容器是否能完全代替数组？

- ArrayList最大的优势就是可以将很多数组操作的细节封装起来
- 支持动态扩容
- **在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适**

#### 5. 解答

- **公式对比**：

  以0为起始下标：a[k]_address = base_address + k * type_size

  以1位起始下标：a[k]_address = base_address + (k-1)*type_size

- **结论**：数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

## 链表

### 一、如何实现LRU缓存淘汰算法？

>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：**先进先出策略 FIFO** （ First In ， First Out ）、**最少使用策略 LFU** （ Least Frequently Used ）、**最近最少使用策略 LRU** （ Least Recently Used ）。

#### 1. 单链表

我们习惯性地把第一个结点叫作**头结点**，把最后一个结点叫作**尾结点**。其中，**头结点用来记录链表的基地址**。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是**指向一个空地址NULL**，表示这是链表上最后一个结点

- **查找**：链表要想随机访问第 k 个元素，需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。
- **插入和删除**

![插入和删除](https://wx4.sinaimg.cn/large/80ceacb8ly1g4srcdkavej20qe0efq3s.jpg)

#### 2. 循环链表

- **循环链表的尾结点指针是指向链表的头结点**。
- **循环链表的优点是从链尾到链头比较方便**。
- 当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。

#### 3. 双向链表

- 向链表，顾名思义，**它支持两个方向**，每个结点不止有一个后继指针 next 指向后面的结点，**还有一个前驱指针 prev 指向前面的结点**。

  ![双向链表](https://ws4.sinaimg.cn/large/80ceacb8ly1g4srkgt6jpj20pp08uwez.jpg)

- **双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。**

#### 4. 双向循环链表

![双向循环链表](https://wx3.sinaimg.cn/large/80ceacb8ly1g4srxt9fa7j20qy0bk756.jpg)

#### 5. 数组和链表的最大区别

**数组的缺点是大小固定**，一经声明就要占用整块**连续内存空间**。如果声明的**数组过大**，系统可能没有足够的连续内存空间分配给它，导致 “ **内存不足**（ out of memory ） ” 。如果声明的**数组过小**，则可能**出现不够用的情况**。这时只能再申请一个更大的内存空间，把原数组拷贝进去，**非常费时**。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

#### 6. 解答

我们维护一个**有序单链表**，**越靠近链表尾部的结点是越早之前访问的**。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

- 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
- 如果此数据没有在缓存链表中，又可以分为两种情况：
  - 如果此时缓存未满，则将此结点直接插入到链表的头部；
  - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

#### 7. 设计思想

时空替换思想： “ 用空间换时间 ”  与 “ 用时间换空间 ”
当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。