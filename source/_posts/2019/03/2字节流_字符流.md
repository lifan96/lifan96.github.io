---
title:字节流_字符流
date: 2019-03-11 09:23:13
categories: Java
---

## 第一章 IO概述

I：input输入（读取数据）

O：output输出（写入数据）

流：数据（字符、字节）1字符=2字节 1字节=8个二进制位（bit）

输入：把硬盘中的数据，读取到内存中

输出：把内存中的数据，写入到硬盘中

## 顶级父类

|            |           **输入流**            |              输出流              |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |

## 第二章 字节流

### 2.1 一切皆为字节

>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。

### 2.2 字节输出流【OutputStream】

`java.io.OutputStream `**抽象类**是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。**它定义了字节输出流的基本共性功能方法**。

* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
* `public abstract void write(int b)` ：将指定的字节输出流。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

#### 2.2.1 FileOutputStream类

继承OutputStream类——【文件字节输出流】

作用：把内存中的数据写入到硬盘的文件中

#### 2.2.2构造方法
- `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 

- `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  

- 参数：

  ​	String name:目的地是一个文件的路径

  ​	File file:目的地是一个文件

- 构造方法的作用：

  1. 创建一个FileOutputStream对象
  2. 会根据方法中传递的文件夹/文件路径，创建一个空的文件
  3. 会把FileOutputStream对象指向创建好的对象

#### 2.2.3写入数据原理（内存--->硬盘）

Java程序--->JVM（Java虚拟机）--->os（操作系统）--->os调用写数据的方法---->把数据写入文件中

#### 2.2.4 字节输出流的使用步骤（重）

1. 创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
2. 调用FileOutputStream对象中的方法write()，把数据写入到文件中
3. 释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提升程序的效率）

#### 2.2.5记事本打开文件原理

任意文本编辑器（记事本，notepad++），在打开文件的时候都会查询编码表，把字节转化为字符表示

#### 2.2.6一次写多个字节的方法

- public void write(byte[ ] b)：将b.length字节从指定的字节数组写入此输入流

  一次写多个字节：

  ​    如果写的第一个字节是正数（0-127），那么显示的时候会查询Ascii表

  ​    如果写的第一个字节是负数，那第一个字节会和第二个字节，两个字节组合成一个中文显示 ，查询系统编码（GBK）

- public void write(byte[ ] b,int off,int len)：把字节数组的一部分写到文件中

  int off：数组的开始索引

  int len：写几个字节

#### 2.2.7 写入字符串的方法

可以使用String类中的方法把字符串，转换为字节数组

- byte[ ] getBytes( ) 

```java
byte[] bytes = "你好".getBytes();
```

#### 2.2.8 数据的追加写/续写

使用两个参数的构造方法

- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  

- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。

- 参数：

  ​	File file,String name：写入数据的目的地

  ​	boolean append：追加写开关 

  ​		true：创建对象不会覆盖原文件，继续在文件末尾追加写

  ​		false：创建一个新的文件，覆盖原文件

#### 2.2.9 写换行

写换行符号：

​	Windows：\\r\n

​	Linux：/n

​	mac：/r

```java
fos.write("\r\n".getBytes());
```

---

---

### 2.3 字节输入流【InputStream】

`java.io.InputStream `**抽象类**是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 读取文件中的一个字节并返回，读取到文件的末尾会返回-1
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

#### 2.3.1 FileInputStream类

文件字节输入流

作用：把硬盘文件中的数据，读取到内存中使用

#### 2.3.2 构造方法

- FileInputStream(String name)

- FileInputStream(File file)

- 参数：读取文件的数据源

  ​	String name：文件的路径

  ​	File file：文件

- 构造方法的作用：

   	1. 会创建一个FileInputStream对象
      	2. 会把FileInputStream对象指定构造方法中读取到的文件

#### 2.3.3 读取数据的原理（硬盘-->内存）

Java程序-->JVM-->OS-->OS读取数据的方法-->读取文件

#### 2.3.4 字节输入流的使用步骤（重）

1. 创建FileInputStream对象，构造方法中绑定要读取的数据源
2. 使用FileInputStream对象中的方法read，读取文件
3. 释放资源

#### 2.3.5 字节输入流读取字节数据

不知道文件中有多少字节，使用while循环，while循环结束条件，读取到-1的时候结束

```java
import java.io.FileInputStream;
import java.io.IOException;

public class Demo01InputStream {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("E:\\a.txt");
        int len = 0;
        while((len = fis.read()) != -1){
            Ststem.out.println(len);
        }
        fis.close();
    }
}

/*
布尔表达式(len = fis.read()) != -1
1.fis.read()：读取一个字节
2.len = fis.read()：把读取到的字节赋值给变量len
3.(len = fis.read()) != -1：判断len是否等于-1
*/
```

#### 2.3.6 字节输入流一次读取一个字节的原理

#### 2.3.7字节输入流一次读取多个字节

int read(byte[ ] b) ：从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中

明确两件事情：

 1. 方法的参数byte[ ]的作用？

    数组起到缓冲作用，存储读取到的多个字节

    数组的长度一般定义为1024（1kb）或者1024的整数倍

 2. 方法的返回值int是什么？

    每次读取的有效个数

String类的构造方法
        String(byte[] bytes) :把字节数组转换为字符串
        String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节    个数

```java
import com.sun.org.apache.xpath.internal.operations.String;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Arrays;

public class Demo02InputStream {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("E:\\b.txt");
        byte[] bytes = new byte[1024];
        int len = 0;
        while((len = fis.read(bytes)) != -1){
            System.out.println(new String(bytes,0,len));
        }
    }
}
```

![image](https://ws3.sinaimg.cn/large/80ceacb8gy1g0uc9de7pfj211s0en0vs.jpg)

### 2.4 文件的复制

![image](https://ws2.sinaimg.cn/large/80ceacb8gy1g0uc8u1fyoj211s0enwfh.jpg)

一读一写
明确：
​	数据源
​	数据的目的地

步骤：

1. 创建一个字节输入流对象，构造方法绑定要读取的数据源
2. 创建一个字节输出流对象，构造方法绑定要写入的目的地
3. 使用字节输入流中的方法read( )读取文件
4. 使用字节输出流的方法write( )，把读取到的字节写入到目的地文件中去
5. 释放资源

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Demo01CopyFile {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("D:\\1.jpg");
        FileOutputStream fos = new FileOutputStream("E:\\1.jpg");

//        //一次读取一个字节写一个字节的方式
//        int len = 0;
//        while((len = fis.read()) != -1 ){
//            fos.write(len);
//        }

        //使用缓冲数组读取多个字节，写入多个字节
        byte[] bytes = new byte[1024];
        int len = 0;
        while ((len = fis.read(bytes)) != -1){
            fos.write(bytes,0,len);
        }
        //先关闭写，后关闭读的
        fos.close();
        fis.close();
    }
}
```

### 2.5 使用字节流读取中文的问题

当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。

1个中文
​	GBK：占用2个字节
​	UTF-8：占用3个字节

---

---

## 第三章 字符流

### 3.1 字符输流【Reader】

`java.io.Reader`**抽象类**是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    
- `public int read()`： 从输入流读取一个字符。 
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

### 3.2 FileReader类

`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。文件输入流。

**java.io.FileReader extends InputStreamReader extends Reader**

作用：把硬盘文件中的数据以字符的方式读取到内存中

> 小贴士：
>
> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。
>
> idea中UTF-8
>
> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。

#### 构造方法

- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   
- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。

#### 构造方法的作用

- 创建一个FileReader对象
- 会把FileReader对象指向要读取的文件

#### 字符数输入流使用步骤

① 创建FileReader对象，构造方法中绑定要读取的数据源

②使用FielReader对象中的方法reader()读取文件

③释放资源

```java
import com.sun.org.apache.xpath.internal.operations.String;

import java.io.FileReader;
import java.io.IOException;

public class demo01Reader {
    public static void main(String[] args) throws IOException {
        FileReader fr = new FileReader("E:\\c.txt");
//        每次读一个字符        
//        int len = 0;
//        while((len = fr.read()) != -1){
//            System.out.print((char) len);
//        }
//      每次读多个字符
        char[] cs = new char[1024];
        int len = 0;
        while ((len = fr.read(cs)) != -1){
            /*
            String类的构造方法
                String(char[] value) 把字符数组转换为字符串
                String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数
             */
            System.out.println(new String(cs,0,len));
        }
        fr.close();
    }
}
```

### 3.3字符输出流【Writer】

`java.io.Writer `**抽象类**是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `void write(int c)` 写入单个字符。
- `void write(char[] cbuf) `写入字符数组。 
- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 
- `void write(String str) `写入字符串。 
- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
- `void flush() `刷新该流的缓冲。  
- `void close()` 关闭此流，但要先刷新它。 

### 3.4 FileWriter类

**java.io.FileWriter extends OutputStreamWriter extends Writer**

作用：把内存中的字符数据写入到硬盘中

#### 构造方法

- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要写入的File对象。   
- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要写入的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。

#### 构造方法的作用

①会创建一个FileWriter对象

②会根据构造方法中传递的文件/文件的路径，创建文件

③会把创建的FileWriter对象指向创建好的文件

#### 字符输出流的使用步骤

①创建FileWriter对象，构造方法中绑定要写入数据的目的地

②使用FileWriter中的方法write，把数据写入内存缓冲区中（字符转换为字节的过程）

③使用FileWriter中的方法flush，把内存缓冲区中的数据刷新到文件中

④释放资源（会把内存缓冲区中的数据刷新到文件中）

```java
import java.io.FileWriter;
import java.io.IOException;

public class Demo01FileWriter {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("E:\\c.txt");
        fw.write(97);
        //fw.flush(); 
        fw.close();
    }
}
```

#### 关闭和刷新区别

因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。

- `flush`：刷新缓冲区，流对象可以继续使用。
- `close `：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

#### 写其他数据

1. 写字符数组

   ```java
   import java.io.FileWriter;
   import java.io.IOException;
   
   public class Demo03Writer {
       public static void main(String[] args) throws IOException {
           FileWriter fw = new FileWriter("E:\\a.txt");
           char[] cs = {'a','b','c','d'};
           fw.write(cs);
           //写字符数组的一部分
           fw.write(cs,1,3);
           fw.close();
       }
   }
   ```

2. 写字符串

   ```java
   import java.io.FileWriter;
   import java.io.IOException;
   
   public class Demo03Writer {
       public static void main(String[] args) throws IOException {
           FileWriter fw = new FileWriter("E:\\a.txt");
           fw.write("西安交通大学城市学院");
           //写字符串部分
           fw.write("西安交通大学城市学院",0,5);
           fw.close();
       }
   }
   ```

3. 续写和换行

   续写,追加写:使用两个参数的构造方法

   FileWriter(String fileName, boolean append)

   FileWriter(File file, boolean append)

   参数:
               String fileName,File file:写入数据的目的地
               boolean append:续写开关 true:不会创建新的文件覆盖源文件,可以续写; false:创建新的文件覆盖源文件

   换行:换行符号
           windows:\r\n
           linux:/n
           mac:/r

   ```java
   import java.io.FileWriter;
   import java.io.IOException;
   
   public class Demo04Writer {
       public static void main(String[] args) throws IOException {
           FileWriter fw = new FileWriter("E:\\a.txt",true);
           for (int i = 0; i <= 10; i++) {
               fw.write("Hello World!"+i+"\r\n");
           }
           fw.close();
       }
   }
   ```

   > 小贴士：**字符流，只能操作文本文件，不能操作图片，视频等非文本文件。**
   >
   > 当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流

   ---
   ---

## 第四章 IO异常的处理

   > 在JDK1.7之前建议使用`try...catch...finally` 代码块，处理异常部分

   ```java
   //格式
   try{
       //可能产生异常的代码
   }catch(异常类变量 变量名){
       //异常处理逻辑
   }finally{
       //一定会指定代码
       //资源释放
   }
   ```

```java
import java.io.FileWriter;
import java.io.IOException;

public class Demo01TryCatch {
    public static void main(String[] args) {
        //提高变量fw的作用域,让finally可以使用
        //变量在定义的时候,可以没有值,但是使用的时候必须有值
        //fw = new FileWriter("09_IOAndProperties\\g.txt",true); 执行失败,fw没有值,fw.close会报错
        FileWriter fw = null;
        try{
            //可能会产出异常的代码
            fw = new FileWriter("w:\\09_IOAndProperties\\g.txt",true);
            for (int i = 0; i <10 ; i++) {
                fw.write("HelloWorld"+i+"\r\n");
            }
        }catch(IOException e){
            //异常的处理逻辑
            System.out.println(e);
        }finally {
            //一定会指定的代码
            //创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放
            if(fw!=null){
                try {
                    //fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
}

```

   ### 4.1 JDK 7 的新特性

   > JDK7的新特性
   >     在try的后边可以增加一个(),在括号中可以定义流对象
   >     那么这个流对象的作用域就在try中有效
   >     try中的代码执行完毕,会自动把流对象释放,不用写finally

   ```java
   //格式
   try(定义流对象;定义流对象....){
               可能会产出异常的代码
           }catch(异常类变量 变量名){
               异常的处理逻辑
           }
   ```

   ```java
   import java.io.FileInputStream;
   import java.io.FileOutputStream;
   import java.io.IOException;
   
   public class Demo02Jdk7 {
       public static void main(String[] args) {
           try( FileInputStream fis = new FileInputStream("D:\\1.jpg");
                FileOutputStream fos = new FileOutputStream("E:\\1.jpg");
           ){
               int len = 0;
               while((len = fis.read()) != -1 ){
                   fos.write(len);
               }
           }catch (IOException e){
               System.out.println(e);
           }
       }
   }
   ```

   ### 4.2 JDK 9新特性

   >try的前边可以定义流对象
   >在try后边的()中可以直接引入流对象的名称(变量名)
   >在try代码执行完毕之后,流对象也可以释放掉,不用写finally

```java
//格式
 A a = new A();
 B b = new B();
 try(a,b){
 	可能会产出异常的代码
 	}catch(异常类变量 变量名){
      		异常的处理逻辑
 	}
```

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Demo03Jdk9 {
    public static void main(String[] args) throws FileNotFoundException {
        FileInputStream fis = new FileInputStream("D:\\1.jpg");
        FileOutputStream fos = new FileOutputStream("E:\\1.jpg");

        try (fis;fos){
            int len = 0;
            while((len = fis.read()) != -1 ){
                fos.write(len);
            }
        }catch (IOException e){
            System.out.println(e);
        }
    }
}
```






